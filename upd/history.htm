<HTML xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"
	xmlns:w="urn:schemas-microsoft-com:office:word">
	<HEAD>
		<title>040622 вт</title>
		<META http-equiv="Content-Type" content="text/html; charset=windows-1251">
	</HEAD>
	<BODY lang="RU" style="tab-interval: 35.4pt" bgColor="#ccffcc">
		ЦЬ
		<meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
		<meta content="True" name="vs_snapToGrid">
		<meta content="True" name="vs_showGrid">
		<meta content="Word.Document" name="ProgId">
		<meta content="Microsoft Word 10" name="Generator">
		<meta content="Microsoft Word 10" name="Originator">
		<LINK href="history_files/filelist.xml" rel="File-List"> <!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Anton L. Varfolomeev</o:Author>
  <o:LastAuthor>Anton L. Varfolomeev</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>2</o:TotalTime>
  <o:Created>2004-06-25T09:07:00Z</o:Created>
  <o:LastSaved>2004-06-25T09:07:00Z</o:LastSaved>
  <o:Pages>2</o:Pages>
  <o:Words>352</o:Words>
  <o:Characters>2011</o:Characters>
  <o:Company>InFRAN</o:Company>
  <o:Lines>16</o:Lines>
  <o:Paragraphs>4</o:Paragraphs>
  <o:CharactersWithSpaces>2359</o:CharactersWithSpaces>
  <o:Version>10.4219</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->  <!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:View>Print</w:View>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:FormsDesign/>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]-->
		<style> @page Section1 {size: 595.3pt 841.9pt; margin: 2.0cm 42.5pt 2.0cm 3.0cm; mso-header-margin: 35.4pt; mso-footer-margin: 35.4pt; mso-paper-source: 0; }
	P.MsoNormal { FONT-SIZE: 12pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: ""; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman" }
	LI.MsoNormal { FONT-SIZE: 12pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: ""; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman" }
	DIV.MsoNormal { FONT-SIZE: 12pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Times New Roman"; mso-style-parent: ""; mso-pagination: widow-orphan; mso-fareast-font-family: "Times New Roman" }
	SPAN.SpellE { mso-style-name: ""; mso-spl-e: yes }
	SPAN.GramE { mso-style-name: ""; mso-gram-e: yes }
	DIV.Section1 { page: Section1 }
		</style>
		<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]-->  <!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="1026"/>
</xml><![endif]-->  <!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
		<p class="MsoNormal"><b style="mso-bidi-font-weight: normal">040622 <span class="SpellE">вт</span><o:p></o:p></b></p>
		<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
		<p class="MsoNormal" align="left">- перенесены <span class="SpellE">хардовые</span> 
			фрагменты из Act2<o:p></o:p></p>
		<p class="MsoNormal">- изменен <span class="SpellE">тулбар</span><o:p></o:p></p>
		<p class="MsoNormal">- разрешение кнопок "новое окно" и "<span class="SpellE">Go</span>"</p>
		<p class="MsoNormal">- пересылка <span class="SpellE">рисовательных</span> команд<o:p></o:p></p>
		<p class="MsoNormal">- динамическое отображение изменения скоростных режимов<o:p></o:p></p>
		<p class="MsoNormal">- первая попытка рисования<o:p></o:p></p>
		<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
		<p class="MsoNormal"><span style="COLOR: #993300"><FONT color="#000099">TODO!<o:p></o:p></FONT></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"><FONT color="#000099">- правильный 
					перенос включенных каналов при изменении их количества<o:p></o:p></FONT></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"><FONT color="#000099">- разобраться с <span class="SpellE">
						непересылкой</span> <span class="SpellE">рисовательных</span> сообщений <span class="GramE">
						множественным</span> <span class="SpellE">осциллам</span><o:p></o:p></FONT></span></p>
		<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
		<p class="MsoNormal">-------------------------------------------------------<o:p></o:p></p>
		<p class="MsoNormal"><b style="mso-bidi-font-weight: normal">040623 <span class="GramE">ср</span><o:p></o:p></b></p>
		<p class="MsoNormal">- первое решение проблемы с рассылкой сообщений: я пытался
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>обрабатывать их 
			в <span class="SpellE">PreTranslateMessage</span> - и происходило
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>следующее: 
			сообщение попадало в основной цикл, откуда - <span class="GramE">в</span>
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span><span class="SpellE">
				PreTranslateMessage</span> главного окна - а в нем вызывалась соотв.
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>функция лишь для 
			"активного" вида. Чтобы попасть в "нужное
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>окно", 
			необходимо дойти до <span class="SpellE">DispatchMessage</span> - то есть 
			избежать
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>"предобработки", 
			а затем обрабатывать сообщение в общей карте.<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>Но! Этот метод 
			работает в однопоточной модели. При переходе <span class="GramE">к</span>
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span><span class="SpellE">
				многопоточности</span> (что желательно) может <span class="SpellE">поднадобиться</span>
			и возврат
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>к <span class="SpellE">
				PreTranslate</span>...<o:p></o:p></p>
		<p class="MsoNormal"><o:p>&nbsp;</o:p></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>А вообще день омрачен двумя событиями: разговором с ЯА, <span class="GramE">в</span>
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>котором он сообщил о своем решении оставить меня <span class="GramE">на</span>
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>финансово-руководящем посту, а также <span class="GramE">безумно-бесполезным</span>
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>визитом в Эльдорадо (попытка забрать оплаченные телефоны):
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>больше часа ожидания без какого-либо толку....<o:p></o:p></span></p>
		<p class="MsoNormal">----------------------------------------------------------<o:p></o:p></p>
		<p class="MsoNormal"><b style="mso-bidi-font-weight: normal">040624 <span class="SpellE">чт</span><o:p></o:p></b></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>Продолжение разговора с ЯА: сообщил ему о своем решении -
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>"зашарить" финансы с Шестопаловой. Еще одна поездка <span class="GramE">в</span>
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>"Эльдорадо" - телефоны получил.<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>
			<o:p></o:p></p>
		<p class="MsoNormal">- Попытался покрасить <span class="SpellE">триггерные</span> полоски 
			в разные цвета -
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>получается <span class="GramE">
				рябое</span> и некрасивое...<o:p></o:p></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp; </span>
			<o:p></o:p></p>
		<p class="MsoNormal">-------------------------------------------------------------<o:p></o:p></p>
		<p class="MsoNormal"><b style="mso-bidi-font-weight: normal">040625 <span class="SpellE">пт</span><o:p></o:p></b></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>Пришла первая из ожидаемых трех <span class="SpellE">Амазоновских</span> 
				посылок -
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span><span class="SpellE">Bootstrap</span> <span class="SpellE">Methods</span>... 
				Интересно, когда появятся остальные
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>две - вроде как они более актуальны. <span class="GramE">Хотя и эта (даже 
					при </span>
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>беглом взгляде в автобусе) - весьма <span class="GramE">полезная</span>.<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: green"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;
				</span>Зашел в Кабинет - выписал сейф, кресло KSI и пару вешалок<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>
			<o:p></o:p></p>
		<p class="MsoNormal"><span style="COLOR: #993300">TODO:<o:p></o:p></span></p>
		<p class="MsoNormal"><span class="GramE"><span style="COLOR: #993300"># не мешать <span class="SpellE">
						TouchProof</span> каналы с обычными (неправильное поведение при</span> </span>
			<span style="COLOR: #993300">
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"><span style="mso-spacerun: yes">&nbsp;</span><span class="GramE">изменении</span>
				количества каналов)<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"># плохо ведет себя при "ручных" 
				изменениях - почему-то
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"><span style="mso-spacerun: yes">&nbsp;</span>сбрасывает 
				режим на "ноль"<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"># начать фрагмент сохранения 
				параметров-переменных<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"># хорошо бы добраться до настоящего 
				рисования... Тогда яснее
				<o:p></o:p></span></p>
		<p class="MsoNormal"><span style="COLOR: #993300"><span style="mso-spacerun: yes">&nbsp;</span>будет...</span></p>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p></o:p></SPAN>&nbsp;</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">Сделано:</FONT></o:p>
			</SPAN>
		</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">- 13:55, с 
						режимами было запутано: в одном месте хранил как long (полную информацию), в 
						других - пытался использовать как short (номер режима). Частично распутал.... </FONT>
				</o:p></SPAN></P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">- 17:20 - очень 
						долго провозился с изначально неверной адресацией карты (там столько раз 
						перерасчитываются размеры и количество рядов...) В итоге удалил пересчет из 
						OnSize, оставив только в Resize - в таком режиме вроде работает... </FONT>
				</o:p></SPAN></P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#ff0000">очередная 
						проблема: при создании нового файла в "дочернюю карту" передается нечто 
						запредельное.</FONT></o:p>
			</SPAN>
		</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">Это очередное 
						"рассогласование": передается "максимально возможное" количество каналов (а не 
						заданное)</FONT></o:p>
			</SPAN>
		</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">- 19:02 - однако, 
						"заданные" - это то, что реально присутствует. А для работы с даннными нужно 
						учитывать то количество каналов, которое соответствует данному режиму (именно 
						столько и передается). Заведена новая переменная <FONT color="#003399">CMainFrame::m_nActChans</FONT>;</FONT></o:p>
			</SPAN>
		</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000"></FONT></o:p></SPAN>&nbsp;</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">- 20:34 Для 
						отображения изменения длительности (как и для всего другого) необходимой 
						оказалась "прямая связь" между диаловой закладкой и собственно осциллом. Тогда 
						попробовал изменить и активацию (без выхода в главное окно), перепробовал 
						разные варианты (мигающее окно и проч.) - но остановился на самом простом: 
						только для правильного отображения активного не-дочернего окна и в нем тоже 
						titlebar нужно рисовать вручную.</FONT></o:p>
			</SPAN>
		</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">&nbsp; Не 
						забывать, что соответствие между комбо-боксом длительности и самой 
						длительностью - списковое!!! То есть нужен будет способ, которым можно из 
						длительности получать позицию списка... </FONT><FONT color="#009966">Или 
						все-таки хранить именно позицию - и пересчетный массив???</FONT></o:p>
			</SPAN>
		</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000">&nbsp;&nbsp; </FONT>
					<FONT color="#ff0000">Мысль!!! Надпись <U><STRONG>Trigger</STRONG></U> должна быть 
						кнопкой, и по этой кнопке выводить соотв. диалог.</FONT></o:p>
			</SPAN>
		</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#ff0000"></FONT></o:p></SPAN>&nbsp;</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000"></FONT></o:p></SPAN>&nbsp;-------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040628 пн</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">- Сообразив, что в диалогах мне понадобится и парочка 
			фильтров, еще раз "подвинул" карты - и обнаржил, что отрисовка стала совсем 
			неправильной (карта не сразу изменяется при изменении размера - пропадают 
			клетки). Так что пришлось отменить с таким трудом найденный "выход" (отмену 
			изменения по OnSize() ). Соответственно, вернулась и старая проблема 
			(неправильное изначальное "масшабирование") - но на этот раз решил ее двойным 
			вызовом CStatMap::Resize из CLeftDlg::SetNofChans.</P>
		<P class="MsoNormal">- Плюс к тому, неправильно отрисовывалась свежезаведенная 
			рамочка для фильтров - ей нужен стиль Transparent!!!</P>
		<P class="MsoNormal">- Ну и пришлось изменить стартовый и минимальный размер 
			"диалогбара".</P>
		<P class="MsoNormal"><FONT color="#000099">todo!!!!</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">Не исправлено удаление дочерних окон (что-то 
				неправильно удаляется из списка - остаются ссылки на отсутствующие окна) !!!!</FONT></P>
		<P class="MsoNormal"><FONT color="#ff3300"></FONT>&nbsp;</P>
		<P class="MsoNormal"><SPAN style="COLOR: #993300"><o:p><FONT color="#000000"></FONT></o:p></SPAN>&nbsp;---------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040630 ср</STRONG></P>
		<P class="MsoNormal">- в принципе приготовился перейти к рисованию, но сообразил, 
			что до того нужно проверить, что у меня с переменными и с памятью:</P>
		<P class="MsoNormal">- в CActDView нужны отдельные буфера для</P>
		<P class="MsoNormal">&nbsp; - триггерного канала (WORD* m_pTrigBuf)</P>
		<P class="MsoNormal">&nbsp; - референса (long* m_pRefBuf)</P>
		<P class="MsoNormal">&nbsp; - для отдельных каналов (размер увеличивается на 
			количество отображаемых каналов)</P>
		<P class="MsoNormal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			(long* m_pChanBuf)</P>
		<P class="MsoNormal">А вот с памятью оказалось не так просто: сначала довольно 
			долго соображал, каким же именно образом мне ее проверять (нужны не только 
			соответствующие "разрешения", но и в определенном порядке - и
		</P>
		<P class="MsoNormal">_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF 
			); для того, чтобы память проверялась при выходе, но и "локальные проверки" при 
			создании-удалении дочерних окон). Ну а потом, естественно, оказалось что память 
			я теряю в катастрофических количествах. По очень простой причине: при открытии 
			нового окна соответствующие объекты создаются (командой new) - а кто их удалять 
			будет? Первые попытки отследить логику удаления тоже успеха не принесли...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040701 чт</STRONG></P>
		<P class="MsoNormal">- Слава богу, с памятью разобрался. Все удаления производятся 
			в соотв. функциях CMainFrame (</P>
		<P class="MsoNormal">CMainFrame::OnViewClose и CMainFrame::OnDlgClose), и 
			заключаются в выполнении команд</P>
		<P class="MsoNormal">delete m_arpView[idx]; delete m_arpDialog[idx]; - никакие 
			DestroyWindow и принудительные вызовы деструкторов при этом не нужны!!! Да, 
			было бы правильнее заводить вектора из мудрых указателей - но не до того, с 
			ними тоже будут проблемы (создание элемента вектора и проч.). Поэтому при 
			закрытии главного окна приходится "вручную" сначала удалять все созданные 
			объекты-окна - а уже потом "чистить" сами вектора. В итоге от утечек избавился</P>
		<P class="MsoNormal">- Немножко изменил рисование: после всяких там изменений 
			заливаю исходный битмэп серым...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">1825: Собственно, уже час (больше, если считать по 
			астрономическому времени и меньше, если выкинуть из него почти непрерывные 
			беседы с Бехтеревым о Брюлях и эпизодические воспоминания об ANOVA) размышляю 
			на тему организации CActDView::OnPlot. Основной вопрос таков: на входе я 
			получаю "массив каналов", включающий ВСЕ ПОТЕНЦИАЛЬНО ВОЗМОЖНЫЕ (первым идет 
			статусный канал). А вот разбираться с ними (из чего считать референт, какие 
			отбирать для отображения) я должен исходя из "карт", имеющих иную структуру - 
			если бы я еще помнил, какую... Буду пытаться вспоминать....&nbsp;</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">----------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040703 сб</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Первое задание: карта точно должна отображать количество 
			установленных модулей (то есть работать и при нечетном количестве тоже) - и 
			строго возвращать нули для отсутствующих, а также и выходящих за рамки режима 
			модулей.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Решение проблемы:</P>
		<P class="MsoNormal">1.&nbsp;При изменении числа модулей в главное окно 
			отправляется WM_DIZ_CHANGEMODE, где оно обрабатывается в PreTranslateMessage - 
			и оттуда вызываются методы SetNofChans(m_nChans,m_nTouch) для картосодержащих 
			диалогов ("левого" и "баров")</P>
		<P class="MsoNormal">2. Оттуда вызвались m_Map.Resize(-1,N,nTouch); , где N = 
			nChans/32; Для более правильной обработки нужно вызывать не с N (числом строк), 
			а с реальным числом каналов.</P>
		<P class="MsoNormal">-1407: почти перешел на реальные каналы - но в "левом" диалоге 
			не работает отображение отсутствующих, а в "барах" отображение работает - но не 
			отключается функция включения/выключения.</P>
		<P class="MsoNormal">- 1412: с отображалкой разобрался (использовал неверное 
			логическое сочетание наличия родительской карты и количества каналов) - а вот 
			теперь хочу, чтобы не работали включение/выключение и тултип.</P>
		<P class="MsoNormal">- 1420: запрет на отрисовку и отлов сообщений для 
			отсутствующих модулей сделан (в CStatMap::OnMouseMove)</P>
		<P class="MsoNormal">Теперь нужно, чтобы все это правильно передавалось в "рабочие 
			части" программы...</P>
		<P class="MsoNormal">.....</P>
		<P class="MsoNormal">- 1809 - Думая (как бы) о дальнейших шагах в программе, сам 
			занялся апдейтом XP на ноутбуке (что-то он глючит - то ли сам сайт, то ли 
			пиратские номера чувствует). Проапдейтил, поставил Офис, сейчас ставлю MSVC - а 
			мысли все же блуждают. А именно: пользовать для референтов и списка каналов 
			настоящие динамические вектора (CSimpleArray&lt;int&gt;). А где их нужно 
			создавать-менять? Видимо, там, где меняются карты. А где они меняются? Похоже, 
			что все это происходит в CDlgView::RedrawMap (по крайней мере, туда направляюсь 
			из главного окна после изменений в "родительской" карте.) Точно: туда же 
			попадаю и при перерисовке "своих" карт.</P>
		<P class="MsoNormal">- 1843 Вектора заведены в диалоге, добавлены функции доступа и 
			подсчета.</P>
		<P class="MsoNormal">-&nbsp;В очередной раз убеждаюсь в необходимости "двойной 
			связки" (диалог-вид). Завел в виде указатель на диалог, устанавливамый в той 
			самой функции (диалога), которая заполняем в нем m_pView;</P>
		<P class="MsoNormal">1850. ATAC! Я где-то утерял способность изменять размер карт 
			(как левой, так и остальных) при изменении числа установленных модулей....</P>
		<P class="MsoNormal">- 1908 - решил: не хватало скобочек вокруг "добавления лишнего 
			модуля" в выражении</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">...замораживаю ноутбук, пакую сегодняшние изменения и статьи - 
			пойду домой...</P>
		<P class="MsoNormal">--------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040705 пн</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Очередные "проблемы" с бухгалтерией, выход на работу 
			Шестопаловой - то есть опять день заполнен непонятно чем. Лишь под вечер - 
			немного "программирования" - все еще на подступах к рисованию. Для упрощения (и 
			ускорения) доступа беру из векторов референсных и отображаемых каналов не <FONT color="#0000cc">
				CSimpleArray&lt;int&gt;*,</FONT> а собственно <FONT color="#0000cc">int*</FONT>
			(получаемый по <STRONG><FONT color="#3300cc">GetData())</FONT></STRONG></P>
		<P class="MsoNormal">------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040706 вт</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Несмотря на продолжение диалогов с ремонтниками и проч., 
			программой удалось позаниматься поплотнее - даже с замачиванием электродов.</P>
		<P class="MsoNormal">Нелады оказались уже с этим - пока беседовал с Витой, система 
			перешла в состояние CMS out of range, и продолжала возвращаться в оное при 
			попытке подключить одновременно 16 A-каналов, Ext после промывки заработали.</P>
		<P class="MsoNormal">Выявлены основные проблемы:</P>
		<P class="MsoNormal">- я неправильно определяю число каналов: при разрешении Ext 
			(Mode &gt;= 4) под них отводится 32(!!!!) последних канала, в итоге уменьшается 
			число доступных пиновых - и соответствующим образом изменяется и положение 
			Ext-каналов в реально получаемом массиве данных, то есть они начинаются :</P>
		<P class="MsoNormal">режим&nbsp;&nbsp; начало Ext</P>
		<P class="MsoNormal">&nbsp;&nbsp;&nbsp; 
			4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 232</P>
		<P class="MsoNormal">&nbsp;&nbsp;&nbsp; 
			5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 104</P>
		<P class="MsoNormal">&nbsp;&nbsp;&nbsp; 
			6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			40</P>
		<P class="MsoNormal">&nbsp;&nbsp;&nbsp; 
			7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			8</P>
		<P class="MsoNormal">(числа - при подсчете с нуля:; реально им предшествует еще два 
			"канала" - синхро и режим)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">- Очень долго мудрил с порядком каналов: ПЕРЕДАЮТСЯ они в 
			исходном интерливинге</P>
		<P class="MsoNormal">- Появляется очень сильный вопрос: а нужна ли мне "двойная 
			буферизация": сейчас в таймерной функции я складываю все полученные данные в 
			"промежуточный буфер" (один и тот же - то есть без двойной буферизации) - а 
			потом в функциях "видов" раскидываю его на каналы. А что мне это дает, кроме 
			лишних операций пересылки?</P>
		<P class="MsoNormal">Можно было бы еще понять, если бы я пользовал действительно 
			двойную буферизацию - но даже в этом случае непонятно преимущество оной перед 
			большим входным циклическим буфером. Единственное, что делается в этой 
			процедуре - так это "раскрутка цикличности" (независимо от перехода через 
			границу, получаю линейный буфер, и делаю это один раз для "всех видов"). Но 
			разве так уж велики расходы на эту "раскрутку"? Ведь можно: а) - проверять, 
			будет ли переход через границу в начале обработки, а потом идти по разным 
			веткам или б) ВСЕГДА брать индекс по маске. похоже, что я буду пробовать второй 
			вариант...</P>
		<P class="MsoNormal">При этом хочется заложить "вторичное хранение" каналов в 
			неинтерливном виде - для возможности иметь разные частоты дискретизации для 
			разных каналов....</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><FONT color="#cc0033">Итак TODO:</FONT></P>
		<P class="MsoNormal"><FONT color="#cc0033">- Правильная нумерация Ext-каналов при 
				изменении режимов</FONT></P>
		<P class="MsoNormal"><FONT color="#cc0033">- Попробовать обойтись без промежуточного 
				буфера, передавая адрес исходного</FONT></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040707 ср</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Обычное начало дня: диалоги с ремонтниками (с Димой), ННБ и 
			прочая. Ввел вчерашние "дневниковые" записи. 13:12 - после перекура буду в 
			очредной раз пробовать достать и подключить железо....</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">14:17 - первые же размышления показали, что "так просто" не 
			получится: "дочерние окна" должны получать не пару (начало буфера - 
			количество), а три параметра: буфер, положение начала "текущего поступления" и 
			размер оного. Передавая просто начало глобального буфера, я не буду знать, 
			откуда начинать отсчет; а при передаче "точки поступления" не смогу вычислить 
			момента разворота. Компромиссное решение: главный буфер делать "максимально 
			глобальным" (либо вообще глобальным, либо в CMainFrame - но с функцией 
			получения адреса), а передавать - позицию начала свежих данных в буфере.</P>
		<P class="MsoNormal">&nbsp;&nbsp; Это выглядит вполне осуществимым: буфер 
			(CMainFrame::m_pBuf) создается в CMainFrame::OnCreate(), имеет фиксированный 
			размер и не изменяется. Соответственно, все дочерние окна (и будущий класс 
			"сохраняемого файла") могут при создании получать его адрес - и хранить у себя 
			(в локальной переменной, чтобы избежать лишней операции в часто повторящихся 
			вызовах).</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">К десяти вечера задача вроде бы реализована - но электроды 
			по-прежнему "барахлят".</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Поздним вечером, уже дома - ввел в диалог edit-box 'Scale' - 
			но без какого-либо обслуживания.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">---------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040710 сб</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Предыдущие два дня - полностью "вне программы": вынос мебели 
			из к. 102, получение товаров по счетам (в Кее - записная книжка и фотобумага, 
			из Кабинета привезли сейф, кресло и вешалки), размышления над курикулумами для 
			CRDF. В пятницу - подписание счетов и прочие беседы с ЯА, раскидка смет по ОБН 
			и прочая... Лучшее из этого - вечер в Мариинском: Самсон и Далила.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><EM><U><FONT color="#009900">ЗАРЯДКА БАТАРЕИ Act-2. Перешел на вторую 
						батарею</FONT></U></EM>.</P>
		<P class="MsoNormal"><EM>начало зарядки - около 16:00</EM></P>
		<P class="MsoNormal"><EM>Перешла от full charge to the trickle charge at 18:12.</EM></P>
		<P class="MsoNormal"><EM>19:23 - зарядка закончена.</EM></P>
		<P class="MsoNormal"><EM></EM>&nbsp;</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Так что к программе вернулся только сегодня.
		</P>
		<P class="MsoNormal">- Обслуживание "Масштаба" (обработка Enter и UpDownCtrl). Учет 
			полученного масшатаба при рисовании. Проба: два экрана по 40 каналов проходят - 
			если только разрешение по времени не слишком велико (более 4 секунд - 
			нормально, меньше - тормозит довольно сильно). Ergo, разделение на потоки 
			понадобится...</P>
		<P class="MsoNormal">- изменен таймер: 250 мс в "стоп-режиме" (для опроса текущего 
			режима и проч) - и 50 мс (20 герц) при запущенном вводе - для более плавного 
			обновления...</P>
		<P class="MsoNormal">- отработка включения-выключения триггера.</P>
		<P class="MsoNormal">- 18:30 - введена обработка биполярного чекбокса (с 
			запрещением, если каналы не заданы). !!!Имя не запоминается и не передается!!!</P>
		<P class="MsoNormal">- 19:18 - пробую отображать биполярные каналы. Что-то 
			отображается... Но похоже, что опять - что-то не то...</P>
		<P class="MsoNormal">Кроме того, я<FONT color="#cc0000"></FONT><FONT color="#000099">во 
				всех дочерних окнах выделяю память под ВСЕ ВОЗМОЖНЫЕ КАНАЛЫ - а это не то, что 
				следовало бы делать. Правильнее - рассмотреть возможность передачи сообщений об 
				изменении отображаемых каналов и перераспределять память</FONT>.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><FONT color="#660000">Также не забыть, что я удумал (месяца 
				три-четыре назад) по поводу <STRONG><U>смещения</U></STRONG>: отображать 
				цветами во ВСЕХ окошках включения каналов (то есть - на картах). Этих цветов 
				может быть три - а может и больше? Например, заливать все зеленым, а по мере 
				увеличения смещения уменьшать количество зеленого и увеличивать - красного....</FONT></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Как ни обидно, но на сегодня надо завершать - проверить 
			наличие на всех возможных винтах нужных данных и прочего... и грести к дому...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">----------------------------------------------------</P>
		<P class="MsoNormal">040717 сб</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Ну вот, вся неделя прошла в разнообразных хлопотах и заботах, 
			если и были среди них "более рабочие", то касались они матлаба, SPSS и прочих 
			более близких к "науке" вещей. Об&nbsp; ActD вспоминал - но ничего не делал. 
			Может быть, оно и правильно: не стоит такие вещи делать второпях. Так что 
			сейчас начинать придется с перечитывания этих записей - и определения того, что 
			же нужно сделать...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Итак, самые очевидные TODO:</P>
		<P class="MsoNormal"><FONT color="#006600">- "правильное" позиционирование Ext-каналов 
				(они не должны мешаться с "обычными", но в то же время количество доступных 
				"Нормальных" должно уменьшаться)</FONT></P>
		<P class="MsoNormal"><FONT color="#009900">- обработка изменения включенных каналов в 
				BiPolar (выключать набор если хотя бы один из каналов отсутствует)</FONT></P>
		<P class="MsoNormal"><FONT color="#0000ff">- Смещение (отображение смещения цветом)</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">- фильтрация (HP, LP - IIR) для отображения</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">- фильтрация (LP, FIR) с децимацией 
				непосредственно при вводе (задавать "итоговую" частоту с тем, чтобы при 
				изменении режима одна не изменялась, менялся только коэффициент децимации; для 
				этого:</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp; -- возможные значения 
				"итоговой" частоты не должны превышать 2048 Гц</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp; -- меньшие значения - тоже по 
				степеням 2, то есть получаем возможные значения:</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
				2048</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
				1024</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
				512</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;256</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
				128</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - такой 
				набор вполне можно загнать и в комбобокс листбокс-типа)</FONT></P>
		<P class="MsoNormal"><FONT color="#cc0000"></FONT>&nbsp;</P>
		<P class="MsoNormal"><FONT color="#000000">- 1343: для обеспечения различения пин- и 
				тачпруф-каналов пришлось различать их и в структуре actMode</FONT></P>
		<P class="MsoNormal">- 1522: очень долго провозился с нормальной обработкой разного 
			рода отключения каналов в CDlgView. Там же сделана правильная (зависящая от 
			установленного режима) поправка начала TouchProof.</P>
		<P class="MsoNormal">- 1616 - обнуляю значение биполярного канала если хотя бы один 
			из двух отсутствует.</P>
		<P class="MsoNormal">- 1723: в книжке (Numerical recipes) ничего хорошего про IIR 
			фильтры не написано. Дескать, думай сам... Бросать все и заниматься дизайном 
			фильтров... Это уж как-то... FIR я умею (должно быть в dUEn) - но для HP такой 
			не подойдет. Да и для LP нужен изрядного порядка (по-моему, я пользовал около 
			50). Ergo, остается либо "домашняя" книжка того же содержания - либо 
			пользоваться библиотекой. Но в таком случае программа сразу станет не слишком 
			лицензионной - и не слишком транспортабельной.</P>
		<P class="MsoNormal">- 1938: Заработал первый вариант отображения смещения - 
			отображаю во всех окнах (хотя можно только в активном). Заодно "решил" и 
			проблему с электрдами - я их просто не туда втыкал!!!
		</P>
		<P class="MsoNormal">В общем, хоть что-то - но сделано...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">---------------------------------------------------------------------------</P>
		<P class="MsoNormal">040722, четверг</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Вечером разбирался с IIR-фильтрами. В ActiView используются 
			Бесселя - 2 порядка для LP и 1 порядка для HP. Попробовал посчитать аналоги в 
			Матлабе - но полностью неудачно... Немало времени ушло на то, чтобы понять:</P>
		<P class="MsoNormal">Генерируемый Матлабом фильтр Бесселя принадлежит к аналоговым 
			- то есть получаются какие-то совсем другие коэффициенты, и принадлежат они 
			S-плоскости (а не Z-плосокости, как у цифровых). Для преобразования аналоговых 
			фильров к цифровым требуется "билинейное преобразование", в котором третий 
			параметр - частота дискретизации деленая на 2*PI. Правда, результат все равно 
			оказывается не совсем точным.
		</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">-------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040723 пятница</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Итак, в LavView:</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">//порядок, частота среза, частота дискретизиции</P>
		<P class="MsoNormal">HP(1,0.16,2048) :&nbsp;a = [-0.9995092466 0]&nbsp;b = 
			[0.9997546233 -0.9997546233]</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">В Матлабе:</P>
		<P class="MsoNormal">[bBh aBh] = besself(1,0.16,'high') b = [1 0] a = [1 0.16]</P>
		<P class="MsoNormal">[bN aN] = bilinear(bBh,aBh,2048/pi/2): b =&nbsp; 
			[0.99975462329844 -0.99975462329844]&nbsp; a = [1 -0.99950924659688]</P>
		<P class="MsoNormal">Матлабовское a(1)&nbsp; потом нигде не используется - это 
			"делитель". Тогда получается, что у меня все даже вполне сходится - до всех 
			значащих цифр...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Далее матлаб использует полученные коэффициенты следующим 
			образом:</P>
		<P class="MsoNormal">a(1)*y(n) = b(1)*x(n) + b(2)*x(n-1) + ... + b(nb+1)*x(n-nb)
		</P>
		<P class="MsoNormal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			- a(2)*y(n-1) - ... - a(na+1)*y(n-na)</P>
		<P class="MsoNormal">Теперь надо придумать, как мне грамотно (быстро и без больших 
			затрат памяти) организовать это на Си...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Из сделанного за сегодня:</P>
		<P class="MsoNormal">- введен переключатель скроллирования</P>
		<P class="MsoNormal">- введена кнопка обнуления (сейчас берется одна точка - а 
			нужно насчитвывать среднее пока держу кнопку; точно так же и при первом запуске 
			ноль должен расчитываться по среднему первого полученного фрейма)</P>
		<P class="MsoNormal">Нули считаются. Пора вводить фильтры (<FONT color="#ff0099">решено 
				для начала остановиться на фиксированных частотах</FONT>, то есть расчитать 
			необходимые коэффициенты в матлабе, чтобы не привлекать посторонние библиотеки)</P>
		<P class="MsoNormal">------------------------------------------------------------------</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><STRONG>040726 пн</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">До программы добрался все равно лишь под вечер (утром купил 
			обратный билет из Чупы на 7 сентября - купейный, да еще в "коммерческой кассе", 
			посему обошелся в 1044 рубля; рядом же купил последнюю индийскую ручку - и 
			ампул с чернилами к ней)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">- "Виды" порождаются из "Диалогов" (по "New" создается диалог, 
			а уже из него - вид)</P>
		<P class="MsoNormal">- Первый элементарный вариант многопоточности (каждый осцилл - 
			в своем потоке!!!)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">-------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040727 вт</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Разумеется, пока это - "псевдомногопоточность", и проблем 
			больше, чем выгод.
		</P>
		<P class="MsoNormal">1) Не удалялся созданный поток - нужно явно прописать удаление 
			в деструкторе (рассмотреть вариант: хранить не указатель на поток, а саму 
			структуру потока, тогда и удаляться будет "автоматом"). Деструктор не 
			срабатывал, т.к. не происходил выход из цикла Run(), а выход не происходил, 
			т.к. я "висел" на GetMessage(). Этого можно избежать, если сделать 
			PeekMessage() - но тогда и кручение в цикле получается постоянным....</P>
		<P class="MsoNormal">2) Перестало срабатывать дефолтовое позиционирование окна при 
			вынесении вовне...</P>
		<P class="MsoNormal">3) Если что-либо сделать с окном, когда оно является дочерним 
			и к тому же находится в "Рабочем" режиме, блокируются сообщения родительского 
			пользовательского интерфейса....</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------</P>
		<P class="MsoNormal">040728 ср</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Продолжал попытки разобраться с многопоточностью - перебирал 
			варианты, расставлял брыкпойнты... Безуспешно :(</P>
		<P class="MsoNormal">Вечером - последний в сезоне поход в Мариинский - 
			"Бал-Маскарад" Верди в постановке Кончаловского.</P>
		<P class="MsoNormal">(с мамой)</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040730 пт.</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Далее было два дня перерыва: в четрвег объявился ЯА - и 
			получалось решение финансовых и прочих оргпроблем с плавным переходом в 
			вечерний заключительный разговор с Сашей Нурским (постановка задачи на 
			симуляцию ERP).</P>
		<P class="MsoNormal">В пятницу хоронили дядю Толю.
		</P>
		<P class="MsoNormal">Вечером (в пятницу же) добрался до программы - но при наличии 
			сильной головной боли. Внес изменения: перенес Thread.h (от Biran Viksoe) в 
			программу (для возможности модифицирования). Всё одно - не то...</P>
		<P class="MsoNormal">Положительный результат дала "правильная" расстановка закрытия 
			окон: если всегда начинать с закрытия "Вида", то оно происходит, и дальнейшее 
			удаление потока из диалога. Но остановки на выходе поточной функции при этом не 
			вижу!!! То есть непонятно, каким же образом выхожу...</P>
		<P class="MsoNormal">Кроме того, <FONT color="#cc0000">обнаржил различия в "домашней" и 
				"рабочей" версиях StatMap - нужно разобраться пока не поздно...</FONT></P>
		<P class="MsoNormal">---------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040731 суббота</STRONG></P>
		<P class="MsoNormal"><STRONG></STRONG>&nbsp;</P>
		<P class="MsoNormal">Итогом вчерашних размышлений стало то, что мне нужно заводить 
			некий единый объект, внутри которого будут уже и диалог, и вид, и поток... И, 
			соответственно, в главном окне держать список таких объектов.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Но пока до этого не дошел, не додумал.
		</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">В ходе сегодняшних разборок:</P>
		<P class="MsoNormal">- одна из причин "вылетов" - в удалении "вида" вызовом из 
			главного окна (деструктор вызывался в контексте основного потока). Убрал, 
			удаляет диалог при своем удалении.</P>
		<P class="MsoNormal">- нужно запоминать идентификатор потока, тогда можно будет ему 
			послать при закрытии сообщение WM_QUIT</P>
		<P class="MsoNormal">- ошибки с активацией окна-диалога: сейчас диалог активирует 
			вид без обращения к главному окну и его списку. "Обратная" процедура тоже 
			переписана</P>
		<P class="MsoNormal">- Ошибки при смене длительности/частоты: вызваны "асинхронным" 
			изменением (диалог напрямую вызывает ф-ию изменения длительности, в ходе 
			которой удаляются нужные массивы и переопределяются новые, а обращение к Plot 
			происходит в другом потоке). Нужно избавиться от непосредственной модификации 
			диалогом (работающим в основном потоке) переменных и массивов дочернего потока.</P>
		<P class="MsoNormal"><STRONG></STRONG>&nbsp;</P>
		<P class="MsoNormal"><STRONG>1957 - </STRONG>после вывода установки длительности в 
			сообщение (через пост) глюки с вылетом при смене прекратились. Затраты 
			процессорного времени при выводе в 4 окна по 40 каналов составляют 22-27%. 
			Хорошо :)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">======================================================================</P>
		<P class="MsoNormal"><STRONG>040929 среда</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><EM>позади - очень длинный перерыв: подготовка статьи и доклада (в 
				основном - на Острове, остатки доклада делал в Питере), беломорский отпуск, XIX 
				съезд физиологов в Екатеринбурге... Второй день потихоньку-понемножку 
				вспоминаю, что же я делал и на чем остановился.</EM></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Получается, что остановился я на фильтрах - принял решение о 
			"фиксированных частотах" и их коэффициентах, но к реализации оного решения не 
			подобрался ни с какой стороны (из трех: интерфейс, матлабовские расчеты, сишные 
			алгоритмы). Попробуем восстановиться...</P>
		<P class="MsoNormal">LF - 10, 20, 30, 40, 50, 100, 200, 500, 1000, 10000 (в 
			усилителе - 30, 100, 1к, 10к)</P>
		<P class="MsoNormal">HF - 0.1, 1, 5, 10, 100 (в усилителе - 0.1, 1, 10, 100)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><FONT color="#9966cc">...В принципе даже взялся за это дело 
				(едит-боксы на комбобоксы заменил) - но заметил, что у меня ерунда творится и с 
				масштабом (тот, который Scale): появляется куча никому не нужных значащих цифр. 
				Попытался исправить - и завис на этом деле....</FONT></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">-------------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>040930 четверг</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><EM>Основные (по смылсу - попутные) занятия дня - договор по 
				поводу B&amp;K и мытье окон в лаборатории.</EM></P>
		<P class="MsoNormal"><EM></EM>&nbsp;</P>
		<P class="MsoNormal">1421 - в общем вчерашнюю "проблему" с масштабом решил, за 
			исключением перехода от микро- к милливольтам: число получается с единицами на 
			конце, а iDelta при этом уже кратна 10...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">2108 - добавил еще один комбобокс (для децимации), но с точки 
			зрения сути ни на йоту не продвинулся...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">----------------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041001 пятница</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><EM>придя на работу в 10:15, на продолжении двух часов занимался 
				"почти ничем" - распечатал договора для B&amp;K, написал письмо Перфильеву, 
				раздумывал о будущем оборудовании</EM>...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Возвращаясь к филтрам: где хранить коэффициенты? Попробую 
			сначала в CDlgView (их будет возвращать специальный метод)</P>
		<P class="MsoNormal">15:49 - таблицы фильтров хранятся внутри диалоговых функций, 
			которые возвращают конкретные фильтры по запросу вида. При изменении установки 
			в диалоге он постит сообщение виду, и вид меняет свой фильтр.</P>
		<P class="MsoNormal">1826 - в CActDView создание буферов вынесено в отдельную 
			функцию (во избежаение многократного создания по-разному)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><EM><U>20:53 Ура! Фильтры работают!!!</U></EM></P>
		<P class="MsoNormal">По началу "засада" оказалась произрастающей из матлаба: 
			функция besselg , даже когда ей говорили 'low', все&nbsp;равно 
			делала&nbsp;'high'!!!</P>
		<P class="MsoNormal">Для получения "настоящего" LP ей нужно не говорить ничего...</P>
		<P class="MsoNormal">После устранения этой проблемы (просто пришлось заново 
			переписать все коэффициенты) заработали оба фильтра.
		</P>
		<P class="MsoNormal">И при двух полноэкранных 40-канальных окнах выше 22% 
			процессорного времени не поднимаюсь... Хорошо...</P>
		<P class="MsoNormal">Соответственно, <FONT color="#ff0066">TODO:</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">- коэффициенты для других частот (сейчас - 
				только для 2048)</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">- добавить HP c 0.5 (0.3?) Hz</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">- децимация (это - уже FIR)</FONT></P>
		<P class="MsoNormal"><FONT color="#000099">- обнуление "хвостов" при любой перестилке 
				(смена длительности и т.д.)</FONT></P>
		<P class="MsoNormal"><FONT color="#000099"></FONT>&nbsp;</P>
		<P class="MsoNormal">---------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041008 снова пятница</STRONG></P>
		<P class="MsoNormal"><EM>... и то до программы добрался лишь к вечеру и без большого 
				энтузиазма</EM></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">- добавлен ФВЧ на 0.5Гц</P>
		<P class="MsoNormal">- переключение таймера из харддиалога (потом можно будет 
			убрать куда-нибудь в setup)</P>
		<P class="MsoNormal">- вывод секундных маркеров</P>
		<P class="MsoNormal">&nbsp; при этом оказалось, что длина окна у меня не кратна 
			секунде... Нужно разобраться....</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">вечером, в раздумьях о надоедливых мельканиях, попробовал 
			повнимательнее заглянуть в DirectX. Да, похоже что там это возможно... Но 
			столько возни будет....</P>
		<P class="MsoNormal">---------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041009 Суббота</STRONG></P>
		<P class="MsoNormal"><EM>...утренний поход в Ленту - на 1100 рублей (половина - в 
				лабораторию, половина - себе). Институтская сеть на работает. Из "общих дел" - 
				расшарил финансовый каталог (оставил сам каталог у Лиды, себе сделал симлинк; 
				разрешения на полный контроль даны мне и Лиде, просмотр - НИ)</EM></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><STRONG>15:55</STRONG> - проблема с "некратностью" решена 
			следующей заменой:</P>
		<P class="MsoNormal">было</P>
		<P class="MsoNormal"><FONT color="#006600">&nbsp;&nbsp;&nbsp;&nbsp; //int nWNew = 
				nNewCnt * W /m_nLength;&nbsp; </FONT>
		</P>
		<P class="MsoNormal"><FONT color="#006600">&nbsp;&nbsp;&nbsp;&nbsp; (int nNewCnt = 
				m_nCnt - m_nOldCnt; if (nNewCnt &lt;= 0) nNewCnt += m_nLength;)</FONT></P>
		<P class="MsoNormal">стало</P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nWNew = 
				m_nCnt * W /m_nLength - m_nOldCnt * W /m_nLength; </FONT>
		</P>
		<P class="MsoNormal"><FONT color="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nWNew 
				&lt;= 0) nWNew += W; </FONT>
		</P>
		<P class="MsoNormal">&nbsp;&nbsp;&nbsp;&nbsp; (nNewCnt оставлен прежним)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041014 Четверг</STRONG> - точнее, в первом часу 
			пятницы, уже дома</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">После воскесных упраженений с Direct3D, увенчавшихся как 
			успехом (я смог что-то нарисовать), так и поражением (для моей программы это не 
			подойдёт) и обычных финансовых дней смог таки немножко возвренуться к 
			программе.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Уже хочется поиграть с цветами и проч. - а для того нужно 
			сохранять установки. С трудом, но вспомнил, каким образом получать доступ к 
			специальному каталогу, сделал имя файла. Но дальше лучше поспать...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Todo - CMainFrame должна обеспечивать функции доступа к сетапу 
			(как чтение, так и запись, для разных типов параметров)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">-------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041015 Пятнцица</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Начата работа с сохранением переменных - заведено имя файла.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">-------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041016 Суббота</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Доступ к реестру - сохранение некоторых параметров</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041017 Воскресенье</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Массовые нововведения - сохранение основных параметров в 
			реестре, сохранение переменных в конфигурационном файле; сохранение вариантов 
			"палитры" и самих цветов.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">---------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041018 Понедельник</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Подправлена перерисовка списка цветов каналов</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">---------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041019 Вторник</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Дальнейшие изменения в работе со списком цветов, дальнейшие 
			усовершенствования общей</P>
		<P class="MsoNormal">работы с установками.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">----------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041020 Среда</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">класс _Settings , диалог - как наследник от него</P>
		<P class="MsoNormal">Новые функции для доступа к цветам</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">----------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041021 четверг</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">изменения родительских взаимоотношений, отображение с учетом 
			выбранных цветов.
		</P>
		<P class="MsoNormal">"Косметические" правки в нескольких классах.</P>
		<P class="MsoNormal">Переход на мультимедийный таймер</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041022 пятница</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Массовые правки касающиеся отображения.</P>
		<P class="MsoNormal">Специальная кнопка в тулбаре дочернего окна для выноса оного 
			наружу и вноса обратно.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041023 Суббота</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Запрещение изменений в HardDlg в процессе ввода.
		</P>
		<P class="MsoNormal">IIR-фильтрация - избавляюсь от "резких взбрыков" при изменении 
			параметров ввода (изменение
		</P>
		<P class="MsoNormal">фильтра, добавление каналов и проч.)</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041025 Понедельник</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Небольшая доработка отображения - устранены "взбрыки" и эффект 
			"зашкала".</P>
		<P class="MsoNormal">Примерные прикидки децимирующих фильтров: если "резать" 
			начиная от 0.75 будущего</P>
		<P class="MsoNormal">(после децимации) Найквиста, то для двукратной децимации мне 
			вполне хватит 64 коэф-</P>
		<P class="MsoNormal">фициентов (с обеспечением 100 дБ подавления на половине 
			частоты среза). При дальнейшем
		</P>
		<P class="MsoNormal">увеличении коэффициента децимации для сохранения столь же 
			хорошего подавления нужно</P>
		<P class="MsoNormal">пропорционально увеличивать длину FIR фильтра - но так как при 
			этом будет уменьшатся и
		</P>
		<P class="MsoNormal">количество точек, для которых нужен данный расчет, то вроде бы 
			в итоге объем вычислений</P>
		<P class="MsoNormal">останется прежним, эквивалентным 32 точкам для "единичной" 
			децимации. Если я прав,</P>
		<P class="MsoNormal">то этот вариант проходит: нагрузка на процессор не выходит за 
			30% даже для максимально</P>
		<P class="MsoNormal">возможного числа каналов. А если учесть, что децимация при 
			этом будет реальной (то есть</P>
		<P class="MsoNormal">уменьшится и количество точек для сохранения) - то должно быть 
			совсем хоршо.</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041027 Среда</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Первые элементы отработки "децимации" в CHardDlg: я буду 
			хранить только "индекс" комбобокса
		</P>
		<P class="MsoNormal">(отображающий лишь итоговую частоту), а коэффициент децимации 
			и фильтры - расчитывать.</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041101 Понедельник</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Вписана "краткая история" за период с 041015 и до сегодняшнего 
			дня.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">CHardDlg::GetFrq() возвращает <EM><U>конечную</U></EM> частоту 
			(после децимации); кроме того CMainFrame использует вызов actMode.GetFrq() для 
			получения <EM><U>реальной</U></EM> (<EM><STRONG>исходной</STRONG></EM>) частоты 
			дискретизации - на ее основе</P>
		<P class="MsoNormal">будут формироваться "входные" буфера.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">------------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041112 Пятница</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">В очередной раз произошел длительный перерыв (плохо!), 
			заполненный в основе своей возней с Лидой (предзащита 11 ноября) и 
			переживаниями относительно неработающей бухгалтерии и зависших финансов.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Вечером заглянул в программу - вспоминл, что мне нужно наконец 
			написать фильтр. А также что для оптимальной фильтрации хорошо подходит 
			4-членный Блэкман-Хэррис, но на этом воспоминании дело и закончилось.</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">---------------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041113 Суббота</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Разгон для выхода из застоя никак не получается: с трудом 
			соображаю, каким же образом мне фильтр и окно творить.</P>
		<P class="MsoNormal">(точное блэкмана-хэрриса)</P>
		<P class="MsoNormal">w = 0.35875 - 0.48829*cos(x) + 0.14128*cos(2.0*x) - 
			0.01168*cos(3.0*x);</P>
		<P class="MsoNormal">где
		</P>
		<P class="MsoNormal">x = (0:N-1)' * 2.0*pi/(N-1);</P>
		<P class="MsoNormal">т.е.</P>
		<P class="MsoNormal">for (i = 0; i &lt; N; i++)</P>
		<P class="MsoNormal">{</P>
		<P class="MsoNormal">&nbsp; x = i * 2.0*pi/N;</P>
		<P class="MsoNormal">}</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">--------------------------------------------------------------------------------------------------------------------</P>
		<P class="MsoNormal"><STRONG>041125 четверг 2012</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">И вновь почти две недели - ни строчки, ни мысли... То есть 
			снова: нужно уже не выбираться - нужно уже начинать заново...</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal"><U><STRONG><EM>-------------------------------------------------------------------------------------------------------------------------</EM></STRONG></U></P>
		<FONT style="BACKGROUND-COLOR: #ccffcc">
			<P class="MsoNormal"><U><STRONG><EM>-------------------------------------------------------------------------------------------------------------------------</EM></STRONG></U></P>
		</FONT>
		<P class="MsoNormal"><U><STRONG><EM>-------------------------------------------------------------------------------------------------------------------------</EM></STRONG></U></P>
		<P class="MsoNormal"><U><STRONG><EM>-------------------------------------------------------------------------------------------------------------------------</EM></STRONG></U></P>
		<P class="MsoNormal"><STRONG>050113 четверг 1438</STRONG></P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Итак, с последней собственно "попытки" (предыдущая строчка - 
			не в счет) прошло ровно два месяца... Так что теперь явно не избежать месяца на 
			восстановление в памяти того, что я пытался делать - и зачем....</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">Вспоминаю: во-первых, в таком случае лучше пользоваться окном 
			Nuttall:</P>
		<P class="MsoNormal">w = 0.3635819- 0.4891775*cos(x) + 0.1365995*cos(2.0*x) - 
			0.0106411*cos(3.0*x);</P>
		<P class="MsoNormal">или</P>
		<P class="MsoNormal">w =&nbsp;a0 - a1*cos(x) + a2*cos(2.0*x) - a3*cos(3.0*x);</P>
		<P class="MsoNormal">где</P>
		<P class="MsoNormal">a0=0.3635819</P>
		<P class="MsoNormal">a1=0.4891775</P>
		<P class="MsoNormal">a2=0.1365995</P>
		<P class="MsoNormal">a3=0.0106411</P>
		<P class="MsoNormal">&nbsp;</P>
		<P class="MsoNormal">1500 - 1700</P>
		<P class="MsoNormal">Придумываю "общий подход" к окну: это будет отдельный класс, 
			все параметры окна задаются в конструкторе (там же оно собственно и создается), 
			доступ - через оператор []. Тип окна - строковым параметром (для начала сделаю 
			Nattall, Blackman-Harris, Blackman и Hamming). По умолчанию - Hamming(128).</P>
		<P class="MsoNormal">&nbsp;</P>
		<P><FONT style="BACKGROUND-COLOR: #ccffcc">--------------------------------------------------------------------------------------------------------</FONT></P>
		<P><FONT style="BACKGROUND-COLOR: #ccffcc"><STRONG>050117 пн</STRONG></FONT></P>
		<P><FONT style="BACKGROUND-COLOR: #ccffcc">Прошлая попытка так попыткой и осталась. То 
				есть новый объект создан был - но не только не был проверен, даже подходы к 
				этой самой проверке выработаны не были. А потом опять занимался... Сам не 
				пойму, чем же я занимался.</FONT></P>
		<P>Сегодня решил проверить (достал и включит коробку) и обнаружил, что:</P>
		<P>- любая децемация тут же рушит все режимы отображения (касается триггерных 
			каналов, длительности окна - и т.д.)</P>
		<P>- переключение децмиации не вызвает тех функций, которые должна была бы.</P>
		<P>20:50 - в функцию обработки изменения децимации введен вызов SetMode(-1); при 
			этом в последнюю функцию введена модификация, позволяющая при -1 на входе не 
			изменять режим; ф-ия создания окна данных дополнена трассировкой 
			ATLTRACE("%d\t%.17f\n",i,dbTmp);, проведено сравнение с матлабовским окном 
			наттолла (пока - только для длины 256), получил результаты идентичные вплоть до 
			15 цифр после запятой (это может быть вызвано уже и погрешностями форматного 
			вывода).</P>
		<P>После пробы вывод закомментировал (буду пробовать его же - но уже для фильтра).</P>
		<P>----------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050128 пт</STRONG></P>
		<P>Еще одиннадцать дней перерыва... Заботы с креслом (привезли наконец), отчет по 
			Школе... Наверное, что-то еще - но я уже ничего не помню.</P>
		<P>Все ж таки собрался с духом: проверил фильтры. Во всем диапазоне децимаций (от 2 
			до 128, последняя дает возможность спускаться с максимальной для Active2 
			частоты 16384 Гц до конечной дискретизации в 128 Гц) совпадение с Матлабовскими 
			данными до 1e-16, подавление на будущем Найквисте порядка 110 дБ (я режу на 0,7 
			- но можно и 0.75, и 0.8).</P>
		<P><STRONG><FONT color="#ff0066">!!!CMainFrame::OnTimer - проверять на сбой синхронизации 
					нужно каждый отсчет!!!</FONT></STRONG></P>
		<P>18:38 - Данные я получаю как полный Long (нулевые младшие биты). Удаление 
			таковых (&gt;&gt;8 == /256) стояло в "виде". Но сейчас оно мне понадобится в 
			главной функции (CMainFrame::OnTimer) - для осуществления децимации. Так что из 
			CActDView деление изъято.</P>
		<P><FONT color="#000099"><STRONG>!!! Проверить, что же у меня&nbsp;после этого стало со 
					смещением !!!</STRONG>&nbsp;- проверено, смещаю на 14 бит для получения 
				полумилливольта. Кажется, до того была ошибка (насчитывал в два раза больше)</FONT></P>
		<P><STRONG><FONT color="#ff0066">!!! Совсем плохо с отображалкой при 30 секундах <FONT color="#000099">
						- и явно "не то" при введении децимирующих коэффициенов.</FONT> !!!</FONT></STRONG></P>
		<P><FONT color="#000099">----------------------------------------------------------------------------------------------------------</FONT></P>
		<P><FONT color="#000000"><STRONG>050201 вт</STRONG></FONT></P>
		<P>Задумался на тему: а с какими буферами я работаю? Похоже, что сейчас я пытаюсь 
			(по крайней мере) обрабатывыать данные "на месте" - а для децимации это не 
			вполне подходит. В принципе, можно (есть класть результат в "нулевую" точку, 
			которая на следующем шаге уже уйдет из зоны рассмотрения) - но при этом я очень 
			быстро "накрою" эту точку (в колцевом-то буфере) свежими данными. То есть - 
			нужны отдельные буфера!!!</P>
		<P>Более того, непонятно и то, какое именно число точек я передаю на отрисовку. 
			Деления на коэффициент децимации не нашел... Плохо искал?</P>
		<P>Заглянул на сайт BioSemi: он просто отображает каждую энную (восьмую - 
			шестнадцатую) точки... Говорит, что иначе не нравится заказчикам... Не бред ли?</P>
		<P>----------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050202 ср</STRONG></P>
		<P>Нет, собственно "перекрытия" кольцевого буфера можно и избежать - если класть 
			"новую" точку на её же место. Но тогда и все "отображалки-сохранялки" должны 
			будут знать, что брать нужно только эти точки.</P>
		<P>На первый взгляд, такой подход экономит и время, и память. Но появляется слишком 
			много сложностей. Кроме того, "вторичный буфер" даст возможность держать:</P>
		<P>- не все каналы, а только "включенные" (в основном окне)</P>
		<P>- децимированную частоту</P>
		<P>- иметь (в будущем) разную децимацию (и частоту) для разных каналов</P>
		<P>- за счет меньшего числа каналов и отсчетов держать более длинный (по времени) 
			буфер для отображения и записи.</P>
		<P>1630</P>
		<P>Для этого при сохранении какое-то время неиспользовавшегося m_pChanBuf изменено 
			его содержание, добавлены новые переменные - количество включенных каналов 
			(m_nOnChans) и длина канального буфера (m_dwChanBufLen). <FONT color="#000099">Вопрос 
				в том, каким образом (и из какого места) получить это самое число включенных 
				каналов.</FONT></P>
		<P><FONT color="#000000">Потихоньку постигаю: главная карта содержится в CLeftDlg, 
				доступны в CMainFrame по ссылке m_pMainMap. Ну а там - простой подсчет...</FONT></P>
		<P>1652 Однако, сейчас я даю возможность изменить общее количество каналов при 
			включенном вводе - а мне нужно это дело запретить!!!</P>
		<P>1654 Сделано. <FONT color="#ff0066">Но сейчас я вновь разрешаю изменения сразу после 
				остановки - а в будущем разрешать менять такие главные параметры можно будет 
				только в том случае, если файл не был начат!!!!</FONT></P>
		<P><FONT color="#ff0066">-------------------------------------------------------------------------------------------------------</FONT></P>
		<P><FONT color="#000000"><STRONG>050207 пн</STRONG></FONT></P>
		<P>При переходе к "поканальной буферизации" появляется возможность заложить разные 
			коэффициенты децимации (и, соответственно, частоты дискретизации) для разных 
			каналов. В настоящий момент это имеет смысл только для "статусного" канала - но 
			закладывать принципальную возможность нужно уже сейчас. Лучше всего посмотреть, 
			каким образом это было организовано в dUEn</P>
		<P>Посмотрел... Нет, от этого отталкиваться не стоит - хотя бы потому, что в "том" 
			варианте частоты дискретизации (и пр.) описывались лишь для группы каналов - а 
			в самом канале указывалась лишь принадлежность к группе. Наверное, нужно взять 
			что-то подобное BDF.&nbsp; Но!!! Там, где это возможно, я буду использовать не 
			ASCII, а числовые значения (пределы, длина); к тому же ВСЕГДА буду указывать 
			"длину на секунду" (частоту дискретизации) - и уж потом ее "переваривать". К 
			этому будет добавлена и собственно длина....</P>
		<P><FONT color="#000000">Еще правильнее: в "рабочем списке" указываются только 
				"внутренние параметры" - номер канала в глобальном списке, длина (в отсчетах), 
				смещение в кольцевом буфере. Частота/дискретизация??? Все прочие - задаются в 
				глобальном списке (расчет на то, что настоящие параметры каналов будут меняться 
				реже, нежели их включенность/выключенность). Но тогда мне понадобятся два 
				разных класса: один - для "глобального" списка каналов, другой - для "рабочего 
				списка". Так их и назову: $ChanG и $ChanW.</FONT></P>
		<P>2148</P>
		<P>Заведены новые классы для "Глобальных" и "рабочих" каналов (почему-то в списке 
			не показываются - неужели дело в долларе?)</P>
		<P><EM><U>Зарегистрировался на фотосайте - имею уже пяток положительных комментариев за 
					первую фотку. Мелочь, а приятно :)</U></EM></P>
		<P>Практически вся работа по положению/выниманию данных переложена на класс. 
			Компиляция проходит, пробные запуски приводят в вылету из-за неверной длины: 
			почему-то
		</P>
		<P>DWORD dwLen = m_HardDlg.GetFrq() * 30;</P>
		<P>дает мне страшенную цифру - и отбор памяти не проходит.</P>
		<P><FONT color="#000099">Проверить работу этого GetFrq - и установить обработку ошибки 
				при заборе памяти!!!!</FONT></P>
		<P>--------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050208 вт</STRONG></P>
		<P>1218 - установлена обработка ошибки выделения памяти</P>
		<P>1222 - устранена ошибка в CHardDlg - как всегда, неинициалирозованная переменная 
			m_nFinalFrq</P>
		<P>Теперь нужно подумать, как передавать информацию на отрисовку....</P>
		<P>1500 - Покамест наблюдается небольшая засада: в "виде" я оперирую со списками 
			каналов (референтных и отображаемых), на вход мне тоже поступает список - но 
			уже каналов вводимых. Получается, что мне нужно сравнивать два списка на 
			совпадение содержимого - а это мягко говоря времяеемко. То есть делать это при 
			каждом поступлении данных не хочется. Тогда хотелось бы другого: найти место, 
			где эти списки формируются - и попытаться в этом месте сформировать список по 
			отношению к списку вводимых каналов.</P>
		<P>1511 - Нет, не получится. Списки формируются диалогом при каждом изменении 
			соотв. карты (или же - списка биполяров). То бишь для того, чтобы пересчитать 
			на списко вводимых каналов, диалогу нужно таковой передавать - а это уже 
			слишком... Но не сделать ли тогда проще: вообще избавиться в CDialogView от 
			списков - и передавать просто адреса соответствующих карт. Тогда и сравнивать 
			будет проще... Посмотрим, где и как используются эти вызовы и списки.</P>
		<P>Угу. Понятно.&nbsp;Функции - только в "рисовательной" функции вида - той, 
			которую я сейчас и меняю. Ничего страшного. Сами списки - тоже лишь в функции 
			CDlgView::CorrectMap(), в деструктуре - и в функциях получения доступа и 
			размера. Так что можно исправлять - только аккуратно. Остается еще вопрос с 
			биполярами - там-то вроде без списков и никак....</P>
		<P>1700 - Разумеется, все не так просто, как хотелось бы. В старом варианте я шел 
			сначала по отсчетам, а уже потом по каналам - и легко мог использовать для 
			референта единственное число. В новом я должен резервировать массив, причем он 
			каждый раз может иметь разную длину. То есть нужно будет эту длину определять, 
			массив при необходимости наращивать, а при каждом заходе массив обнулять.... 
			При этом нужно учесть, что "реферирование" каналов с разной децимацией в 
			принципе невозможно!!!</P>
		<P>1705 буфер, кстати, у меня уже есть. Только он никак не использовался... Вот 
			теперь и задействуем :) Но вот длину нужно добавить</P>
		<P>------------------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050218 пт</STRONG></P>
		<P>На том месте, где прерывается предыдущая запись, порушил систему. А когда 
			готовил к переустановке, затер VSS-овскую базу этого проекта. Хорошо, дома 
			некое подобие нашлось... В общем, весь конец прошлой недели на это и ушел. А 
			дальше в основе своей - статья SLB, семинар ВиТек'а, поездка в Полюс... Это - 
			из рабочего. Из "внерабочего" - возня с фотографиями. Подготовил 
			вороьбя-командира, сегодня заслал.Но комментариев мало, увы....</P>
		<P>Итак, попробуем посвпоминать, на чем мы остановились....</P>
		<P>2115 - У меня даже еще не установлены драйвера от BioSemi, так что программа 
			просто вылетает... Поставлены доп. проверки, позволяющие по крайней мере ничего 
			не делать :))) НО!!! <FONT color="#ff0066">В таком режиме у меня наблюдаются утечки 
				памяти...</FONT></P>
		<P><FONT color="#ff0066">------------------------------</FONT><FONT color="#000000">----------------------------------------------------------------------</FONT></P>
		<P><STRONG>050219 сб</STRONG></P>
		<P>Так как вчера даже близко к работоспособности не подобрался, решился таки 
			приехать на работу в субботу (прошлые три субботы пропустил - смотрел на Роми 
			Шнайдер в трилогии про императрицу Сисси). Что ж, вроде бы приехал не зря:</P>
		<P>- Вызов из CMainFrame "видовых рисовалок" производился не с тем lParam (либо 
			недописанный, либо утерянный при вылете системы кусок)</P>
		<P>- Никак не мог ввалиться в отладку в ChanW: в итоге функции вынес в cpp-файл, а 
			сам класс переименовал в _ChanW ($ChanW чем-то не устраивал студию: не 
			показывала имени.)</P>
		<P>14:23: наблюдаются следующие вылеты: после остановки ввода получаю нарушение 
			доступа по записи в функции OnTimer. Очень похоже, что в этот момент я уже 
			разрушил канальные буфера - но продолжала работу функция OnTimer....</P>
		<P>16:29 Выход из положения пытался найти в перенесении цилка подсчета 
			каналов/заполнения массива включенных каналов из OnRunGo() в OnMapChaged() - но 
			долго не получалось. Оказалось, что эта ф-ия не вызывается, а вызвается 
			аналогичная ветка из PreTranslateMessage(). Убирание ветвления не помогло - 
			пришлось напрямую вызвать ф-ию. В таком виде работает.</P>
		<P>НО!!! Я оказываюсь в классической ситуации, требующей синхронизации доступа: 
			массив каналов, который я удаляю-модифицирую в OnMapChaged() используется в 
			асинхронной ф-ии OnTimer() - и в таков варианте возможны любые нюансы.... Нужно 
			что-нибудь типа как минимум критической секции....</P>
		<P>17:45 Critical Section заведена и, как показала отладочная печать, не напрасно: 
			попытки конкурентного доступа встречаются нередко... Кажется минусом то, что 
			при выключении приборда не запрещается основная карта (и все дочерние). Хотя 
			так было и в предыдущих версиях... Но наверное лучше все-таки их сбросить - 
			совсем....</P>
		<P>17:56 - предыдущее сделано путем исправлений в CHardDlg::SetMode&nbsp;
		</P>
		<P>19:19 Были большие проблемы с полной неработоспособностью: явно лез не в ту 
			память... Ошибки обнаружилось две: во-первых, размер канального буфера 
			определялся из общего кол-ва каналов (и получался нулевым) - <FONT color="#ff0066">а 
				нужно???</FONT> из включенных (это в OnMapChanged). Во-вторых, уже в 
			OnRunGo() это значение вновь обнулялось - и заново не пересчитывалось... То 
			есть выделял память нулевой длины - вот не туда и лез... Сейчас добился по 
			крайней мере "тишины" (вид еще ничего не делает - но хоть вылетов нет....).</P>
		<P>-----------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050221 пн</STRONG></P>
		<P>1307 Как выяснилось, субботняя "невылетаемость" обеспечивалась без записи в 
			"третий" буфер. Но и при таковой (сейчас разрешил) работает...</P>
		<P>1545 По ходу дела нашел еще несколько закомментированных строк, предотвращающих 
			запись в выходной буфер. Но и это не помогло: если и рисовались, то сплошные 
			нули... В итоге оказалось, что в CActDView::OnPlot для адресации выходного 
			буфера использовалась переменная nChanIdx, а модификация оной не 
			производилась.... После устранения этого "недостатка" рисование заработало. На 
			настоящий момент два главных недостатка:</P>
		<P>-<FONT color="#6600ff"> не отрисовывается статусный канал<BR>
			</FONT><FONT color="#000099">- Довльно часто возникают "затыки" при изменинии 
				главной карты (очень похоже на дедлок).</FONT></P>
		<P>20:37 - <EM>около семи выскочил поснимать "след ледокола". Чуточку опоздал 
				(обманулся светлым небом - но то на западе, на востоке же уже царила глубокая 
				ночь). Наверное, получилось бы все равно неплохо (ясно, ветер разнес дымку - и 
				луна), хотя и было очень холодно, пальцы заледенели... Но получилось очень 
				смазано, и только при "разборе" понял почему: не выключил стабилизатор, вот он 
				и дурил при съемке со штатива :((( А удастся ли повторить, неясно: холодно, и 
				след может затянуть... Обидно будет :(((</EM></P>
		<P>Говоря о "сути": во-первых, статусный канал тоже нужно сдвигать вправо на 8 бит. 
			А во-вторых, я не определил для него память (в соотв. цикле забыл поставить +1) 
			- вот он и возвращал все время нули... После исправления отрисовка тригеров 
			заработала.</P>
		<P>21:15 При помощи многочисленных ATLTRACE удалось установить: в то время, как 
			критическая секция захвачена процедурой обработки таймера, я пытаюсь доступить 
			к ней из процедуры обработки OnMapChaneged - и на этом месте глухо висну. 
			Видимо, поток-то у меня все же один... Тогда наиболее правильный вариант - 
			вынесение всего пользовательского интерфейса в отдельный поток, но сейчас я 
			такого не потяну... Не потяну даже выяснения вопроса о том, в самом ли деле это 
			один поток (и если да - то каким образом выполнение одного запроса прерывается 
			другим).</P>
		<P>Проблему удалось победить (насколько успешно, покажут время и дальнейшие тесты): 
			отказом от входа в обработку таймера, ежели секция занята (полагая, что это не 
			будет фатально, к тому же ни одного подобного "попадания" зарегистрировать не 
			удалось). С обработкой OnMapChanged() так грубо поступать нельзя - буду 
			пропускать изменения карты. Поэтому в ситуации возможного дедлока отваливаюсь, 
			перед этим заново запостив себе же это же самое сообщение. В таком виде вроде 
			как работает...</P>
		<P>--------------------------------------------------------------------------------------------------------------------</P>
		<P>050222</P>
		<P>12:03 Поджал таймерный критический фрагмент, исключив из него начало обработки 
			(где массив каналов не используется). Поначалу было плохо после старта при 
			выключенном девайсе - видимо, из-за "выхода" из CS не сопровождавшегося вводом. 
			После заведения соотв. флага стало совсем хорошо&nbsp; :))) Правда, редкие busy 
			встречаются....</P>
		<P>ToDo:
		</P>
		<P><FONT color="#ff0066"><FONT color="#000099">- увеличить спин-каунт, вспомнить про 
					старший бит в нём</FONT>.</FONT></P>
		<P><FONT color="#000000">сделано в 20:25. После этого даже отошел от вчерашних 
				"нововведений" (отказа от входа в обработке таймера и повторного поста 
				сообщений в обработке OnMapChanged()) - и ничего, работает... Удалось получить 
				сообщение о невозможности войти (уже в режиме "ввода" - от таймера) - но и оно 
				не вызвало зависаний...</FONT></P>
		<P><FONT color="#000099">- Различать в OnMapChanged, какая карта изменилась - главная 
				или дочерняя. Полную обработку делать только по главной!!!</FONT></P>
		<P>сделано около 20:25. Но мне не понравилось, что для не-главной приходится 
			перебирать диалоги - почему-то из карты в создавший оную диалог сообщение не 
			доходит - ни в PreTranslateMessage (этот почему-то вообще не вызывается) - ни в 
			карту... Повозился, и вернул всё на места. Надо вспоминать...</P>
		<P>-------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050224 чт</STRONG></P>
		<P>Вялый день (отходняк). Утром успел послать четвертую фотку на фотосайт - дальше 
			в основном тем и занимался, что ждал ответов... Единственное, что сделал - 
			перенес в CMainFrame::OnTimer расчет смещений в основной канальный цикл (был в 
			отдельном).</P>
		<P>После чего задумался на тему: а что же я успел сделать на тему FIR-фильтра - и 
			где??? Только в восьмом часу вечера выяснил - сделано это было в 
			CHardDlg::SetMode, причем фильтр порождался локально - и тут же стирался 
			(использовался только для отладочной печати). То есть снова нужно думать: а где 
			же мне держать этот самый фильтр (чтобы не слишком далеко был) - и как 
			правильно организовывать буфера для фильтрации....</P>
		<P>---------------------------------------------------------------------------------------------------------</P>
		<P>050225 пт</P>
		<P>Снова ничего не удалось - и уже не получится, очевидно :(((</P>
		<P>В очередной раз полез в Ворд - и понял, что его дополнительное пусто-молчаливое 
			окно мне надоело! Снёс ОРФО - не помогло. Снес и поставил офис - не помогло... 
			В общем, помогло только: снести офис, вручную стереть соотв. ветки реестра - и 
			только после того поставить офис заново (видмо, глюк происходит из утилиты 
			переноса файлов и установок). Но после этого отказалась стартовать студия 
			.НЕТ.... Постановка "поверх" не помогла - пришлось сносить и ставить заново. А 
			какая уж после этого работа...</P>
		<P>Единственное, что смог сделать за день - это вспомнить, каким образом была 
			организована децимирующая фильтрация в dUEn. Там действительно заводились 
			буфера - по одному на канал, но размером точно в длину фильтра. Буфера - на ВСЕ 
			каналы, в том числе и те, которые фильтровать не предполагалось - чтобы было 
			откуда брать "синхронные" данные. Это, разумеется, порождало проблему 
			"цикличности", в простом варианте требующую дополнительного сравнения на каждом 
			шаге. Сия проблема обходилась следующим образом:</P>
		<P>if (((scan+decOff)%nDec)==0) {<BR>
			&nbsp;&nbsp;&nbsp;for (int k = posScanF+1; k &lt; FILLEN; k++)<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += 
			(double)pFiltBuf[k*nNumch+chn]*flFilter[kF++];&nbsp;<BR>
			&nbsp;&nbsp; for (k = 0; k &lt;= posScanF; k++)&nbsp;<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += 
			(double)pFiltBuf[k*nNumch+chn]*flFilter[kF++];
			<BR>
			}</P>
		<P>То есть вместо одного цикла использовалось два - но без "двойных сравнений"... 
			Интересно, а реальный выигрыш от этого есть?</P>
		<P>Где это всё должно находиться? Наверное, не слишком далеко: если потребление 
			данных и децимация будут производиться в CMainFrame::OnTimer, то и фильтр, и 
			промежуточные "фильтовальные блоки" должны лежать там же. Ситуацию с хранением 
			может слегка облекчить то, что изменение режима децимации возможно только во 
			время "останова" - тогда и аллоцировать буфера/считать фильтр может в 
			"стартовалке". Прибивать же буфера можно там же - и при выходе.</P>
		<P>-------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050228 пн</STRONG></P>
		<P>Итак, где держать фильтр и соотв. буфера, я решил. Но ведь не прояснен вопрос с 
			форматом!!!
		</P>
		<P>Вот и сижу целый день, считаю биты: что делать, дабы точно ничего не потерять - 
			при 24 входных, стольки же выходных - и фильтре длиной до 4097 коэффициентов... 
			Если верить мелкомягким, то в double у меня на мантиссу приходится 52 бита - то 
			есть потеря вроде бы минимальная... Конечно, пользовать все 64 - лучше... Но 
			слишком ли заморочно. И - главное - как проверить????</P>
		<P>В общем, голова моя не соображает :((( Так что остановлюсь пока на варианте 
			double...</P>
		<P>В итоге с большими трудами и длительным хождением по площадке перенес 
			формирователь фильтра в CMainFrame, и там же организовал "фильтровальный 
			буфер".</P>
		<P>Для меня не совсем удобно то, что таймерный цикл работает в цикле каналы-точки 
			(придется держать по указателю на канал). Нужно посмотреть, нельзя ли работу с 
			этим буфером вклинить таким образом, чтобы его заполнение (по крайней мере) шло 
			в порядке точки-каналы... Погружаемся в функцию OnTimer();</P>
		<P>----------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050301 вт</STRONG></P>
		<P>Еще одно неудобство, вызываемое циклом "каналы-точки": мне где-то нужно хранить 
			(и опять - по-канально) счетчик значений: с тем, чтобы фильтровать (и помещать 
			в выходной буфер) только нужные....</P>
		<P>16:20 Вроде как завел все необходимые переменные и прописал цикл децимации - 
			но... Увы, даже начать пробовать не могу: как только включаю децимирование, у 
			меня запрещаются-исчезают все диалоги. Надо проверять...<BR>
			16:24 При смене децимации я вызываю CHardDlg::SetMode(-1) - а контролы у меня 
			запрещались при модах &lt;= 0... <FONT color="#000099">Сменил на = 0... Нужно 
				проверить, в каких еще случаях SetMode вызывается с -1!</FONT></P>
		<P>16:37 Выяснил: -1 вообще-то используется как признак отключения... Сменил вызов 
			на SetMode(aMode.GetMode()); - используется существующее значение. Так лучше, и 
			даже не вылетает. Но:<BR>
			<FONT color="#000099">- Соответственно уменьшается и длительность вывода (4 секунды 
				вместо 8)<BR>
				- нечто похожее на реальные данные проскальзывает лишь изредка...</FONT></P>
		<P>В очередной раз - все та же проблема: не попадаю в карту сообщений вида. 
			Проблема была решена путём:<BR>
			- наследования класса вида от CMessageFilter<BR>
			- передачи ему в качестве параметра конструктора адреса CMessageLoop 
			графического потока<BR>
			При этом оказываются рабочими как PreTranslateMessage - так и карта 
			сообщеиний...</P>
		<P>Но вот параметры передаются всё равно не те....</P>
		<P>------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050302 ср</STRONG></P>
		<P>Выяснилось, что у меня и безо всякой децимации длины считаются неправильно: как 
			бы только для 2048 Гц... Теперь вот поди вспомни, какая из переменных чего 
			значит....</P>
		<P>14:02 - пытаюсь вспомнить<BR>
			m_nLength = m_nDur * m_nLen //явно - длина окна в отсчетах</P>
		<P>14:29 Да, исходно был совсем бред... Избавился от m_nLen, стал запоминать 
			частоту - стало нормально работать при разных частотах. Но не при децимации!!!</P>
		<P>15:02 Да, там и не в одном месте бред... CMainFrame::OnTimer передавал 
			ПОЛУЧЕННОЕ количество новых точек. А по-просту делить его тоже нельзя - по этим 
			точка ведется отсчет входного буфера... И вообще: передавать количество точек 
			неправильно, коль скоро это количество может быть разным для разных каналов!!! 
			Пусть пока - только для триггерного, но кто знает...
		</P>
		<P>16:15 А нужно ли мне что-нибудь для этого? Или уже существующий класс _ChanW эту 
			задачу может выполнить?</P>
		<P>19:28 Так и не вспомнил, как правильно делать колцевой буфер... Пока "тупо" 
			добавил счетчики занятого и свободного места... А ведь где-то, в каком-то 
			учебнике про это было хорошо расписано - с примерами, подводными камнями...</P>
		<P>-----------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050311 пт</STRONG></P>
		<P>И снова - перерыв больше недели :(((<BR>
			Походы по магазинам за подарками для мамы (все равно ничего делать не мог), 
			беседы с ЛБ по ТЗ, заливка нового ноутбука НСР, немного писанины по repeated 
			measures на выходных (которых было три дня), визит к Татьяне Александровне...</P>
		<P>В общем так: классы из стандартных библиотек использовать можно - но не буду: 
			универсальность мне не нужна, а вот возможные потери быстродействия могут 
			оказаться существенными. Сильно экомномить на паре переменных 
			(занятый/свободный размеры массива) тоже глупо: лишь затрачу кучу лишнего 
			времени на проверки при каждой операции. Посмотрим, на чём всё-таки 
			остановился...</P>
		<P>Итак, остановился на модификации ChanW. Идея: каждый канал должен передавать 
			полученное количество точек. Для этой цели хорошо подходят "внутренние 
			счетчики". Но, кроме того, мне нужно будет из каждого канала достать 
			информацию, на основании которой я смогу расчитать "горизонтальный масштаб"...</P>
		<P>В таком случае получается, что я в рамках CActDView должен отказаться и от 
			единого "Собственного буфера" (пересчитанные каналы, подлежащие отображению) - 
			а пользоваться тем же самым классом. То есть - списком каналов...</P>
		<P>В настоящий момент буфера определяются в <FONT color="#000099">CActDView::SetBuffers</FONT>
			как:<BR>
			m_nLength = m_nFrq * m_nDur/4;
			<BR>
			m_pRefBuf = new long[m_nLength];
			<BR>
			m_pChanBuf = new long[m_nLength*(m_nBufChans-2)];
			<BR>
			m_pBpBuf = new long[m_nLength*(m_nBufChans-2)];
			<BR>
			m_pTrigBuf = new WORD[m_nLength];</P>
		<P>Эта функция вызывается изнутри - из OnCreate и SetFrq; последняя - как обработка 
			сообщения, вызываемого диалогом (при смене длительности ) и главным окном (при 
			запуске - то есть по команде Go). То есть длительности перерасчитываются по 
			установленной длительности окна отображения. Количество каналов берется как 
			m_pMainFrame-&gt;GetActChans(); - то есть общее количество вводимых каналов!!! 
			А мне-то это зачем????
		</P>
		<P>Хотя есть и другая сторона вопроса: просто делать все каналы разными никак 
			нельзя: я просто не смогу считать референты/биполяры. Тогда получается, что 
			нужно (как это было в dUEn/dWEn) деление на группы. В то время, как сейчас 
			групп только две - "обычные" каналы и триггер. И понадобятся ли другие - совсем 
			неясно... И (кстати) - сколько может быть биполяров? "Теоретически" - очень 
			много (N*(N-1)), где N - число вводимых каналов. Практически же... А почему 
			пользователь не может захотеть получить ВСЕ межполушарные биполяры? Или 
			"привести" все каналы к соответствующему уху??? <STRONG>Ergo:</STRONG> биполярные 
			массивы тоже должны формироваться динамически: завели новую пару - добавили... 
			И тогда ещё один вопрос: а почему я должен заводить эти массивы на всю 
			длительность граф. окна? Просто потому, что в противном случае непонятно, каким 
			образом выбирать???</P>
		<P>Но если биполяры перераспределять динамически - то почему не поступать так же и 
			с остальными каналами?</P>
		<P>--------------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050315 вт</STRONG></P>
		<P>Насколько я помню, в пятницу единственное до чего добрался (кроме подобных 
			"досужих" размышлений) - попытался повнимательнее посмотреть, что же происходит 
			при децимации. Впечатления крайне негативные:<BR>
			- как будто фильтрует "не то" (слишком сильная фильрация)<BR>
			- при финальной частоте 128 Гц и частоте опроса 50 Гц (20 мс) я получаю 
			некратное (2.56) и маленькое количество точек на выборку. Как итог - "рваная" 
			кривая (точнее - ломаная).</P>
		<P>Кстати, где-то здесь и аргумент в пользу буферизации полного окна вывода: даёт 
			возможность перерисовать при перестилке... А как у меня со "сверхкороткими" 
			выборками в старых децимирующих программах???</P>
		<P>-------------------------------------------------------------- 
			------------------------------------------------------------------</P>
		<P><STRONG>050316 ср</STRONG></P>
		<P>И снова дальше этой пары мыслей дело не пошло... Посмотрел в старую программу: 
			никакого учёта "старой точки" (в пределах PolyLine) нет. Если и учитывается - 
			то на этапе буферизации...</P>
		<P>В очередной раз получается, что я хочу совсем по-другому... И при этом с трудом 
			соображаю, как именно... Но примерно:<BR>
			- Устройство опрашивать пореже (скажем, 5-10 Гц, то есть 100-200 мс)<BR>
			- после опроса, забора и опциональной фильтрации-децимации данных отправляется 
			сообщение "видам". Там происходит не только референсирование и опциональная 
			IIR-фильтрация - но и ТУТ ЖЕ формируются кривые (PolyLine), и ТУТ ЖЕ 
			отрисывываются (где??? В каком-то внутреннем еще одном граф. буфере)<BR>
			- собственно отображение происходит по СОБСТВЕННОМУ таймеру, с бОльшей частотой 
			(скажем, 50 Гц, 20 мс). Самое лучшее - это сделать отображалку привязанной к 
			кадровой развертке, но как это сделать я пока без понятия (были попытки с 
			directX, но неудачные - при обращениях с обычнми рисовательными функциями эту 
			систему клинит).<BR>
			- Рисовательный таймер запускается только после окончания обработки первой 
			порции данных<BR>
			- При его срабатывании нужно грамотно определять, какие точки (уже не точки 
			данных, а пикселы буфера) добавлять - и сдвигать при осциллоскопическом режиме.</P>
		<P>17:08 - в очередной раз залез посмотреть на DirectX. Нет, ничего там нет... 
			Ergo, не нарисовать....
			<BR>
			Если же поступать проще, то непонятно, какой таймер брать (все равно точно под 
			развертку мне будет не подобрать).</P>
		<P>---------------------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050317 чт</STRONG></P>
		<P>14:05
			<BR>
			<U>- При любом изменении дочернего окна делать полный его рестарт!!!<BR>
			</U>При этом я переопрелеяю и "граф. окно в памяти". Какого размера оно должно 
			быть? В принципе, с запасом должно хватить двукратной (даже полуторакратной) 
			длительности окна вывода. Но попробуем рассмотреть крайний случай: минимальную 
			длительность 1/4 секунды. Тогда, учитывая реденькое квантование ввода (около 5 
			Гц, то есть 1/5 секунды) весьма велик риск этот вывод перекрыть новым... А 
			может оно и не страшно? Посмотрим....<BR>
		</P>
		<P><U>- Поведение по граф. таймеру:<BR>
			</U>&nbsp;&nbsp; - Осциллоскопический режим<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - определяем относительное время (мс) 
			относительно старта этого окна<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - переводим это время в точки экрана<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- эта точка будет ПОСЛЕДНЕЙ отображаемой 
			точкой нового вывода<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ПЕРВОЙ точкой буфера будет последняя точка 
			предыдущего (включая - чтобы зарисовать серую линию - маркер)<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - Определяем, не было ли перехода через конец 
			окна:<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - не было - просто битблтуем 
			буфер<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - было - плюемся два раза (до 
			конца окна и от начала до конца буфера)<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - рисуем маркер<BR>
		</P>
		<P>15:10 Промежуточные буфера CActDView получаются независимыми от длительности 
			окна. Тогда можно поступить двумя способами: определять их однократно при 
			запуске ввода (и тогда отводить под все обрабатвываемые каналы) - или же 
			дополнительно переконфигурировать каждый раз при изменении количества 
			каналов... Похоже, что нужен будет именно второй вариант, прежде всего - из-за 
			недетерминированности количества биполярных каналов...<BR>
			В качетве длины этих буферов можно взять некоторое детерминированное значение - 
			скажем, 8 секунд...<BR>
			Изменение буферов должно происходить в функции "полного рестарта". Для этого 
			нужно определить точку входа обработки изменения карт каналов и биполяров. Но 
			(опять же!) preTranslateMessage до вида не доходит....</P>
		<P>15:32 Единственной рабочей точкой входа в диалоге является ф-ия CorrectMap() - и 
			то лишь потому, что она вызывается в цикле из главного окна!!! Все же хорошо бы 
			было, если бы можно было вызвать её не в цикле - а "целенаправленно"....</P>
		<P>15:42 - поступил с диалогом так же, как ранее с видом: в дополнение к уже 
			сущестовавшему наследованию от CMessageLoop нужно еще зарегистрировать этот 
			цикл в "основном". Но в отличие от вида, на сей раз основным является именно 
			главный цикл приложения (интересно, правильно ли это?). В таком варианте 
			CDlgView::PreTranslateMessage начинает работать....</P>
		<P>16:04 - в таком варианте даже PreTranslate не нужен - нормально работает вход по 
			CDlgView::OnMapChanged.<BR>
			Теперь нужно посмотреть, что происходит при подключении биполяров...</P>
		<P>16:19 - в обработчики биполярного чекбокса и листа добавлено 
			m_pView-&gt;PostMessage(WM_DIZ_MAPCHANGED);</P>
		<P>17:56 В текущей конфигурации происходит неприятная вещь: в осциллоскопическом 
			режиме графика сбрасывается на начало не только при изменении размеров окна, но 
			и при его перемещении (но не всегда). Концов этому делу найти не смог :((( В то 
			же время понял, что органолептически приятнее, когда после изменения размеров 
			окно не "обнуляется". Это значит, что я таки должен хранить промежуточные 
			буфера ПОЛНОЙ ДЛИТЕЛЬНОСТИ окна (иначе мне будет не восстановить нужные точки). 
			И предусматривать очень специальный режим отрисовки полного окна....</P>
		<P><FONT color="#ff0066">18:08</FONT> - сброс m_nPos на ноль происходит в OnPaint 
			из-за того, что она действительно оказывается "за пределами" окна. Но почему???</P>
		<P>18:12 Почему-то при перемещении окна равной его правой границе оказывается 
			перменная nWNew... Ищем...</P>
		<P>18:22 <FONT color="#000099">NB!!! Вылеты при удалении дочернего окна - я не 
				разрегистрирую цикл</FONT> сообщений!!!</P>
		<P>20:00 Удаление фильтра сообщений из родительского цикла (как для вида, так и для 
			диалога) помогла, но не совсем: все равно продолжились вылеты. Анализ показал, 
			что они проистекают из-за того, что после удаления вида становится 
			неопределенной переменная CMainFrame::m_pCurrentView. И тут мы имеем вопрос: а 
			какой собственно вид должен становиться текущим после удаления? Следующий? 
			Предыдущий? Тут поможет только волевое решение... Сделаем так:<BR>
			- если был удален не последний вид, текущим становится следующий (с тем же 
			номером)<BR>
			- если был удален последний вид, текущим становится предыдущий (естественно)<BR>
			- при удалении последнего вида переменная обнуляется</P>
		<P>20:12 И это не помогло. Пришлось добавить стандартное <FONT color="#000099">&amp;&amp; 
				::IsWindow(*m_pCurrView) . </FONT><FONT color="#000000">В таком варианте 
				вопросов не вызывает - и вроде бы закрытие проходит нормально. Возвращаемся к 
				вопросу от <FONT color="#ff0066">18:0</FONT>8 .</FONT></P>
		<P>20:52 - Нет, "запредельным" оказывается NWnew - видимо, всё здесь растёт из того 
			факта, что OnPaint вызывается "не во-время"...</P>
		<P>------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050318 пт</STRONG></P>
		<P>15:20 В погоне за сбоящими счетчиками обрамил все изменения/обращения 
			критическими секциями - всё равно не помогло. В итоге дело оказалось проще: в 
			самом начале CActDView::OnPaint стояло<BR>
			&nbsp; int nNewCnt = m_nCnt - m_nOldCnt;
			<BR>
			&nbsp; if (nNewCnt &lt;= 0) nNewCnt += m_nLength;<BR>
			- а в случае "произвольной перерисовки" счетчики оказывались равны, вот я и 
			получал "полную длину" вместо нуля. Проблему решила замена сравнения на "строго 
			меньше", с выходом из фукции при равенстве нулю.</P>
		<P>15:46 - закомментировал все обращения к критической секции. Всё равно работает 
			:) Видимо, внутри вида многопоточности нет :)))</P>
		<P>19:27 <EM>Отвлекся на фотографии, обед, Славу... А там выяснилось, что мало того что 
				корпуса в компах не те - так и процессоры тоже не те! И двух гигов ни в одном 
				нет... В итоге от рабочего настроения ничего не осталось - только злость, 
				упадок сил и матерные слова на душе... Надо попытаться и вспоминть, о чем же 
				(хорошем...) думалось вечером-утром... Там были какие-то варианты, картинки, 
				графы, можно сказать...</EM></P>
		<P>1) (Из вчерашнего 17:56) - канальные буфера вида нужно иметь на полную 
			длительность окна - для возможности полной перерисоки без потери данных<BR>
			2) "нормальный" (текущий) режим:&nbsp;I&nbsp;receive the Data&nbsp;(PostMessage 
			from MainFrame), fill ChanBuffers (with re-referencing and IIR-filtering) - and 
			plot received portion of data onto memory Bitmap. But which step will be the 
			next one? What should I do by CActDView timer message? There seems to be two 
			possibilities:<BR>
			2.1. Call RedrawWindow() - or post (send??) WM_PAINT message<BR>
			2.1. I can try to re-plot new portion of window by myself (without WM_PAINT)</P>
		<P>-------------------------------------------------------------------------------------------</P>
		<P><STRONG>050319 сб</STRONG></P>
		<P>Дома - таки нашел откомплированные тесты на Direct3D. Мнение о "не пойдёт" 
			подтверждено: на "не том" устройстве даже в самом директовом устройстве получаю 
			4-5 FPS , а это - ни в какие ворота....</P>
		<P>Проект вроде как синхронизиован с домашним компьютером.</P>
		<P>---------------------------------------------------------------------------------------------</P>
		<P><STRONG>050320 вс</STRONG></P>
		<P>Один из основных вопросов - размер "графического буфера". Я преследую две 
			задачи:<BR>
			1. Каждое очередное "рисование" (по полученному большому куску данных) должно 
			быть цельным - не перехлестывать через конец-начало<BR>
			2. По возможности хотелось бы избежать и "перерисовки" еще неотображенных 
			данных (хотя это и не фатально - если местами и будет отображаться "не совсем 
			то")</P>
		<P>Определять его совсем статитчески, раз и навсегда - наверное, не совем 
			правильно. При необходимости можно и "перераспределить" - но заниматься этим 
			каждый раз тоже не хотелось бы... Тогда так: при первом вхождении выделять 
			память с некоторым запасом (20-30-50%), в дальнейшем перераспределять при 
			нехватке.</P>
		<P>Вопрос с "простотой отображения": наиболее простым представляется вариант одного 
			циклического буфера. Но даже в нём я получу "точку под вопросом" - вводимые 
			данные имеют переменную длину, совсем необязательно кратную выводу. Намного ли 
			увеличастя мои затраты, если я буду держать не один кольцевой, а 2-3-4 "сменных 
			буфера"?</P>
		<P>Какую информацию в таком случае я захочу иметь об этих буферах?</P>
		<P>---------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050321 пн</STRONG></P>
		<P><EM>Снова день суеты: в дополнение к пятничным проблемам с компами добавился и 
				потекший водогрей... Проверить микроволновку, слить воду... Если что-то и писал 
				- то только сюда, в "размышления" - но было утеряно при перезагрузке компа, в 
				очередной раз приключившейся при попытке что-то воткнуть во frontal&nbsp;USB... 
				Это "что-то" было от НС - они заходили вместе с Галей...</EM></P>
		<P><EM>Вечером выбирался поснимать на мост лейтенанта Шмидта</EM>.</P>
		<P>-----------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050322 вт</STRONG></P>
		<P><EM>Утром отправил на сайт свиристель. На многое не расчитывал - но получилось 
				совсем мало: три с половиной часа спустя всего 1-0-1 рек и один комментарий... 
				Ладно, не суть</EM></P>
		<P>К делу: при планируемой отрисовке непонятно, что делать с нулём. В скролл-режиме 
			этот вопрос как бы и не стоит (там ноль считается по кнопке). А в осц? Я (вроде 
			бы) принимал за ноль первую точку окна - а сейчас-то я даже не знаю, какая 
			точка будет первой...</P>
		<P>Но подожди... В осц-режиме я МОГУ узнать, какая точка будет первой в окне. Я 
			только не узнаю, в какой граф-скан (и какое его место) она попадёт... Размер же 
			окна является фиксированным В СЕКУНДАХ - то есть я ещё и гарантированно не 
			получу разрыв "где-то между точками". Но тогда получается, что в осц-режиме я и 
			полилайны должен строить уже с оглядкой на выходное окно... Интерполируя 
			последнюю линию, считая последнюю точку (в окно уже не попадающую) по СТАРОМУ 
			нулю - и начиная новое с НОВОГО нуля...</P>
		<P>15:13 - все еще читаю свой код, голова никакая... Переименовал функцию OnPlot в 
			Plot - чтобы не путать с OnPaint. Залез в неё: а если попытаться объединить 
			подсчет референтного канала и перекладывание отображаемых в одном цикле 
			(перебираю все введенные каналы, если есть в рефмаске - добавляю к рефбуферу, 
			если есть в прочих - перекладываю). Тогда реферирование будет делаться отдельно 
			- уже перебором отображаемых каналов. Это избавит от двоякого подхода к 
			итераторам каналов введенных.</P>
		<P>------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050326 сб</STRONG></P>
		<P>Опять вся неделя - в никуда. Фотографии, "доклад" (вроде бы и без подготовки - а 
			всё равно и среда ушла, и четверг вместе с ней). В субботу попробовал чем-то 
			заняться - но опять не обнаружил головы на месте, в итогде готовил к 
			архивации-записи отснятое...</P>
		<P>---------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050328 пн</STRONG></P>
		<P>В очередной раз возвращаюсь к дилемме: мне не хочется заводить в виде буфер под 
			ВСЕ возможные каналы (а для биполяров это и невозможно) - но в то же самое 
			время хотелось бы сохранить "преемственность" (при включении/выключении одного 
			канала отображение старых остается).</P>
		<P>Или же... Плюнуть на это дело и каждый раз - заново??? Наверное, и в этом есть 
			смысл... Тогда получится так...</P>
		<P>15:56 - переделал выделение буферов. <FONT color="#000099">Но под Ref полная длина 
				не нужна!!!</FONT></P>
		<P><FONT color="#000000">---------------</FONT><FONT color="#000000">-------------------------------------------------------------------------------------------</FONT></P>
		<P><STRONG>050329 вт</STRONG></P>
		<P>несмотря на общую суету (ОВ ищет свою установку, ЛБ задает вопросы - ну и 
			Термекс впридачу), взялся за программу. Не с первого раза, но удалось (в 
			очередной раз) довести до рабочего состояния - с новыми буферами...</P>
		<P>16:59 - вновь заработало... Ну а если мне (для начала хотя бы) отказаться от 
			сохранения больших буферов - и "держать в голве" только то, что приходит??? С 
			одной стороны, я при этом лишусь возможности перерисовать все окно... Попробую 
			пока пережить... Тогда выделение буферов должно происходить там же, где и 
			референтного - в Plot()</P>
		<P>20:52 - уже образован новый класс _GrBitmap, заложены его основные переменные и 
			образец конструктора... Но еще совсем не решено, как это должно выглядеть по 
			большому счету...<BR>
			- я работаю не с отдельным битмэпом - со списком<BR>
			- Начало: перебрать список и найти первый "свободный" битмэп (флаг фрии = 1)<BR>
			&nbsp;&nbsp; - не найден - создаем новый, длиной на 20% больше требуемого 
			размера<BR>
			&nbsp;&nbsp; - найден - смотрим на размер,
			<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - если не подходит - удаляем, создаем новый на 
			20% больше требуемого размера (длины)<BR>
			- получаем "рабочий" битмэп.<BR>
			- рисуем в нём....</P>
		<P>Первый же возникающий вопрос - что означает "перебрать список"? По уму, это 
			должно как-то касаться итераторов....</P>
		<P>Второй вопрос - делать ли мне список моих битмэпов - или же наследовать свой 
			класс от списка с добавлением в него битмэповской функциональности. Или же - 
			наследовать от битмэпа? (Уж наверняка в WTL что-то подобное есть?)</P>
		<P>--------------------------------------------------------------------------</P>
		<P><STRONG>050330 ср - </STRONG>
		</P>
		<P><STRONG>11:00 - дома</STRONG></P>
		<P>Вечером (то ли по дороге домой, то ли уже дома) осознал, что я уже не помню даже 
			ЗАЧЕМ были затеяны эти последние изменения - когда, вроде бы, и без того 
			более-менее работало... С трудом, но вспомнил: из-за невозможности правильной 
			отрисовки при высоой частоте вывода на экран - и сильной децимации (т.е. когда 
			итоговая частота ввода 128 Гц, а частота вывода - около 50 Гц; я при этом 
			получаю около 2.5 точек на вывод). Дома попытался посмотреть книжки - грустно. 
			Всё нужно было делать по-другому: контейнеры, итераторы... Тогда было бы 
			красиво...</P>
		<P>Нуждается в сильной переделке и работа с отображаемыми каналами: сейчас я 
			перебираю отдельные карты (отображаемых, референтных) - и совсем не занимаюсь 
			биполярами (потому что не знаю, что с ними делать). Видимо, нужно при запуске 
			(и каждом изменении карты/списка бп) строить какую-то карту "отображения" всех 
			вводимых каналов: с признаками референтности, отображаемости (и номер), 
			биполярности (с плюсом или минусом - и тоже номер) - а при получении совершать 
			однократный проход по этой карте. Тогда в итоге у меня исчезнет разница между 
			моно- и биполярными каналами - уже на этапе IIR-фильтрации и отображения я буду 
			работать с единым массивом.
		</P>
		<P>По поводу списка битмэпов: мне НЕ нужно производить перебор всех, чтобы 
			определить, нет ли свободного. Если свободный есть - то это следующий за 
			текущим. Если следующий еще занят, то свободного нет. Вопрос: сразу ли мне 
			зацикливать (например, создавая первый узел со ссылкой на себя самого) - или 
			держать признаки конца и начала для перехода? И хорошо бы какие-то функции 
			"встроить" напрямую в этот контейнер: чтобы сам он поставлял нужный битмэп для 
			рисования - и, по возможности, сам из себя выдавал нужные фрагменты для 
			отображения.<BR>
			Последний вариант - снова двояко: либо заводится еще один (промежуточный) 
			битмэп на случай, если запрошеннй фрагмент попадает на стык. Либо "выдаваться" 
			может больше одного фрагмента... Думаем... Ага: контейнеру в качестве входа 
			будет даваться битмэп "куда" (pDst), и временн<STRONG><EM>ы</EM></STRONG>е 
			координаты желаемого участка. И тогда контейнер (список) действительно САМ 
			поместит изображение в pDST - независимо от того, оказалось ли оно цельным 
			куском - или было разорвано между разными узлами.</P>
		<P>21:07 - "рабочий" день начался с побежки к ТА. Потом всё-таки взялся за работу - 
			дополнил несколькими функциями класс _GrBitmap, ввел ссылку на него в 
			CActDView. Чтобы проверить хотя бы элементарную (основную) работоспособность, 
			нужно что-то работоспособное написать. Начал потихоньку переность рисовательные 
			функции из OnPaint в Plot... Но тут позвонила Галя - проблема с принтером. В 
			итоге время с трех и до семи на это и ушло - но хоть пообщались....
		</P>
		<P>Таким образом, только к девяти какой-то перенос функций осуществлен - но до 
			работоспособности еще очень далеко: пока сплошные вылеты и ничего кроме...</P>
		<P>---------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050331 чт</STRONG></P>
		<P>12:05<BR>
			Причины вылетов отслеживал долго: на работе, дома вечером и утром, снова на 
			работе... Оказалось, дело в вызываемой (автоматом) ф-ии OnSize - а там в 
			удалении битмэпа, который не был правильно инициализирован нулём.</P>
		<P>13:52<BR>
			Ограниченной работоспособности добился. Вылетаю внутри Plot()&nbsp; - и именно 
			где-то в рисовании.... Бум ловить.</P>
		<P>14:24<BR>
			Угу. Я похоже что запутался - какую размерность у меня имеет m_pChanBuf... Еще 
			один повод для того, чтобы и такие массивы "классифицировать"....<BR>
			14:35<BR>
			Да, "подстановка" правильного значения (m_nMaxCnt) от вылетов избавила&nbsp;- 
			вроде как и работает... Только вот не рисует - но это потому, что никакого 
			рисования и нет :)))</P>
		<P>14:44 - Как-то работает - но ведь я еще даже не объявил образованный битмэп 
			занятым! Более того, следов вызова деструктора тоже не наблюдается....</P>
		<P>15:01 Какого.. у меня при delete m_pBmp; не вызывается деструктор????</P>
		<P>18:23 после выхода в город с этим разобрался: удаление вызывалось из деструктора 
			вида - и было описано в h-файле, в котором класс _GrBitmap был только объявлен, 
			но неопределен (не был включен соотв. заголовок). Вот деструктор и не 
			вызывался.... После переноса тела деструктора в спп-файл деструктор вызывается 
			- но (довольно логично) вызывает переполнение стека: единственный битмэп у меня 
			ссылается сам на себя... Надо думать, как развязать этот узел...</P>
		<P>19:21 - частично добился: временная переменная, отказ от рекурсии, если pNext == 
			this. Но я еще не выставлял флаг "занято" - то есть работал с единственным 
			битмэпом... Рискуем:</P>
		<P>19:24 - Ввел флаг занятости (освобождения пока нет - как нет и отображения, в 
			ходе которого освобождение должно получатся). Новые битмэпы образуются без 
			фатальных последствий, удаление тоже идет как запланировано - за исключением 
			последнего: здесь я все-таки&nbsp; в какое-то подобие рекурсии впадаю....</P>
		<P>19:27 - и это решено: в качестве флага "валидности" бмп использую его указатель 
			m_pNext: если он нулевой, то удалять этот битмэп уже не надо... В таком виде 
			работает (то есть битмэпы выделяются - и уничтожаются без видимых утечек 
			памяти.)<BR>
			Наступает время думать об отображении и сопутствующих ему флагах....</P>
		<P>20:14 - задумался о том, каким таймером я буду пользоваться. Наверное, 
			мультимедийным - решил... Но такое впечателение, что мультимедийный у меня 
			используется только в "медленном&nbsp; режиме"... НО! Впечатление оказалось 
			обманчивым - у меня же написана собственная функция SetTimer!!! А она описывает 
			уже "заправку" мультимедийного...<BR>
			&nbsp;&nbsp; Но вопросы на этом только начинаются. Например: мультимедийному 
			таймеру на вход подается колбэк-процедура. Ну а если подавать оную - то ее 
			нужно будет и завести :))) И очень интересно знать, в каком контексте она будет 
			выполняться... Ведь у меня должны быть <EM><U>раздельные</U></EM> таймеры и 
			процедуры для <EM><U>разных экземпляров</U></EM> моего вида...Ну, положим что 
			ссылку на экземпляр я как-то смогу этой ф-ии передать - но все равно вопрос: 
			как она будет вызыватсья????</P>
		<P>21:51 Первые тесты показали, что этот таймер вызывается неким глобальным потоком 
			- и, соответственно, вызываемые им ф-ии выполняются в нем же - а не в 
			графическом потоке... Завтра надо будет попробовать "обычный таймер"...</P>
		<P>-----------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050401 пт</STRONG></P>
		<P>Утренние тесты показали: мультимедийные таймеры идут в отдельном потоке - 
			отличном как от основного потока приложения, так и от "граф." потока 
			конкретного окна. Видимо, это не то, что мне нужно: я хочу сохранить приоритет 
			за вводом (а отображение, тем более множественное, в том же потоке может это 
			дело затормозить). Будем пытаться "разрулить"...</P>
		<P>Хотелось бы избежать использования "обычного" таймера: хотя бы потому, что в 
			этом случае (насколько я помню) невысок приоритет сообщения в очереди (хотя кем 
			он регулируется???). Можно пробовать пользовать мультимедийный - но сообщение 
			окну посылать/постить...</P>
		<P>14:02 - проходит даже "элементарный" вариант с SendMessage - сам таймер работает 
			в одном (своем) потоке, а сообщение обрабатывается уже в "правильном" потоке 
			граф. окна. Только получился какой-то "затык" при выходе....</P>
		<P>14:37 - от вылета при закрытии окна "спасает" принудительное "убиение" таймера. 
			Но вопрос остается: хорошо бы этот таймер убивать и при остановке ввода... 
			Но... Но делать это нужно не сразу - в принципе-то надо дожидаться конца То 
			есть какой-то признак конца должен содержатся в самой очереди передаваемых на 
			отрисовку картинок....</P>
		<P>15:45 Первые пробы рисования вызывают уныние... Во-первых, ничего не получается 
			отрисовывать без WM_PAINT (и инвалидации нужного региона). Во-вторых, 
			битмэпчик-то у меня похоже что черно-белый получился... Сначала разберемся с 
			цветами:</P>
		<P>15:55 Ага, если битмэпу передовать не m_hMemDC, a m_hDC - то цвета получаются. 
			Но пока я что-то совсем не вижу "реальной отрисовки"...</P>
		<P>15:57 - тоже понятно: рисующий фрагмент был просто закомментирован. После снятия 
			комментов получается хорошо :) Думаем дальше.</P>
		<P>21:00 !!!!<BR>
			Иду по пути дальнейшего "деления" рисовательных контекстов. Тот, в котором 
			будет производиться собственно рисование (во временных переключаемых битмэпах) 
			будет называться m_hTempDC. Название m_hMemDC будет закреплено за контекстом, 
			"напрочь" спаянным с "постоянным битмэпом" - то есть тем, который в каждый 
			текущий момент будет отображать "реальную" картинку на экране.</P>
		<P>-----------------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050402 сб</STRONG></P>
		<P>что-то опять едва шевелюсь...<BR>
			Итак, send от одного потока к другом проходит - но вопрос в организме остается: 
			будет ли выполнение вызывающего потока приостановлено на время работы 
			вызваемого? И как это проверить?</P>
		<P>Относительно же самого рисования: если вернуться к идее о заполнении 
			результирующего битмэпа самим классом "списка динамических", то выглядеть оно 
			должно так: определяем результирующий прямоугольник, передаем его (вместе с 
			прочими необходиыми переменными) списку - а потом отзваниваем на экран именно 
			его...</P>
		<P>14:46<BR>
			Проверка установила: вызывающий поток тормозится.<BR>
			Попутные проблемы:<BR>
			- в некоторых случаях при рисовании получаю undefined c - видимо, рисование с 
			нулевым к-м точек. Но не проверял<BR>
			- недетерминированное поведение при закрытии вида. В том числа - отлеты при 
			попытки определить IsWindow (вида уже нет, и его m_hWnd - тоже). Нужно как-то 
			более правильно обнулять CMainFrame::m_pCurrentView/</P>
		<P>16:46 !!!!!!!!!!<BR>
			Частично разобрался с отлетами. Основная причина была ясна еще вчера - я не 
			останавливал таймер. Более детальный анализ показал, что основная 
			деинициализация вида вообще производилась в OnClose - а эта ф-ия вызывалась 
			лишь при клике на соотв. кнопке; таким образом при общем закрытии она участия 
			не принимала. Проблема решена переносом нужного кода в деструктор - но не 
			уверен, что таким образом решены все проблемы...<BR>
			(<EM>на этом месте решил провести перестановку - а то слишком часто забываю 
				выключать прибор. При этом случайно выключил монитор - и чуть не... 
				Выключатель-то у него в очень незаметном месте :))) </EM>)</P>
		<P>16:55 - проверка nDisp &gt; 0 добавлена к CMainFrame::OnTimer - в место, где 
			сообщение посылается дочерним видам. Теперь из самого вида эту проверку можно и 
			убрать....</P>
		<P>-----------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050404 пн</STRONG></P>
		<P>19:20<BR>
			И все воскресенье провел в погоне за птичками, и понедельник по большей части 
			неизвестно куда делся... Вроде бы что-то делать и пытался - но собственно "за 
			дело" принялся лишь в седьмом часу...</P>
		<P>Проблема в чем: у меня три единицы измерения: отсчеты, миллисекунды и точки 
			(окна вывода), и отношения между ними не слишком простые (с учетом некратности 
			и ошибок округления). А я хочу максимально упростить "механизм" передачи 
			изображения из временных битмэпов в "запоминающий". В простой ситуации я еще 
			могу переложить практически всю работу на "временные битмэпы" - сказав им лишь 
			"куда" выводить и "сколько" миллисекунд нужно (хотя ведь могу - и в точках???). 
			Но может возникнуть случай, когда очередная перерисовка не только перекроет два 
			временных битмэпа - но и попадет на границы запоминаемого (в осц-режиме). И что 
			тогда???</P>
		<P>20:05 -
			<BR>
			Начинаю с того, что еще более инкапсулирую работу с временными битмэпами в них 
			самих: там же будет храниться и контекст устройства. Для этого он сначала будет 
			создаваться. (Подозреваю, что копирвоание - не пройдет).<BR>
			20:17 _GrBitmap<BR>
			Я не только создаю свой CDC, но и тут же выбираю в него m_hBmp. Перед 
			уничтожением - отмена выбора.</P>
		<P>20:23 Вовнутрь засунута FillSolidRect<BR>
			20:44 Вовнутрь засунуты Line, PolyLine, SetPixels (рисует не одну, а две 
			точки). Оставлена переменная CActDView::m_hTempDC - но только для 
			CActDView::OnNcPaint() - для отрисовки стрелочки...<BR>
		</P>
		<P>21:28 - получены первые признаки жизни. Много внимания приходится уделять тому, 
			передаются ли собственно объекта (например, HPEN) - или же их WTLевские 
			обертки. С обертками получается плохо. При передаче объектов одна отрисовка 
			проходит :)</P>
		<P>&nbsp;------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050405 вт</STRONG></P>
		<P>13:27 На работу пришел в начале одиннадцатого, но за работу берусь только 
			сейчас... Как и вчера, лазал по амазонам - птичьи книжки заказывал. Заходила 
			Лида (после ночного дежурства), пообщались. Фотосайт, опять же... Так вот время 
			и уходит...</P>
		<P>Итак, вчерашний вечер завершился тем, что отрисовка происходит - но только один 
			раз. И где искать концы, не совсем понятно: накручено много. Но уже видна одна 
			существенная недоделка: мне недостаточно ОДНОГО указателя m_pBmp - нужно иметь 
			отдельные указатели для записи (рисования) и чтения (отображения). Не очень 
			понятно, как нужно обходиться с контекстами устройств: иметь ли один на все 
			битмэпы - или создавать свой для каждого. Один, вроде бы, чего-то должен 
			сэкономить - но тогда при каждой записи/чтении придеся перевыбирать битмэпы...</P>
		<P>14:25<BR>
			Проблема оказалась вчерашняя: нужно было таки передавать в копирующую ф-ию HDC, 
			а не CDC. Возможно, это связано с тем, что в "родителе" (виде) m_hDC определено 
			как HDC, а не как CDC... Но проблемы остаются:<BR>
			- по-прежнему встречаются вызовы с нулевым к-м отсчетов<BR>
			- похоже, что все битмэпы, кроме первого, у меня получаются черно-белыми...</P>
		<P>14:28<BR>
			- нулевое к-во отчетов порождается невалидным коэффициентом децимации 
			(-858993460) - теперь нужно понять, откуда он берется.<BR>
			14:38 - Видимо, какое-то неверное число западает в CHardDlg::m_nDecIdx... 
			Добавил инициализаций и проверок - не знаю, поможет ли. Отловить - не могу....<BR>
			14:43 Разница в битмэпах определялась разинцей в конструкторах: в 
			копи-конструкторе тоже нужно создавать битмэп, как совместимый с 
			РОДИТЕЛЬСКИМ!!! Теперь все - цветоное...</P>
		<P>16:08 Поискал взламывалки на adobe drm - ничего... Поиски плавно перешли в 
			беседу со СФ на тему планов - огорчил ее... Вывод один: нужно продолжать...
			<BR>
			Итак: рисование идет. Теперь нужно сделать, чтобы рисовалось то, что нужно :)</P>
		<P>17:47 Борюсь с рваной и неровной отрисовкой. Пока обедал, пришла в голову мысль 
			о возможном источнике: при обработке таймера я каждый раз определяю количество 
			точек, к-е нужно отрисовать со времени ПРОШЛОГО прихода - и оно часто 
			оказывается нулевым. А я должен считать время, прошедшее от начала окна!!!</P>
		<P>19:20!!!!<BR>
			Я неправильно расчитывал координаты при рисовании!!! Брал в числителе - общую 
			ширину окна, а в знаменателе - число актуальных отсчетов. Переход на пару 
			"ширина отрисовки"/"полученные отсчеты" тоже мало помогает (числа маленькие и 
			нецелые). После применения пары "ширина окна"/"число отчетов на окно" 
			отображение идет нормально - насколько я могу судить... И битмэпа при этом 
			образуется только два :))) !!!!</P>
		<P><FONT color="#000099">Но попытки децимации программа не переносит....</FONT></P>
		<P>Перекур - и думаем дальше....</P>
		<P>21:06 !!!!!!!!!!!!!!!<BR>
			Меня "зацепил" размер первого битмэпа - 63 отсчета, 1-2 точки... Ну и всё 
			прочее на этом месте "циклило". Вычислить не мог долго, много отладочной печати 
			потребовалось. С ее-то помощью и было установлено: ДО вклчюения я каждый раз 
			абортировал драйвера (чтобы иметь возможность изменить режим). А первый запуск 
			после включения ВСЕГДА читает эти самые 63 точки!! Соответственно, для решения 
			проблемы пришлось "забуферизовать" флаг запуска (в локальной переменной ф-ии 
			CMainFrame::OnTimer() ) - и ставить эту переменную в false в случае, если 
			драйвера переоткрывались...<BR>
			&nbsp;&nbsp;&nbsp; Самое интересное, что это (на первый взгляд, по крайней 
			мере) решило и вопрос с "разорванным рисованием" - оно стало нормальным!!! Но 
			надо проверять дальше...</P>
		<P>Почему-то у меня при этом битмэп образовался только один... Что непонятно...<BR>
			<FONT color="#00cc00">ToDo - нарисовать правую границу в осц-режиме.</FONT></P>
		<P>21:21
			<BR>
			Граница нарисована.<BR>
			Нет разрывов при основном таймере 800 и 400 мс (что с битмэпами - не проверял). 
			При 200 они появляются - но вроде бы только на первом экране...&nbsp; Нужны 
			дальнейшие проверки...<BR>
		</P>
		<P><FONT color="#000000">21:45
				<BR>
				Опробованы варианты со скроллом. По первым впечатлениям - мерзко. (пробовал 
				скроллировать в памятьи - и выбрасывать чохом, 20 мс). При меньшей частоте - 
				еще более мерзко. Вроде бы более-менее - при 10-15 мс и прямом скроллировании 
				m_hDC... Но похоже, что это чревато нестабильностью системы - и совсем плохо с 
				множественными окнами..</FONT></P>
		<P>21:53 - да нет, вроде бы и через память все выглядит приемлимо (даже и на 10 мс) 
			- но только на CRT. Для LCD не подходит. <FONT color="#000099">ПОпытка открытия 
				второго окна вешает программу насмреть....<BR>
			</FONT><FONT color="#000000">так что даже зашатдаунюсь....</FONT></P>
		<P>--------------------------------------------------------------------------------------</P>
		<P><STRONG>050406 ср</STRONG></P>
		<P>На работу пришел в полодиннадцатого - но вместо программы занялся шопом: правлю 
			скворца... Отвлекся на кофе - а тут ННБ с брюлевскими проблемами... Пять минут 
			такого разговора - и день потерян :((( Да и с шопом тоже - то цвета не 
			нравятся, то рамка... Сделаешь - потом переделываешь... Изредка заглядывая в 
			то, что происходит с программой</P>
		<P>13:52<BR>
			Первое, что беспокоит - поведение при ресайзе. Дебаг ничего не дает (получается 
			инвалидное окно-получатель, не более того). На самом деле все понятно: у меня 
			при ресайще удаляются временные битмэпы - а в это время может происходить 
			запись в них. Попробуем обрамить критическими секциями.</P>
		<P>14:32<BR>
			Несмотря на крит. секции вылеты продолжились - я не обнулял m_pReadBmp - и не 
			проверял ее на равенство нулю при отрисовке.</P>
		<P>15:22<BR>
			Нет, все-таки при 200 мс опросе неполадки с отображением есть - какие-то 
			полоски рисуются... И это - в однооконном режиме. Что же происходит в 
			многооконном - я вообще пока понять не могу :((( То ли он их отображает 
			"вперемешку" - то ли вообще по очереди...</P>
		<P>15:44<BR>
			Пытаюсь перейти на WM_TIMER - пока что-то не получается....<BR>
			16:14 (после обеда) "нерабочесть" WM_TIMER объяснялась тем, что я в порядке 
			теста обнулял (int*)(lParam) - а там при нормальном сообщении содержалось 
			что-то осмысленное... Теперь сообщение проходит - но рисовать нормлаьнее прога 
			не стала...</P>
		<P>16:46 Решил побороться с остановкой: путем посылки сообщения о "нулевом" 
			рисовании и выставлении при оном _GrBitmap::m_pNext = 0. Получилось не сразу: у 
			меня SetNext(0) ставила значение this. После попраки работает - но повторный 
			запуск уже не проходит.... К тому же понятно: я при этом теряю цепочку....</P>
		<P>16:55 - сменил на обнуление размера. В таком виде проходит и рестарт - только 
			самое начало получается "совсем не то". С двумя окнами - все равно полная 
			лажа..</P>
		<P>---------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050407 чт</STRONG></P>
		<P>Так весь вчерашний вечер с этими проблемами и промаялся... Единственное, что 
			стало очевидно - что BitBlt отображает прямоугольник, НЕ включающий правую 
			границу, то есть все расчеты нужно делать исходя из этого. Багов же...<BR>
			- после добавления/удаления каналов получается "полосатость" отображения<BR>
			- аналогично - после ресайза (но не после max/restore window)<BR>
			- после подобных изменений возникают "молчаливые участки" - похоже на попытку 
			вывода за пределами окна<BR>
			- можно отображать и два (и больше) окон - но только пока в них разные каналы<BR>
			- очевидно неверна скорость при скролл-выводе</P>
		<P>Вечером (по дороге домой и перед сном) посетили мысли. Точно помню, что их было 
			три - но вот какие... Вроде бы так:<BR>
			- Во-первых, сбои при выводе в несколько окон объясняются тем, что разные 
			отображения пользуются одним "входным итератором" - а для каждого вывода нужен 
			свой собственный!!! Как????<BR>
			- Во-вторых, для "разборок" мне обязательно нужно выводить на экран секундные 
			метки. Проще всего ставить их уже в m_hMemDC - но это явно не то, что мне нужно 
			для отладки. А вот как выводить эти метки во "временные битмэпы"...<BR>
			- "полосатость отображения" при смене числа каналов явно закладывается на этапе 
			отрисовки битмэпа - но непонятно, каким образом...</P>
		<P>11:57 Начну, пожалуй, с обдумывания вопроса о секундных метках...</P>
		<P>12:53 Алгоритм отрисовки секунд во временных битмэпах придуман - и он довольно 
			прост... Но рисуется не каждая секунда... То ли у меня могут встречатсья 
			битмэпы, перекрывающие сразу две (???), то ли я "накрываю" при собственно 
			выводе - неясно...<BR>
			12:56 Адаптировано для случая многих секунд - все равно получается "не каждый 
			раз". Выходит, перекрываю....<BR>
			13:00 !!! Замечательно. Один из вопросов с "минус единицей разрешился" - теперь 
			каждая секунда отрисовывается... Но: у меня получилось, что окно оказывается 
			длинее заданного (то есть выводится, скажем, больше 8 с). Причем через какое-то 
			время эта разница исчезает - и дальше уже попадает "секунда в секунду"... Как 
			бы это могло быть? Очень похоже на ошибки округления - которые через какое-то 
			время исчерпываются...</P>
		<P>13:40<BR>
			В CMainFrame введена новая ф-ия - void Stop(), в которую сведены необходимые 
			при остановке действия. Вызвается она как по кнопке - так и в случае "отлёта" 
			программы (при выключении питания и т.п.), обеспечивает остановку графических 
			таймеров.<BR>
		</P>
		<P>Попутно выясноилось, что сейчас у меня стало резко нехорошо с "рисованием за 
			пределами окна" - после пары проходов курсор пропадает, и я нахожусь неизвестно 
			где... Интересно, это - следствие домножения времён на 10???</P>
		<P>14:05<BR>
			Я кое-что понял!!! "ошибки округления" и выода связаны с разрывом между 
			вызовами: ведь между последней точкой первого полученного буфера и первой 
			точкой второго лежит одна дискрета - и эта линия должна отображаться!!! И она 
			занимает на графике какое-то, пусть близкое к нулю - но ненулевое расстояние в 
			окне. Соответственно, ошибок тем больше, чем меньше дискрета отрисовки - а с 
			увеличением дискреты у меня и в самом деле все становится лучше.<BR>
			&nbsp;&nbsp; Я уже думал об этом: обязательно нужно запоминать последнюю точку 
			каждого буфера - и учитывать ее при отрисовке следующего. Но при этом сама 
			точка отображаться как бы и не должна... Или же - не должна отображаться 
			последняя точка... В общем, ой... И, видимо, все это нужно каким-то образом 
			состыковывать с "входным массивом" - и, соответственно, теми самыми 
			"индивидуальными итераторами"....</P>
		<P>14:33<BR>
			Собственно, я имею проблему циклического буфера (_ChanW) с единственным 
			доступом по записи - и множественным доступом по чтению. Доступ по чтению может 
			устанавливаться в двух случаях:
			<BR>
			- при запуске ввода (для всех открытых окон) и
			<BR>
			- при открытии нового окна во время ввода<BR>
			Получается, что для каждого доступающего по чтению окна я должен иметь свой 
			комплект указателей и счетчиков - плюс глобальный комплект (учитывающий, что 
			канал прочитан ВСЕМИ окнами, которые его хотят читать)</P>
		<P>Даже еще сложнее: ведь один буфер - это один канал, а "существование" канала в 
			конкретном окне может меняться динамически (то отображаем, то не отображаем). 
			При этом "неотображаемость" канала не должна вызывать иллюзии занятости - а 
			включение "отображаемости" должно приводить к тому, что канал начнет читать не 
			с любой точки - а именно с той, которая нужна (синхронной с другими каналами)</P>
		<P>Ладно, о "детальной" (поточечной) синхронизации я могу не думать - но по крайней 
			мере на уровне "одной получки" я ее обеспечить должОн!. При этом вариант 
			"одного счетчика" тоже не устраивает - именно потому, что у каналов может быть 
			разная децимация (как было сказано выше, сейчас - только у обычных и триггера). 
			Следовательно, мы волей-неволей возвращаемся к идее dWEn-dUEn - обеспечения 
			"групп каналов". Но и при этом без "индивидуальных" счетчиков не обойтись...</P>
		<P>Общий итог: идея "глобализации" счетчиков в данном случае была плоха. Но в то же 
			время - что-то глобальное нужно: чтобы отслеживать занятость буфера и его 
			"общетекущую" точку....</P>
		<P>15:50<BR>
			Тогда так: понятия "занят-свободен" вводятся ПОБЛОЧНО. При очередном заполнении 
			КАЖДЫЙ канал запоминает место, с которого заполнялся - и место ДОКУДА. 
			Сообщение отправляется ВСЕМ ВИДАМ. Но - у меня, собственно, нет специального 
			метода, чтобы запоминть "начало заполнения". Я могу зафиксировать лишь момент 
			"готовности к посылке" - и именно его считать "состоянием буфера", которое 
			будет передаваться (а оно, собственно, включает в себя начало-конец, из которых 
			и длина может быть посчитана). Признака "свободности" я при этом получить, увы, 
			не смогу....</P>
		<P>17:18<BR>
			Слишком запутано всё... Пока завёл лишь самую элементарную ф-ию 
			_ChanW::ResetRW() - просто устанавливающую указатель чтения на указатель 
			записи. Но здесь нет ни контроля переполнения/опустошения - ни даже самой 
			элементарной защиты от одновременного доступа :(((</P>
		<P>19:00<BR>
			Как выяснилось, целая куча проблем была вызвана сегодня же введенной ф-ией 
			CMainFrame::Stop(). А именно, я в ней не убивал таймер, что в итоге (правда, 
			непонятно почему) приводило к вызову основного таймера с очень коротким 
			периодом - а это, как мы уже выяснили, сказыывается на всем крайне негативно. 
			После правильных разборок с таймером стало чуть легче.</P>
		<P>19:44<BR>
			Аналогичным образом решены вопросы с изменением размера: тоже нужно было не 
			только делать все в критической секции - но и убивать таймер (с тем, чтобы 
			восстанавливался он уже из ф-ии Plot() )<BR>
			&nbsp; Собственно, поведение при изменении длительности вывода (отрабатываемое 
			через SetFrq() ) исправлено тоже вводом посылки себе сообщения WM_SIZE<BR>
			&nbsp; Таким образом, стало самую капельку - но легче. Но не совсем легко: 
			проблемы с выводом остаются. В частности, временами (увы, далеко не каждый раз) 
			при достижении границы окна битмэп заполняется одинаковыми 
			фрагментами&nbsp;чего-то, после ресайза возникают неопределенности с выводом 
			секундных маркеров...</P>
		<P>---------------------------------------------------------------------</P>
		<P><STRONG>050408</STRONG></P>
		<P>Главные вопросы на сегодняшний день:<BR>
			<FONT color="#000099">- откуда берутся перекосы после ресайза<BR>
				- откуда берутся "лишние точки" после добавления/удаления каналов<BR>
				- как поступать с граничными точками вывода (отрисовка линии от последней точки 
				пред. до первой нового)</FONT></P>
		<P>.17:17<BR>
			Так ничего и не понял. Попытка проверить на изменение размеров (сравниваю 
			размеры битмэпа и текущие размеры окна) ничего не прояснила: разница не 
			обнаружена....</P>
		<P>20:43<BR>
			Ну вот, весь день прошел - и ничего не сделано...<BR>
			Какие-то мысли мелькали, пока ходил платить за интернет: нужно сделать так, 
			чтобы на рисование отправлялось на одну точку больше, чем получено: добавлять в 
			начало предыдущую точку (для первого запуска - просто дублировать нулевую). При 
			этом в отображение эту точку не включать - только считать линию от неё (если 
			таковая линия имеется).<BR>
			&nbsp; Но полным спасением это не станет: вполне реальна ситуация, когда на 
			каждый пиксел вывода придется каких-нибудь 5.5 точек ввода. И тогда, получив 
			эту "первую" точку в очередном выводе, я должен буду знать - является ли она 
			первой в новом пикселе - или четвертой в старом... А этого я никак не узнаю, 
			если не буду напрямую в Plot() отслеживать точко-пиксельное соответствие - 
			базируясь на окне. Соответственно, нужен еще один счетчик (подобный тому, каким 
			я считаю секунды) - точно отсчитывающий необходимое количество отсчетов на 
			окно. Тогда и расчеты станут более "правильными" - и можно будет попытаться 
			решить проблему с нулём при осц-выводе.</P>
		<P>--------------------------------------------------------------------</P>
		<P><STRONG>050409 сб</STRONG></P>
		<P>Ничего не придумал - но продолжал размышлять и по дороге домой:<BR>
			&nbsp; По всему выходит, что мне для очередного вывода (заполнения битмэпа) 
			может понадобиться предыдущая вертикаль (но может и не понадобиться). Отсюда 
			вытекает тот не слишком приятный факт, что все колупания последних двух недель 
			(собственный битмэп на каждый вывод) шли не туда: в таком варианте предыдущую 
			точку можно получить лишь со значительными затратами.<BR>
			&nbsp; На смену приходит вариант с буферизацией всего графического окна: причем 
			имеется как минимум две копии: в одну рисуется, по графическому же таймеру эта 
			(первая) копия частично переносится во вторую (отображаемую). Вторая, 
			собственно, является полной копией экрана.<BR>
			&nbsp; Возикает вопрос: хватит ли мне двух копий? Какие могут возникнуть 
			проблемы при при переходе за границы окна? Как это будет выглядеть при 
			скролл-отображении???</P>
		<P>-------------------------------------------------------------------</P>
		<P>050411 пн</P>
		<P>Еще немножко подумал вечером: нет, такой вариант чреват. Как и любой другой 
			"фиксированный", он рискует наскочить на несоблюдение заложенных условий (а что 
			будет при 1/4-секундном окне? А что будет, если вывод еще подзадержится?). 
			Ergo, мне судьба вернуться к (слава богу) еще не аннулированному варианту 
			временных битмэпов - но с его дальнейшим усложнением (расчет точек по размерам 
			окна, перенос последней колонки).</P>
		<P>Еще одна шальная субботняя мысль: вообще-то у меня все проблемы растут из 
			некратности ввода и вывода - то есть из того факта, что я получаю практически 
			ЛЮБОЕ количество точек. А если это дело ограничить? То есть: даже получая 
			больше, выводить всегода полсекнунды? Надо посмотреть, какие кол-ва я 
			получаю....</P>
		<P>11:40 Попробовал. Нет, этот вариант (с фиксацией к-ва получаемых точек) не 
			пройдёт: при частоте 2048 и времени 500 мс я получаю чаще всего 1016 точек (на 
			8 меньше), иногда - 1080, а при первом приеме - так и вообще 953...</P>
		<P>12:39<BR>
			Думал, что вообще уже того... При каждой остановке - полный отлёт, и концов не 
			найти... Оказалось - все просто: я перешел (в пятницу, ближе к вечеру, в 
			истории не отражено) на задание размеров битмэпа с указанием прямоугольника 
			родительского окна - а при остановке ввода эта ф-ия вызывалась с двумя нулями. 
			Вот я и пытался получить размеры прямоугольника, адрес которого равнялся 
			нулю.... Как вредно прерываться хоть на что-либо...</P>
		<P>Анализ "кратностей вывода" показал: чаще всего добавка будет равна 1, и примерно 
			с одинаковой частотой - 2 и 0. Не могу понять, будет ли это фатально.... И 
			нужно ли вообще думать на тему: насколько серьезно будет улучшение? При 
			произвольном кол-ве точек в окне (оно может быть и простым числом!) и широких 
			рамках его временных границ - не факт...</P>
		<P>13:01<BR>
			Как ни крути, начинать нужно с главного: канальный буфер должен мне возвращать 
			на одну точку больше (включая предыдущую или - для самого первого раза - дубль 
			первой точки). Так что начать мне нужно с того, что определить, чем "самый 
			первый раз" отличается от всех остальных.</P>
		<P>Речь идет об элементах списка CMainFrame::m_arChanW. Формируется список в 
			OnMapChanged() (наверное, можно было бы и по старту - но сейчас менять не 
			буду). При запуске ввода в OnRunGo для каждого элемента выполняется команда 
			SetBuff() - так что она и может быть тем местом, где возможна пометка 
			первого/непервого раза...<BR>
			&nbsp; После этого данные в буфер кладутся по таймеру - командой Put(). При 
			этом при каждом тике выполняется&nbsp;ResetRW() -&nbsp;устанавливающая 
			указатель чтения на указатель записи (кстати, потенциально опасная команда!). 
			Похоже, что это место я является для меня самым интересным: я могу установить 
			указатель чтения ПОЗАДИ указателя записи. Ну а так как это - сравнительно 
			редкая процедура - то и&nbsp;доп. проверка на границу буфера&nbsp;не окажется 
			сильно затратной.<BR>
			&nbsp; Минус в том, что всё это происходит ДО положения первого числа в буфер - 
			то есть в случае "самого первого раза" я еще не могу ничего положить в 
			"предпервую точку"....</P>
		<P>14:34<BR>
			Решил разделить&nbsp;"синхронизацию указателей" на две части: перед началом 
			записи очередных данных&nbsp;текущая позиция указателя записи (откуда и нужно 
			будет начинать чтение) запоминается в переменной m_dwWposOld, а синхнонизация 
			(присваиваение указателю чтения значения, на единицу меньшего, чем это) 
			произоводится уже после записи. При этом&nbsp;у меня появляется возможность 
			однократно проанализировать флаг "первого раза" - и&nbsp;для&nbsp;этого случая 
			скопировать уже имеющееся первое значение.<BR>
			&nbsp; Сначала хотел даже производить второй этап синхронизации в 
			CActDView::Plot&nbsp;- но там я работаю уже с локальными копиями итераторов, а 
			флаг (обязательно!!!) нужно менять глобальный!!!&nbsp;&nbsp;<BR>
			14:58 -&nbsp;проверил, после небольшой корректировки (нельзя делать без флага 
			m_bRun - буфера неопределены) вылетов нет...</P>
		<P>15:35<BR>
			Перехожу к отображению. Завел переменную CActDView::m_nWinFrameCnt - а теперь 
			думаю, что же с ней делать...<BR>
			- во-первых, определять "нулевой отсчет" (для вычисления нуля при осц-выводе)<BR>
			- во-вторых, похоже что лучше будет при достижении границ разбивать на два 
			битмэпа (ситуацию с перекрытием избегать)<BR>
		</P>
		<P>19:23<BR>
			Как-то очень долго и муторно определял начальную точку для отсчета нуля... 
			Вроде получилось. Перехожу к раздумьям о координатах.</P>
		<P>19:34<BR>
			_GrBitmap::Resize() перенесена вовнуть _GrBitmap::GetFree(), туда же добавлено 
			копирование первой колонки (пока не проверил).<BR>
			19:39<BR>
			_GrBitmap::FillSolidRect() - запрет на стирание нулевой колонки (которая была 
			скопирована из пред. битмэпа)<BR>
			19:48<BR>
			Интересно, как она у меня работала? Я же при ресайзе не отменял выбор битмэпа в 
			контексте... И сейчас ошибку допустил: не тот контекст использовал в кач-ве 
			шаблона для создания (нужен m_hParDC)</P>
		<P>--------------------------------------------------------------------------------------</P>
		<P><STRONG>050412 вт</STRONG></P>
		<P>Мысли вечерне-домашние:<BR>
			- у меня иногда возникает ошибка при начале ввода, связанная с перенесением 
			первой точки буфера в последнюю. Не исключено, что это может быть вызвано и 
			"сбоями" самой оси (выделение и кэшировние памяти). Попробовать выделять НА 
			ТОЧКУ БОЛЬШЕ, резервируя "минус первую точку".<BR>
			- видимо, без разибиения переходящего через границу окна битмэпа на два мне не 
			обойтись. В этом случае само рисование лучше вынести в отдельную ф-ию, которую 
			и можно будет вызывать два раза</P>
		<P>12:19<BR>
			Угу, это получилось. Теперь нужно все-таки посчитать - что мы передаем, что 
			получаем, что и где рисуем...<BR>
			1. Ввод - передача. На входе получаем nCnt точек - но передаётся в вид на одну 
			точку больше!!!<BR>
			2. Рисовать будем именно эту nCnt+1 точку из расчета:<BR>
			&nbsp; - На экран приходится m_nLength точек<BR>
			&nbsp; - нулевая точка рисуется в нулевой колонке.
			<BR>
			&nbsp; - точка с номером m_nLength рисуется в колонке m_nWinW+1<BR>
			&nbsp; - точка с произвольным номером рисуется в колонке 
			N*(m_nWinW+1)/m_nLength<BR>
			&nbsp; - при очередном (не первом в окне) рисовании координата точки 
			определяется как:<BR>
			&nbsp;&nbsp;&nbsp; - (m_nWinFrameCnt + i)*(m_nWinW+1)/m_nLength - m_nWinPixCnt, 
			где<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nWinFrameCnt - последний&nbsp;отсчет пред. 
			рисования<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nWinPixCnt - последняя точка пред. рисования 
			(она же - нулевая текущего)<BR>
			3. Отображение:<BR>
			&nbsp; - окно занимает nDur*250 ms<BR>
			&nbsp; - окно занимает m_nWinW точек<BR>
			<BR>
			14:14<BR>
			Налетел с _ChanW::m_dwRpos - ставлю его в -1, а он же у меня DWORD :))) Изменил 
			на long</P>
		<P>14:57 !!!!<BR>
			Из вспомненного вчера по дороге домой (на мосту), и не попавшего в список: 
			копировать в первую колонку нового окна нужно последнюю "рабочую" старого!!!<BR>
		</P>
		<P>15:17<BR>
			Еще один баг выловлен - но свежий (вчерашний): образовывая в поисках свободного 
			битмэпа новый, я возвращал не его...<BR>
			Получена какая-то работоспособность, но:<BR>
			- сбои на границе окна (а я до сих пор не бью битмэпы по его границе - так что 
			все может быть....)<BR>
			- посередине окна тоже что-то бывает<BR>
			- совсем плохо с 1/4-секундным окном (что, в связи с вышеизложенным, 
			понятно...)</P>
		<P>15:30<BR>
			Начато выделение рисования в отдельную ф-ию CActDView::Draw()</P>
		<P>15:37<BR>
			Функция выделена - пока без анализа на конец окна.</P>
		<P>20:24<BR>
			Около четырех пообедал, посмотрел - все равно фигня получается. Не попадаю я в 
			окошко... Вроде бы и считаться все должно правильно - а промахиваюсь: то в одну 
			сторону, то в другую... Плюнул, воспользовался солнышком - пошел поснимать... И 
			подумать.<BR>
			Все же: насколько "фатален" переход к полноэкранным битмэпам?<BR>
			- ждать до окончания заполнения текущего необязательно. Но нужно проверять, 
			чтобы ненароком не отобразить еще неотрисованное (лучше заход-другой пропустить 
			- и отобразить полностью)<BR>
			- выделять можно точно также - динамически. Если битмэп еще не отображен - 
			рисовать в следующем.<BR>
			- предусмотреть какой-то флаг конца...</P>
		<P>делаем чекин - и пробуем перемордовать...</P>
		<P>20:35<BR>
			Но у меня изменится понятие свободы!!! То есть: если в текущем битмэпе еще 
			достаточно места для отрисовки - то он свободен... А если нет - то и занят....</P>
		<P>21:09<BR>
			Нет, эти расчеты вообще находятся вовне ф-ии Draw(). Она вызывается уже всегда 
			со указанием на свободный битмэп (то есть и битмэп выбирается вовне). Выбор 
			может происходит при нехватке места в текущем...</P>
		<P>-------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050413 ср</STRONG></P>
		<P>12:00<BR>
			Не выдержала душа, откатился (благо и изменений-то почти не было) - решил еще 
			раз проверить, где же ошибаюсь. Для проверки ввел доп. переменную - первый 
			пиксел битмэпа (по отношению к окну). Проверка показывает, что сбой на одну 
			точку получается каждый раз при переходе границы битмэпа (src правее dst). Чем 
			это может быть вызвано?<BR>
			- ошибка при образовании битмэпа (не учитываю перекрытия)<BR>
			- ошибка при сдвиге</P>
		<P>17:39<BR>
			Последним перед проглукой с Галей "открытием" стало наблюдение над совсем уж 
			хитрым сбоем: в качестве следующего у меня оказался предыдущий битмэп... В 
			общем, совсем...</P>
		<P>18:43<BR>
			Я чувствую, где проблема - но чувствую и то, что мне ее не побороть... Таки 
			надо переделывать... Делаем чекин с лейблом...
			<BR>
			<FONT color="#ff0066">SMALLBITMAP</FONT></P>
		<P>18:57<BR>
			Внесены первые изменения в класс _GrBitmap()</P>
		<P>20:25<BR>
			Уже что-то рисует НО:<BR>
			- странные линии в на все окно в конце<BR>
			- таки "грязь" (пробелы при копировании???)<BR>
		</P>
		<P>-------------------------------------------------------------------------</P>
		<P><STRONG>050414 чт\</STRONG></P>
		<P>Просидел почти до десяти, и лишь по дороге домой понял: этого не может быть! Не 
			могут возникнуть на экране линии, проходящие ЧЕРЕЗ ВСЕ окно!!! Снова нужна 
			отладка...</P>
		<P>11:40<BR>
			С линиями стало яснее: при рисовании перехода обнулял лишнюю переменную. 
			Продолжает быть непонятно с:<BR>
			- разрывами<BR>
			- точкой обнуления<BR>
			- "лишними" прямыми в начале каждого битмэпа....</P>
		<P>12:05<BR>
			Третий пункт (лишние линии) прояснен - "не то" значение A (должно быть x0). С 
			остальными - неясно....</P>
		<P>13:12<BR>
			Разрывы на графике возникают в точках несовпадения имеющегося m_nWinPixCnt и 
			расчитанного x0....</P>
		<P>13:46<BR>
			Удален m_nWinPixCnt - избегаем двусмысленностей....</P>
		<P>14:18<BR>
			Нехорошие разрывы и проч. пропадают, если ликвидировать не-стирание первой 
			колонки очередного вывода. Но непонятно, правильно ли это: ведь все расчитано 
			как раз на тот случай, что в этой колонке уже есть инфа, которую не нужно 
			удалять - а в текущем выводе она лишь дорисовывается...<BR>
			&nbsp; Плюс к тому: очередные тестовые добавки показали, что у меня имеются 
			неприятности с ф-ией Copy()/////</P>
		<P>16:30<BR>
			Нет, неприятности у меня были не с Copy()!!!
			<BR>
			В ходе перестройки была утеряна специфика записи рисовательного таймера: он 
			запускался не после второго, а после первого потребления данных - и когда 
			отображение переходило на следующий участок, он еще не был заполнен!!! А 
			"проверки" (фиксация пределов отрисованного и проверка корректности 
			отображения) я так и не завел... Сейчас проблема решена просто путем запуска 
			таймера лишь после второго потребления данных - но если по-хорошему, то нужна 
			проверка. Причем она должна быть достаточно хитрая (чтобы в следующий раз 
			рисовать, включая неотрисованный при прошлом вызове участок)<BR>
			&nbsp;&nbsp; Короче, сейчас рисование (но только в осц-режиме!) идет - за 
			исключением спецслучая 1/4 секунды....</P>
		<P>16:42<BR>
			Убраны тестовые заливка синим и косая линия</P>
		<P>16:43<BR>
			В битмэпе m_nEndPix фикируется не только по PolyLine(), но и по 
			FillSolidRect();&nbsp; обнуляется при GetFree();</P>
		<P>16:46<BR>
			Битмэп проверяет попытку&nbsp;копирования за пределами участка, при выходе 
			возвращает 0 и ничего не копирует.</P>
		<P>16:55<BR>
			Проверка в виде при копирвоании. Приходится делать в двух местах. Появлись 
			остановки в конце окна.</P>
		<P>17:17<BR>
			Зависы в конце окна были вызваны ситуацией строгого равенства прошедшего 
			времени ширине окна - получалось, что в очередной раз я хочу отрисовать ВСЕ 
			окно, вот и не мог... Изменение проверки на &gt;= спасло....
			<BR>
			&nbsp; Таким образом, проверка на отображение неотрисованного реализована - 
			проверено в режиме запуска граф. таймера после первого ввода. Но при этом вывод 
			получается "рваный" (часто приходится ждать). Возвращаюсь к запуску после 
			второго ввода.</P>
		<P>17:28<BR>
			<FONT color="#ff0066"><FONT color="#000099">- начинает слегка сбоить при 1/2 секунде<BR>
				</FONT><FONT color="#000099">- совсем не работает при 1/4 секунды<BR>
				</FONT><FONT color="#000099">- не прописан скролл-вариант<BR>
				</FONT><FONT color="#000099">- не прописаны биполяры<BR>
				</FONT><FONT color="#000099">- совсем непонятно с децимацией....</FONT><BR>
			</FONT>В целом - пахота только начинается....</P>
		<P>17:43<BR>
			При внимательном рассмотрении "проблемы" с полусекундным окном оказались в 
			основном - в области остановки. А там нехорошо при любых длительностях: я 
			впадал в цикл "невозможности рисования" (не было новых данных), а обнулялся 
			лишь следующий битмэп. Введено обнуление текущего, но и следующий тоже оставлен 
			- на всякий случай...</P>
		<P>17:50<BR>
			С четвертьсекундой тоже все не так плохо: проблема вырастала все из той же 
			плюс-минус точки: в таком варианте последняя была на точку раньше длины 
			окна.... После введения поправки вроде как работает...</P>
		<P>18:00<BR>
			Переходим к формированию скролл-варианта:<BR>
			- модифицирован вызов _GrBitmap::Copy - берет два прямоугольника, Dst и Src, 
			второй может быть равен нулю (для осц-варианта), и тогда приравнивается к 
			первому<BR>
		</P>
		<P>19:39<BR>
			Чего-то изобразил. Отрисовывать скролл начинает - но очень быстро 
			затыкается....</P>
		<P>19:54<BR>
			Угу, теперь и не затыкается. Но скорость вывода - явно не та: теряю точки....</P>
		<P>19:57<BR>
			Повычитал единиц :) Вроде бы похоже. На четвертьсекунде вылетает (хотя кому это 
			может понадобиться????). С нулем - не то! Ищем - где и как его считаем....</P>
		<P>20:21<BR>
			Про ноль вспоминл. Скроллируем худо-бедно :)))) Вылет при скроллировании на 
			четвертьсекунды образовывался из-за вызова рисовалки с нулевым счетчиком. 
			Откуда - не знаю, просто заблокировал этот вариант....</P>
		<P>Ну и что теперь? Биполяры или децимацию???</P>
		<P><STRONG><EM><U>Ха! Поздравляю!! Я вернулся на уровень 1 ноября!!! То есть&nbsp;- делаем 
						децимацию :)))</U></EM></STRONG></P>
		<P>Сейчас я даже не уверен - то ли все децимируется правильно, а передается совсем 
			не то - то ли огрехи лежат в области самой децимации. И даже не очень 
			представляю, как это выяснить... Разве что на максимальном сжатии, когда у меня 
			должно выйти около 64 точек на получку....</P>
		<P>21:15<BR>
			Выяснил: точно недодаю при собственно децимации: последние точки равны нулю....</P>
		<P>21:22<BR>
			Похоже, что я не то передаю... Кладу в буфер 61 точку, а говорю - 63 ????</P>
		<P>21:28!!!!!<BR>
			Ага!!! Я ошибался на точку!!! Нужно не<BR>
			<FONT color="#000099">if (nDecCnt++ &gt;= m_nDecCf)<BR>
			</FONT>а<BR>
			<FONT color="#000099">if (++nDecCnt &gt;= m_nDecCf)</FONT></P>
		<P>Теперь количество точек передается правильное. Но вот нравится ли мне это????</P>
		<P>21:33<BR>
			Нет, мне это определенно не нравится:<BR>
			- уж очень непохоже на результаты IIR-филтрации: как будто и не отфильтровали 
			вовсе... И прямые участки..<BR>
			- через какое-то время вывод начинает "затыкаться" - такое впечатление, что 
			ввод за ним не поспевает...
			<BR>
			- не возникает ли проблем с некратностью точек????</P>
		<P>Но об этом будем думать - завтра....</P>
		<P>--------------------------------------------------------------------------</P>
		<P><STRONG>050415 пт</STRONG></P>
		<P>14:40<BR>
			Первая удача дня: отлаживать в цифрах децимацию немыслимо - пришлось 
			догадываться. А догадка показала: я не сбрасывал глобальный флаг m_bStart - то 
			есть при поступлении каждой следующей порции данных фильтровальный буфер заново 
			заполнялся первым значением... Введение сброса помогло: стало выглядеть 
			приемлимо...<BR>
			- с фильтрацией как-то сильно не то. Либо я недофильтровываю FIR, либо 
			перефильтровываю IIR - либо при IIR-фильтрации не учитываю децимацию<BR>
			- возникают тормоза вывода - похоже на нехватку данных<BR>
			- при малой длине окна - тут же затыкаемся. Похоже, что просто не хватает 
			последней точки (или - проблемы некратности окна)</P>
		<P>14:56<BR>
			Ну конечно! Фильтр у меня формируется диалогом - и непохоже, чтобы там как-то 
			учитывалась реальная частота дискретизации...<BR>
			<FONT color="#000099">- коэффициенты для других частот (сейчас - только для 2048)<BR>
			</FONT><FONT color="#000000">--- это было записано в пятницу, 1 октября 2004 года 
				!!!!<BR>
				А теперь мне придется еще и вспоминать - каким же таким образом я считал эти 
				коэффициенты...</FONT></P>
		<P>19:42<BR>
			Выяснил, что считал их 23 июля :) Логику расчетов восстановил - только потому, 
			что она была записана в этом дневнике. После чего последовал длительный 
			перерыв: обед, прощальная прогулка с Галей... Возвращение, финансовые 
			вопросы... Но к мысли вернуться смог. На сей раз, чтобы точно не забыть: так я 
			считаю highPass фильтры:</P>
		<P><FONT style="BACKGROUND-COLOR: #66ffff">&nbsp; function f = hpIIR(cutFrq, dFrq)
				<BR>
				&nbsp;&nbsp;&nbsp; [bBh aBh] = besself(1,cutFrq,'high');
				<BR>
				&nbsp;&nbsp;&nbsp; [bN aN] = bilinear(bBh,aBh,dFrq/pi/2);
				<BR>
				&nbsp;&nbsp;&nbsp; f = [bN aN]; </FONT>
		</P>
		<P>При помощи этой функции можно составить таблицы и для других частот 
			дискретизации. Но сначала нужно понять, какие они могут быть:<BR>
			- "родные":&nbsp;<BR>
			16384<BR>
			&nbsp;&nbsp;8192<BR>
			&nbsp; 4096<BR>
			&nbsp; 2048<BR>
			&nbsp; 1024&nbsp; - децимированные<BR>
			&nbsp;&nbsp; &nbsp;512<BR>
			&nbsp;&nbsp;&nbsp; 256<BR>
			&nbsp;&nbsp;&nbsp; 128</P>
		<P>Итого получается 8 разных частот, при предусмотренных&nbsp;7 частотах highpass 
			среза<STRONG><U> (0.1, 0.5, 1, 3, 5, 10, 100&nbsp;)</U></STRONG>&nbsp; получаю 
			матрицу из&nbsp;48 элементов :) Неплохо :)))) Даже пока каждый элемент состоит 
			из четырех чисел :)))</P>
		<P>Заполняем.</P>
		<P>20:31<BR>
			Таблица HighPass коэффициентов заполнена. НО! Нет самого учета частоты - и не 
			изменены данные комбобокса.</P>
		<P>20:38<BR>
			Данные комбобокса изменены, для облегчения доступа к финальной частоте заведена 
			соотв. ф-ия MainFrame::GetFrq().</P>
		<P>20:55 - это сделано, НО! Коэффициенты не меняются при смене децимации в 
			харддиалоге - только по комбобоксу!!! <STRONG><FONT color="#000099">Ошибка!!!</FONT></STRONG></P>
		<P>21:04<BR>
			Для устранения этой ошибки запрос коэффициентов введен в CActDView::SetFrq(), 
			которая вызывается по OnRunGo(). <FONT color="#ff0066"><STRONG>Но! А что у меня 
					происходит при создании нового окна уже в процессе ввода????</STRONG></FONT></P>
		<P>Видимо, уже на завтра - все то же для LowPass...</P>
		<P>21:19<BR>
			Ага, чуть было не налетел - причем точно не в первый раз. В матлабе про Besself 
			написано, что он только lowpass - но на самом деле считается и highpass, причем 
			при наличии ЛЮБОГО третьего аргумента!!! :)))<BR>
			<FONT color="#000099">Во-вторых - наверное, нужно изменить порядок частот: пусть 
				сразу за выключенным следует наибольшая, а потом - по уменьшению...</FONT></P>
		<P><FONT color="#000000">21:26<BR>
				Порядок в диалоге изменен. Закладываем основы - но заполнять буду завтра....</FONT></P>
		<P>--------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050416 сб</STRONG></P>
		<P>13:47
			<BR>
			Заполнена таблица для IIR Low-Pass филтров.</P>
		<P>13:57<BR>
			Проверено. Похоже, что результаты совпадают (IIR фильтрация после децимации не 
			влияет там, где не должна). Двигаемся дальше:<BR>
			<FONT color="#ff0066"><STRONG><FONT color="#000099">- Затыки<BR>
						- "нехватка данных"<BR>
					</FONT>- <FONT color="#000099">длительные уходы за нулевую линию после переключения</FONT></STRONG></FONT></P>
		<P>14:36<BR>
			Размышляя над проблемой "затыков": при малой частоте дискретизации и малой 
			длительности вывода я получаю сколь угодно большое рассогласование между 
			последней точкой линии - и последней точкой битмэпа. То есть: одна точка 
			находится еще в этом битмэпе (далеко от край), следующая - уже в другом (и тоже 
			далеко от края). Каков же выход?<BR>
			&nbsp; Возможно, в подобной ситуации нужно пытаться рисовать линии, выходящие 
			за пределы битмэпа - как в конце, так и в начале. Видимо, делать это придется в 
			сочетании Plot &amp; Draw...</P>
		<P>14:43<BR>
			Простое решение: если текущий ввод выходит за пределы битмэпа, рисуется включая 
			СЛЕДУЮЩУЮ точку - ну а новый начинается с ПРЕДЫДУЩЕЙ. Но при этом появляются 
			"взбрыки" (которые можно будет проверить лишь на хардовом сигнале) - и от 
			"нехватки данных" я не спасен... Нужно думать поточнее...</P>
		<P>15:36<BR>
			Проверка показала: при сильной дециации я недосчитываюсь точек НЕЗАВИСИМО ОТ 
			ДЛИНЫ ОКНА!!!</P>
		<P>16:02<BR>
			Видимо так: я же передаю кол-во точек ДЕЛЕНИЕМ, а оно не учитывает ОСТАТОК. 
			Нужно же - реальное кол-во точек...</P>
		<P>16:09<BR>
			Изменил. Но при этом куда-то исчезла часть секундных меток (при 20с) - и все 
			равно затыкается....</P>
		<P>18:15<BR>
			Вот уже второй час сильно сомневаюсь: а что же у меня вообще со счетчиками? Я 
			же (вроде как) собирался передавать НА ОДНУ ТОЧКУ больше??? Стал смотреть - 
			пока высмотрел только, что m_nCnt уже нигде не используется - убрал...</P>
		<P>18:35<BR>
			Внимательно прошелся по m_nWinFrameCnt - поизменял где-то на единичку, строгое 
			неравенство на нестрогое... Но без четкого понимания - что и где меняю. Надо 
			сейчас в SourceSafe проверится...
			<BR>
			&nbsp; Факт: стало лучше - но все равно до тормознутого варианта добираетмя... 
			блиин....<BR>
			<STRONG><FONT color="#000099">&nbsp; К тому же явно есть логическая несостыковка с 
					фильтрами: первая полученная точка ввода является на самом деле последней 
					точкой предыдущего - то есть уже сохраненной...<BR>
				</FONT></STRONG>&nbsp; Лезу в VSS.\</P>
		<P>Было&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			стало</P>
		<P>Plot - рисование
		</P>
		<P>if (m_nWinFrameCnt + nCnt &gt; 
			m_nLength)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			if (m_nWinFrameCnt + nCnt &gt; m_nLength)<BR>
			{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
			&nbsp;&nbsp;&nbsp; int nC = 
			m_nLength-m_nWinFrameCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			int nC = m_nLength-m_nWinFrameCnt + 1;</P>
		<P>Draw - конец</P>
		<P>if (m_nWinFrameCnt &gt;= m_nLength) m_nWinFrameCnt -= 
			m_nLength;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			if (m_nWinFrameCnt &gt; m_nLength) m_nWinFrameCnt -= m_nLength;</P>
		<P>&nbsp;</P>
		<P>18:49<BR>
			Последнюю строчку вернул к старому варианту (показалось логичнее). Не помогло: 
			дело в том, что все равно начинаю "сбоить". Причем - где-то через 64 окна (или 
			128 секунд???)<BR>
			Проверить не могу: при 4-секундном окне - уже не дождаться....</P>
		<P>19:35<BR>
			Разобрался с секундами: к их счетчику добавлялся nCnt, а нужно - nCnt-1; Теперь 
			они похоже что точно попадают - и не пропадают. Счетчик переименован из <STRONG>m_nOldCnt</STRONG>
			в <STRONG>m_nOneSecCnt</STRONG>.От "недоввода" это, понятное дело, не 
			спасает...</P>
		<P>19:45<BR>
			Похоже, нужное исправление вот: при переходе к рисованию и обнаружению выхода 
			за пределы окна следующее окно должно начинаться с той же точки,&nbsp;на 
			которой закончилось это:<BR>
			<FONT color="#000099">//выходящую за пределы точку убираем
				<BR>
				nC--;
				<BR>
				nCnt -= nC;
				<BR>
				nBase = nC; </FONT>
		</P>
		<P>По крайней мере, после этого уже пять минут рисует крайне децимированное 
			двухсекундное окно. На этом завершаем, напомнив предстоящие шаги:</P>
		<P><STRONG><FONT color="#3300cc">TODO<BR>
					- Реденькие точки разрыва, наблюдающиеся при максимальной децимации и малой 
					длине окна<BR>
					- Правильный учет совпадения первой точки новой получки с последней предыдущей 
					в IIR-фильтрах</FONT></STRONG></P>
		<P>---------------------------------------------------------------------------------</P>
		<P>050417 вс (дома)</P>
		<P>- Источником точек разрыва может быть как заливка прямоугольника рисования: его 
			"нулевая" точка может совпадать с последней точкой предыдущего (ДОЛЖНА - НО 
			МОЖЕТ И НЕ СОВПАДАТЬ????). Я соотв. поправку вводил - но что-то мне не 
			понравилось. Попробую еще раз (CActDView::Draw, пометка 050417)</P>
		<P>- 18:36 - для всех случаев, кроме m_bChange == true, цикл реферирования и 
			IIR-фильтрации начинаю не с нулевой, а с первой точки!!!</P>
		<P>20:20 К вопросу о "взбрыках" - от них избавлялся в период между 22 и 23-25 
			Октября 2004 года. Попробую сравнить две "крайние" версии в VSS.<BR>
			20:22 Посмотрел. Единственные изменения между 22 октября и 29 января (следующий 
			домашний чекин) - заполнение коэффициентов по флагу m_bChange и перенос 
			вычисления нуля с предшествующей на следующую за IIR-Фильтрацией позицию. А где 
			у меня сейчас? Да вроде бы так же... Фильтруется в Plot(), а ноль берется уже в 
			Draw()... Нда....
			<BR>
			21:08<BR>
			Разве что в перечень условий обнуления не был включен флаг m_bChange. 
			Включил...</P>
		<P>-------------------------------------------------------------------------------------------</P>
		<P>050418 пн</P>
		<P>11:47 (все-таки полтора часа провел на фотосайте)<BR>
			Первые пробы домашних изменений: не-стирание нулевой колонки похоже что 
			отрабатывает правильно. А вот с учетом нулевой точки при IIR-филтрации что-то 
			не то: без HighPass еще рисует нормально, а вот после HighPass нулевая точка 
			получается совсем не там....</P>
		<P>13:13<BR>
			Все еще разбираюсь с нулевой точкой (в режиме постоянных отвлечений на 
			финансовые вопросы). Получается, что просто пропускать мне нельзя (ведь новое 
			значение уже положено!). Нельзя только сдвигать в "старые значения"....</P>
		<P>14:00<BR>
			"Лишние палки и точки" объяснялись просто: в "зачищаемом" прямоугольнике нужно 
			и правую границу увеличивать на 1... В общем, сейчас все работает, на глаз 
			нехорошестей не видно (а так как фильтры только для глаз и предназначены - то и 
			пусть его). Возвращаюсь к начатым по дороге на работу раздумьям о судьбе 
			биполяров - и о "переходной таблице" вообще....</P>
		<P>-------------------------- чекин -------</P>
		<P>Итак, биполяры и проч.<BR>
			-Во-первых, мне хочется, чтобы на выходе ф-ии Plot() формировался уже 
			гомогенный массив отображаемых каналов - без разницы, моно- или же биполярные 
			они.<BR>
			-Во-вторых, "Дословный перебор" имеющихся биопляров кажется процедурой слишком 
			дорогостоящей: тем более, что осуществлять ее придеся для КАЖДОЙ точки КАЖДОГО 
			из вводимых каналов<BR>
			-В-третьих, биполяры усложняют ситуацию значительно: получается, что каждый из 
			вводимых каналов может не только быть/не референтным и монополярно отображаемым 
			- но и являться членом любого количества биполяров!</P>
		<P>Напрашивающийся выход - иметь "сводную карту". Проще всего сделать ее (как и 
			прочие карты) - по ВСЕМ каналам, из каждого вводимого получать его номер, и уже 
			по нему определять флаги:<BR>
			- референтности<BR>
			- монополярности (с номером канала-вывода) - флагом может быть номер (начиная с 
			единицы)<BR>
			- биполярности (с номером канала-вывода и знаком) - флагом может быть номер 
			(начиная с единицы), отрицательный для вычитаемого. Но вот этих-то флагов может 
			оказаться много!!!!</P>
		<P>Пытаюсь придумать альтернативу. В общем случае у меня, скорее всего, может 
			оказаться МНОГО ВВОДИМЫХ каналов - и МАЛО ОТОБРАЖАЕМЫХ. Тогда и цикл можно было 
			бы попытаться построить ПО ОТОБРАЖАЕМЫМ (считая таковыми и референты). Но, 
			опять же, при этом один вводимый канал в списке может встретиться несколько 
			раз....</P>
		<P>Наверное, можно не бояться статической карты (основные карты у меня именно 
			такие). Но! Сейчас у меня установлен размер 32*9 = 288 каналов. Хватит ли этого 
			для всех будущих применений????</P>
		<P>Карту эту можно строить по сообщению (OnMapChanged, вроде бы). Можно и каждый 
			раз - но зачем?</P>
		<P>14:56<BR>
			<STRONG><FONT style="BACKGROUND-COLOR: #ffff33" color="#ff0066">#define TOTCHANS 32*10 
					!!!!</FONT></STRONG></P>
		<P>16:13<BR>
			Первый после массовых изменений (совсем другая карта!) тест - без биполяров 
			живет и работает!</P>
		<P>16:38<BR>
			Удаляю биполярный буфер (m_pBpBuf). Соответственно, под m_pChanBuf выделяется 
			память на все выводимые каналы (включая биполяры).</P>
		<P>19:24<BR>
			уФ, и это побороли... Сначала неправильно обнулял буфер - и лишь под занавес 
			понял, что у меня биполярный цикл оказался вне цикла по точкам... Сейчас 
			нормально отображает и те, и другие каналы - и допускает добавление/удаление.</P>
		<P>Следующие планы:<BR>
			<FONT color="#990000"><FONT color="#000099">- отображение при отсутствии монополяров и 
					каналов вообще, при отсутствии всего<BR>
					- поведение при открытии нового окна во время ввода<BR>
				</FONT>- обработка каналов с разной децимацией.</FONT></P>
		<P>-------------- чекин 
			--------------------------------------------------------------------------</P>
		<P>19:41<BR>
			Сейчас отлетает при попытке отрисовки окна без аналоговых каналов - и даже с 
			одними биполярами</P>
		<P>19:49<BR>
			Слишком рано выходил из фии SetBuffers - не успевал назначить длины. Но и 
			пытаться выделять буфера нулевой длины тоже нельзя!!! Сейчас работает с одними 
			биполярами (без моно) - но только если предварительно был включен-выключен хотя 
			бы один моно....</P>
		<P>20:17 Наверное, на радостях от 30го река за "ополовника" :)<BR>
			ПонЯл: дело было в диалоге, именно в нём неинициализировались переменные. 
			Поставил вызов CorrectMap() в конец OnInitDialog(). Теперь пустое окно 
			рисуется. Более того, открытие нового окна во время ввода не приводит к вылету 
			- все проходит нормально.</P>
		<P>20:24<BR>
			- при добавлении нового биполярного канала включаю биполяры</P>
		<P>21:26<BR>
			Покамест сделал децимацию триггерного канала. <FONT color="#ff0066">Есть таки 
				затыки при полусекундном окне :(((<BR>
			</FONT>Устал - пора к дому....</P>
		<P>---------------------------------------------------------------------------------------------------------------</P>
		<P>050419 вт</P>
		<P>Разибираюсь с разноразмерными каналами (попытка организовать недецимированный 
			триггер). Заведена переменная _ChanW::m_nNew - раздельный счетчик новых данных 
			по каналу. Вид теперь тоже берет счетчики прямо из соотв. канала 
			(предполагается, что буфер начинается с аналоговых каналов, триггерный идет на 
			последнем месте). Соответственно, и счетчик максимумов у тригканала свой. В 
			таком режиме работает без вылетов - но и явно не так :) Помимо "счетчика новых" 
			я должен из каждого канала вычерпывать и его длину...</P>
		<P>15:05<BR>
			Для обеспечения недецемированного триггера пришлось ввести полный второй 
			комлект счетчиков (в виде). Похоже, что работает - хотя можно ожидать всяких 
			подвохов из-за возможного несовпадения "границ окна".</P>
		<P>15:24<BR>
			Введена кнопка "децимация триггера". Как бы проверить, работает она или нет???</P>
		<P>16:13<BR>
			Кнопка не работала (главное окно не считвыало ее показания). Когда же стала 
			работать, выяснилось: при децимации триггера теперь все рушится...</P>
		<P>16:16<BR>
			Исправлено поведение OnRunGo() в отсутствие включенных каналов (ранее не 
			вызывала Stop())</P>
		<P>17:21<BR>
			Теперь обработчик CHardDlg::OnBnClickedTrigdec посылает сообщение 
			m_pMainFrm-&gt;PostMessage(WM_DIZ_MAPCHANGED,0,0); - и перераспределение 
			буферов происходит в правильном месте, наблюдаются все признаки переключения и 
			работоспособности. Отлеты регистрировались - но не каждый раз (надо 
			разбираться). И даже окно с одним только триггером отображается.... Один минус: 
			во всех режимах с децимацией (как с децимацией трига, так и без оной) 
			появляюстя глюки отображения тригканала (мусор в конце.) Хотя я не уверен - они 
			могут быть и на аналоговых каналах....</P>
		<P>17:40<BR>
			В CDialogView заведен checkbox для инвертирования триггера</P>
		<P>19:50<BR>
			Первые хардовые тесты. Первые баги:<BR>
			<FONT color="#ff0066"><STRONG><FONT color="#000099">- промашки на границе децимации<BR>
					</FONT><FONT color="#000099">- ошибка при масштабировании раз в 10<BR>
					</FONT></STRONG></FONT>Думать....</P>
		<P>20:19<BR>
			Проверил масштаб в ActiView - совпадает с моим. Сдается мне, Слава ошибся раз в 
			10...</P>
		<P>20:31<BR>
			Промашки на границе децимации: "запоминать" я должен уменьшенный на 1 
			децимационный счетчик. Но это помогает только когда включена децимация 
			триггера... Правильно: если децимация триггера выключена, я после перебора 
			каналов (а триггер идет последним) получаю старое значение - вот мне ничто и не 
			помогает... Как же сделать????</P>
		<P>21:00<BR>
			Применена довольно сложная схема запоминания (алгоритмом это не назовешь): если 
			канал подвергся децимации, его итоговые значения (децимационный счетчик и 
			позиция в буфере) сохраняются в отдельных переменных. После прохождения всех 
			каналов смотрим, являются ли эти переменные валидными (не -1) - и если да, 
			присваиваем...</P>
		<P><STRONG><FONT color="#000099">На самом деле и в случае с не-децимацией тригканала (да и 
					в случае с децимацией - тоже) я должен учесть факт сдвига!!!!</FONT></STRONG></P>
		<P><STRONG><FONT color="#ff0066">Мусор в конце тригканала так таки и появляется.... Вроде 
					бы - только при децимации</FONT></STRONG></P>
		<P><STRONG><FONT color="#ff0066">И при скролле на границе окон нехорошо...</FONT></STRONG></P>
		<P>----------------------------------------------------------------------------------------------------------------------------------------------</P>
		<P>050420 ср<BR>
			Вчераший вечер принес пусть и пустую - но неприятность: вылетел фотосайт. В 
			итоге он откатился на 13 апреля - пропал "Ополовник" со всеми реками и 
			комментариями - ну и бОльшая часть таковых к "Тупику". Обидно - и по старой все 
			же набралось что-то, ну а последняя просто стала моим "рекордсменом", втрой раз 
			по ней 37 реков я уже не наберу.... Да и выкладывать сейчас смысла нет - сайт 
			еще несколько дней будет переполнен. Ладно, переживем...</P>
		<P>После гибернации не запустилась джина. Может быть, еще и из-за того, что 
			замораживался, даже не остановив куловский вывод. Пришлось перезапуститься. 
			Теперь работает - попробуем подумать...</P>
		<P>Потом меня ждал еще один глюк: пошел совсем не тот выход с джины. А после 
			перезапуска и вообще отказалась работать. Конечно! Снова выскочила из разъема 
			плата. Подкусил зажим - надеюсь, будет держать.</P>
		<P>Лишь часам к трем понял: глючу я не при отображении - я недорисовываю! Это 
			отчетливо видно и на осц-картинках: между последней и первой точками есть 
			разрыв. Еще хитрее при "обнулении": первая-то точка получается необнуленной. 
			Надо вылизывать...</P>
		<P>18:17<BR>
			Еще подумал, посмотрел, посчитал - и убрал во всех рисовательных функциях 
			m_nWinW+1. Оказалось, что теперь рисуется правильно - и даже при скролле с 
			недецмированным триггером мусор не появляется... Сейчас покумекаю еще.</P>
		<P>18:40<BR>
			При децимации триггера мусор появляется (и скролл - и осц). Без децимации вроде 
			бы нет в осц - но есть в скролл. При скролле одна точка таки пропадает - и нет 
			соотв. секундной линии...</P>
		<P>19:00<BR>
			Секундную линию нашел: счетчик нужно было инициализировать не нулем, а готовой 
			секундной (тогда рисуется в нулевой поизиции). Пропажа точки в конце/начале 
			(при скролле) сохраняется. Мусор сохраняется....</P>
		<P>19:20<BR>
			Попытки бороться с отс. точкой: создаю битмэп на 1 точку шире. Точки все равно 
			нет - и пропадают секундные линии :(</P>
		<P>&nbsp;</P>
		<P>-----------------------------------------------------------------------------</P>
		<P>050421 чт</P>
		<P>Так вчера весь вечер - и сегодня с утра искал пропавшую точку. Основной вопрос - 
			где же она находится: в рисовании или в отображении. И каким образом это можно 
			вычислить??? Создал бездну тестовых конфигураций, с отрисовкой начальных и 
			конечных точек и участков ломаных линий, с трейсингом... Полной ясности нет - 
			но кажется, что дело скорее в отрисовке. Причем не отирсовывается (вроде бы) 
			именно начальная, первая точка нового окна....</P>
		<P>так весь день и вечер точки и искал....</P>
		<P>---------------------------------------------------------------------------------------</P>
		<P>050422 пт</P>
		<P>Нет, нет и еще раз нет! Нужно еще и еще раз думать - как я отсчеты и точки 
			считаю... Увы, здесь не получится - надо на бумаге...</P>
		<P>18:51<BR>
			После очередных размышлений понял: никаких единиц ни добавлять, ни вычитать - 
			не надо! Единственное, что нужно учитывать - это при рисовании, выходящем за 
			пределы окна таки брать выходящую точку. А откатываться потом на минус единицу! 
			Но там ведь и по пикселям тоже откат нужен "в минус"....</P>
		<P>Но триггерные проблемы остаются - хотя иногда и кажется, что их совсем нет...</P>
		<P>20:52<BR>
			Но оказалось, что проблема точки тоже остается.... Стал смотреть еще 
			внимательнее: оказалось, что дело - в неправильной инициализации стартовых 
			параметров ф-ии Plot() (min, max. d). И в самом деле, они были расчитаны на 
			обеспечение непрерывности рисования - но сейчас-то я эту непрерывность 
			обеспечиваю "извне" (дублируя конечную и начальную точки). Получается, что мне 
			и массивы не нужны - обхожусь локальными переменными... Теперь вроде рисует 
			:))) Наконец :)))</P>
		<P>Но вот что делать с триггером.... И довольно-таки частыми отлетами :((((</P>
		<P>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<BR>
			По дороге домой пытался сообразить: что же это получается, я сам наехал одной 
			своей "идеей" на другую? Ведь разрыв произошел из-за того, что и в Draw() 
			предыдущая точка запоминалась - а сейчас я её же стал дублировать ещё и в 
			"основной цифири"... Но не всё так просто: сейчас я обеспечиваю любую 
			некратность точек и отсчетов, IIR-фильтрацию... В общем, пусть остается...</P>
		<P>--------------------------------------------------------------------------------------------------------------------------</P>
		<P>050423 сб<BR>
			Утром получил птичьи определители - вот смотрел/слушал их, по ФС ползал... Аж 
			до двух часов. Сейчас пытаюсь вернуться к "работе". Основное - разобраться, что 
			же происходит с тирггерным каналом при децимации.</P>
		<P>14:45<BR>
			Первое, что выяснилось после включения трейсинга перехода рисования - 
			рассогласование счетчиков: "основной" я увеличивал на единицу, а триггреный - 
			нет. Это неприятно и в недецимированном варианте, а при децимации моглостать 
			совсем...
		</P>
		<P>17:00<BR>
			Поправка оказалась ключевой. После ее введения в режиме децимации (и децимации 
			триггера) программа отпахала больше часа - без каких-либо сбоев или перекосов</P>
		<P>Точнее, два неприятных момента есть:<BR>
			<FONT color="#ff0066"><STRONG><FONT color="#ffff33">- изредка точки тригканала дублируются</FONT>
					<BR>
					<FONT color="#000099">- какая-то полная лажа с первой точкой вводимого буфера - 
						причем сказывается уже на этапе децимации!!!<BR>
					</FONT></STRONG></FONT>И еще про один момент не забывать:<BR>
			<STRONG><FONT color="#000099">- во всех случаях децимации тригканал нужно сдвигать на 
					половину ширины фильтра!</FONT></STRONG></P>
		<P>Думаем дальше...</P>
		<P>Единственное, чего добился - понял проблему первой точки: это сами усилители 
			генерировали мощный выброс - причем с той же частотой 2 Гц....</P>
		<P>-------------------------------------------------------------------------------------------------------------</P>
		<P>050425 пн</P>
		<P>14:26<BR>
			Первый сигнал собрал - и первые тесты провел. Теперь бы сообразить, как должен 
			выглядеть желаемый сигнал.... Ведь нужно и биты хорошо представить, и временную 
			точность соблюсти.....</P>
		<P>практически весь день ушел на построение в куле тестового триг-сигнала. Надо 
			было получить отдельные биты - а для этого потребен дополнительный код (соотв. 
			- отрицание и убирание единицы). В итоге сейчас (19:33) построено, и работает - 
			но вот только я не понял: получается, что у меня при децимации сдвиг идет не в 
			ту сторону???</P>
		<P>20:44<BR>
			Да.... Ошибок тут хватало<BR>
			<FONT color="#000099">-</FONT><STRONG><FONT color="#000099"> Во-первых, совсем неверно 
					решена не-децимация триггера (я вообще проскакиваю нужную ветку). Не сделано - 
					еще нужно думать<BR>
				</FONT><FONT color="#000099">- Во-вторых, и при децимации сдвиг на децимированные 
					отсчеты применялся два раза<BR>
					- в третьих, если итоговый коэффициент оказывался за пределами буфера, он 
					корректировался ВНУТРИ цикла - тем самым вызывая его прерывание<BR>
					- в-четвертых, под "триггерным" понимался канал 0 - в то время, как им является 
					канал 1</FONT></STRONG></P>
		<P>На настоящий момент решена задача синхронизации с децимированным триггером. 
			Беремся за недецимированный.</P>
		<P>21:03<BR>
			<STRONG><FONT color="#ff0066"><FONT color="#000099">- сейчас при недецимированном триггере 
						ввод вообще не идет<BR>
					</FONT></FONT><FONT color="#000099">- попытка запуска без децимации после ввода 
					с децимацией - однозначный вылет!!!</FONT></STRONG></P>
		<P>21:47<BR>
			- Во-первых, никакого отображения не было по причине nD == 0. <STRONG><FONT color="#ff0066">
					А вот зачем вообще эта переменная ???<BR>
				</FONT></STRONG>- Во-вторых, я просто еще и забывал положить 
			недецимированное триг-значение в выходной буфер</P>
		<P>Кроме последнего вопроса все решено. Моем электроды - и домой.</P>
		<P>----------------------------------------------------------------------------------------------</P>
		<P><STRONG>050426 вт<BR>
			</STRONG>(<EM>на работу пришел в час - утром шлялся по лесу. Ни одного кадра, но 
				столько слышал</EM>...)</P>
		<P>13:55<BR>
			Практически точный путь к вылету: запуск с децимацией триггера, после этого - 
			выключение децимации вообще. Видимо, путаюсь с логикой флагов. И почему-то 
			разрешается окошко разрешения децимации триггера....</P>
		<P>14:25<BR>
			Изменена логика разрешения чекбокса (пришлось - с проверкой на существование 
			окна)<BR>
			Подправлена логика возвращаемого значения CHardDlg::GetDeciamate() - не 
			помогает :(</P>
		<P>...Я предполагал, что дело - в неправильной интерпретации флагов. Но нет - флаги 
			(сейчас - уж точно) расставляюстя правильно. Однако я явно пихаю мимо какого-то 
			буфера :((((</P>
		<P>15:37<BR>
			У меня при изменении децимации не вызывалась ф-ия пересчета буферов. (заложена 
			в изменение родительской карты). Но вызывалась при включении/выключении 
			децимации триггера. Соответственно, после включения децимации, включения 
			децимации триггера и выключения децимации я оказывался с последним (маленьким) 
			буфером. Вот и результат....</P>
		<P><FONT color="#ff0066"><STRONG><FONT color="#000099">- кнопка Decimate Trigger мигает (не 
						нужно разрешать в Enable Controls)<BR>
					</FONT><FONT color="#000099">- после выключения канала в родительской карте в 
						дочерних он исчезает - но остается распознаваемым в отображении....</FONT></STRONG></FONT></P>
		<P>15:58<BR>
			Бороться нужно не со следствиями (миганием кнопки), а с причиной - частыми 
			вызовами SetMode(). А происходят они оттого, что в сравнении участвует ПОЛНОЕ 
			статусное слово - включающее в себя признак начала и триггер. Нужно применять 
			маску!!!</P>
		<P>16:25<BR>
			Применены маски, изолирующие скорости и батарейно-CMS-ный статус. Итоги 
			сдвинуты. Алгоритм расчета режима изменен.</P>
		<P>16:48<BR>
			В CHardDlg заведены индикаторы BAT и CMS, соотв. ф-ия выставления цветов 
			(OnCtlColorStatic)</P>
		<P>17:21<BR>
			После некоторых мытарств индикаторы работают, как задумано</P>
		<P>17:30<BR>
			Отправляю сообщения об изменении главной карты - только не видам, а диалогам!!! 
			Так - проходит.</P>
		<P>18:14<BR>
			Программа отработала 45 минут - без сбоев и нарушений. Намечаем, что дальше<BR>
			<STRONG><FONT color="#990000">TODO:<BR>
					<FONT color="#006600">- создание нового окна в процессе ввода</FONT><BR>
					<FONT color="#000099">- сохранение параметров окон<BR>
					</FONT><FONT color="#000099">- сохранение параметров программы<BR>
					</FONT><FONT color="#000099">- правильное отображение Ext-электродов</FONT><BR>
					<FONT color="#000099">- правильный отзвон кол-ва модулей в главной карте<BR>
					</FONT></FONT><FONT color="#000099">- изменение длины окна на едит-бокс со 
					спинкотролом (от 1 секунды)</FONT></STRONG></P>
		<P>CheckIn
			<BR>
			-----------------------------------------------------<BR>
			18:35<BR>
			Вроде бы новые окна создаются и начинают работать без проблем????</P>
		<P>18:44<BR>
			Модули отзваниваются правильно. <FONT color="#ff0066"><STRONG><FONT color="#000099">Нужно 
						правильно разрешать чекбокс екстов</FONT>.</STRONG></FONT></P>
		<P>18:50<BR>
			Откорректировано отклчюение боксо екстов.</P>
		<P>20:00<BR>
			Установлено: главную карту перекашивает после посылки главному окну сообщения 
			WM_DIZ_MAPCHANGED</P>
		<P>20:07<BR>
			Сбой происходит после добавления к списку триггерного канала</P>
		<P>20:10<BR>
			Это происходило из-за попытки "поправить" смещение триггерного канала....</P>
		<P>20:15<BR>
			Можно сказать, что с кол-м модулей разобрались возвращаемся к вопросу об 
			екстах.</P>
		<P>20:42<BR>
			Откорректированы оффсеты тачпруфов.</P>
		<P>21:20<BR>
			Такое впечателение, что мэпирование - поборол....<BR>
			<FONT color="#ff0066"><STRONG><FONT color="#000099">Вылет после смены режима!!!!<BR>
					</FONT><FONT color="#000099">- сохранение параметров окон<BR>
					</FONT><FONT color="#000099">- сохранение параметров программы<BR>
					</FONT><FONT color="#000099">- изменение длины окна на едит-бокс со спинкотролом 
						(от 1 секунды)</FONT></STRONG></FONT></STRONG></FONT></P>
		<P>---------------------- чекин - домой --------------------------------</P>
		<P>---------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050427 ср<BR>
			</STRONG><EM>Еще одна прогулка по лесу - на сей раз кого-то "настрелял" - желтая 
				трясогузка, большой пестрый дятел....</EM></P>
		<P>14:30 - 16:30<BR>
			Отслеживал, что происходит. При смене режима из CHardDlg посылается сообщение 
			WM_DIZ_CHANGEMODE. Сейчас после него делаю и обработку WM_DIZ_MAPCHANGED - все 
			равно не помогает :(((</P>
		<P>16:38<BR>
			Стоило пожаловаться - и догадался: я кол-ва каналов переустанавливал ПОСЛЕ 
			вызова HardDlg.SetMode() - а нужно ДО. Сейчас определение этих переменных 
			включено и в обработку WM_DIZ_CHANGEMODE. Но вопрос возникает: что такое у меня 
			m_nChans и m_nTouch???</P>
		<P>16:45<BR>
			Да, m_nTouch - то, что называется obsolete. Сейчас это - m_nExtChans. А вот 
			m_nChans и m_nPinChans - вещи разные: первая - кол-во реально включенных (с 
			учетом кол-ва модулей) каналов, вторая - максимально возможное для режима 
			кол-во пин-каналов.</P>
		<P>16:50<BR>
			Если сбой произошел во время активного ввода, выводится сообщение об ошибке.</P>
		<P>19:09<BR>
			Переделана длина - теперь просто в целых секундах, без излишеств.<BR>
			<STRONG><FONT color="#000099">Почему-то стал неправильно отражаться статус CMS</FONT></STRONG></P>
		<P>19:30<BR>
			Последняя ошибка исправлена (я по-другому перекосил статусное слово).
		</P>
		<P>Задача: внедрить в диалог три битмэпбаттона (сохранение, чтение и установка 
			параметров)</P>
		<P>20:30<BR>
			Битмэповские кнопки в диалоге заведены.</P>
		<P>21:08<BR>
			При создании диалога в него передается его номер - для деления установок. 
			Изменения в конструкторе.</P>
		<P>21:32<BR>
			Сдеалано запоминание (пока на автомате) основных числовых парметров окон. 
			Встают вопросы:<BR>
			<STRONG><FONT color="#cc0066"><FONT color="#000099">- нумерация окон (особо - в случае 
						удаления: как-то нужно декрементирвоать счетчик???)<BR>
						- запоминание и чтение массивов (карты) и структур (биополяры)<BR>
					</FONT></FONT><FONT style="BACKGROUND-COLOR: #ccffcc" color="#000099">- чтение 
					дефолтов ("нулевое окно")</FONT></STRONG></P>
		<P>--------------- устал - домой ------------------------------</P>
		<P>--------------------------------------------------------------------------------------------------------</P>
		<P>050428 чт<BR>
			Почти два часа просидел на ФС - а всего-то получился 21 коммент... Да, таким 
			способом популярность зарабатывать мне тоже не по силам...</P>
		<P>12:44<BR>
			Решаю вопрос о нумерации окон. В очередной раз - у меня две функции закрытия 
			(вида и диалога). Общее и различия???<BR>
		</P>
		<P>13:15<BR>
			Функции удаления вида и диалога приведены к общему знаменателю.</P>
		<P>13:18<BR>
			Если удаляется последний вид, счетчик уменьшается - и новый созданный получит 
			тот же номер. При удалении диалога из середины списка уменьшения номера не 
			происходит.</P>
		<P>13:25<BR>
			Перенесена домашняя версия ActD.h - с внесенными функциями записи и чтения 
			структур.</P>
		<P>13:45<BR>
			В картах заведены функции, дающие доступ к самой карте (для чтения и записи); в 
			диалоге карты пишутся - читаются. Но! Не вызывается обработка изменения 
			карты!!! - приводит к вылету.</P>
		<P>14:27<BR>
			Все же у меня очень нехорошо с открытием новых окон во время активного ввода. 
			Похоже на то, что сообщения к ним начинают идти до того, как окно окончательно 
			сформируется... Попытки заблокировать - тоже пока неудачи :(</P>
		<P>17:00<BR>
			Дело оказалось в нарушении последовательности. Для правильной обработки 
			изменений в карте должна была пройти доп. инициализация диалога, запускавшаяся 
			уже после его создания. Решение - вынесение загрузки карты в отдельную ф-ию, 
			вызываемую из главного окна уже после прохожения всех инициализаций. В таком 
			виде - работает, даже "на ходу".<BR>
			Добавлено сохранение/восстановление рефкарты.</P>
		<P>18:09<BR>
			Чтобы структуру биполяров можно было записывать, CStringh m_strName&nbsp;&nbsp; 
			изменее на char m_czName[40]</P>
		<P>18:54<BR>
			Поборото сохранение/восстановление биполяров</P>
		<P>19:03<BR>
			Запрет на закрытие единственного вида во время ввода. Для этого в классе вида 
			пришлось сказать, что сообщение обрабатывается (инче все равно закрывался, хотя 
			контроль - в главном окне)</P>
		<P>19:08<BR>
			Запрет на закрытие последнего диалога (здесь - уже без извращений).</P>
		<P>19:10<BR>
			Окошко с сообщением о невозможности закрыть последнее окно</P>
		<P>21:20<BR>
			После долгих мытарств стало точно ясно: путаюсь с массивами диалогов-видов. 
			Обрамил критической секцией - стало легчк</P>
		<P>21:35</P>
		<P>Была одна ошибка: при невозможности удаления вида/диалога я не покидал критич. 
			секцию. А покидать ее надо&nbsp;- причем ДО вызова окошка с сообщением (иначе 
			мы останемся в крит. секции - и вывод затормозиться.). Сейчас работает, как 
			руки ни выкручивал - не убил.<BR>
			-------------------------- 21:37 -------- завершаем - домой 
			--------------------------------</P>
		<P>--------------------------------------------------------------------------------------------------</P>
		<P>050429 пт</P>
		<P>14:42<BR>
			Задание отдельного цвета для фона биполяров.</P>
		<P>14:49<BR>
			Заливка биполяров отдельным цветом</P>
		<P>16:47<BR>
			Бьюсь с сохранением/восстановлением позиций окон. Получаетя, что функцию вида 
			SetPar() использовать нельзя - она сама уже что-то предполагает и сохраняет... 
			Придется дублировать ее функциональность в отдельной функции.</P>
		<P>19:00<BR>
			Поборол сохранение положения окна: почему-то перед <FONT color="#000099">GetWindowRect(&amp;rcW);</FONT>&nbsp; 
			нужно было давать
			<BR>
			<FONT color="#000099">SetParent(0)</FONT>;
		</P>
		<P>21:40<BR>
			Начал делать диалог параметров вида. После его вызова при закрытии программы 
			регулярно получаю ошибки :((( Усё....</P>
		<P>---------------------</P>
		<P>050430 сб</P>
		<P>14:59<BR>
			продолжаю попытки разобраться с замеченными вчера вылетами. Для них не нужно 
			даже открывать диалоги и проч. - отлёты бывают просто при закрытии программы, 
			имеющей хотя бы одно окно. Предположение одно: какие-то сообщения бродят у меня 
			слишком длинными путями :((( Вот и забредают в окна уже после того, как окна 
			этого нет :(((</P>
		<P>17:25<BR>
			Во всех случаях ошибки возникают, когда обработка таймера вызывается уже после 
			того, как была вызвана ф-ия OnClose()... Или же: таймер возникает раньше, 
			OnClose() прерывает его обработку... Тогда надо еще какую-то крит. секцию что 
			ли???</P>
		<P>17:39<BR>
			Завел таковую крит. секцию. Все хорошо - только теперь запуск не проходит :)))</P>
		<P>17:50<BR>
			А, я попросту два раза выходил из секции в OnRunGo()... Сейчас вроде как все 
			исправлено.... А не пойти ли мне???</P>
		<P>--------------------------------------------------------------------------------------<BR>
			<STRONG>050501 вс<BR>
			</STRONG>------------- дома, ночью -------------------------</P>
		<P>01:00<BR>
			При отсутствии драйверов и железа наблюдались дедлоки при выходе - я просто не 
			выходил из таймерной секции (стоял return вместо throw). Исправил, но кажется, 
			что временами дедлоки бывают...</P>
		<P>01:15<BR>
			Восстановлена заливка свежесоздаваемого битмэпа вида (дабы не было пустого 
			окна)</P>
		<P>01:20<BR>
			Коррекция размеров восстанавливаемых окон (чтобы дочерние не выходили за 
			пределы родительского)</P>
		<P>12:49<BR>
			Надо избавляться от рестартов основного таймера - у меня и в рабочем режиме 
			вызовы медленные... Так что будет достаточным стартовать при запуске - и 
			останавливаться при выходе...</P>
		<P>12:50<BR>
			Пожалуй, ближайшую задачу сформулируем - на воспоминание о формировании диалога 
			свойств. Сейчас-то у меня лишь одна - по цветам... А нужны будут общие 
			установки, триггера - и далее, далее, далее...</P>
		<P><STRONG>050502 пн
				<BR>
			</STRONG>снова ночью
		</P>
		<P>00:58<BR>
			Примитивные листочек и страничка созданы. Но! Нужно еще подумать, каким образом 
			передавать установки (в случае диалога это делалось через конструктор)</P>
		<P>01:05<BR>
			Придумал: _Settings у меня все равно глобальная переменная - так что я буду 
			инициализировать наследуемый от нее класс конкретной страницы в дефолтовом 
			конструкторе. Нужно понять, как обходиться с правильным запоминанием при 
			выходе....</P>
		<P>01:18<BR>
			С запоминанием тоже обошелся - но пока есть проблема: вообще нет выхода (в том 
			смысле, что по ОК не выходит). Подумаем утром...</P>
		<P>----------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050503 вт<BR>
			</STRONG>На работе: продолжаю не понимать, почему не происходит выход по кнопке 
			OK....</P>
		<P>12:51<BR>
			Ну бред!!! Выщывающая фунция ожидала булевского значения - и получаемые 
			возвраты интерпретировала прямо наоборот!!! При успехе из Onapply() нужно 
			возвращать 1, при неудаче - 0 !!!</P>
		<P>12:57<BR>
			Класс CSettingsDlg убран из проекта. Осталась только страничка цветов, 
			сделанная на его основе....</P>
		<P>13:02<BR>
			В свойствах разрешена Apply, на странице цветов добавлены вызовы SetModify() - 
			теперь цвета можно менять "совсем на лету".</P>
		<P>13:50<BR>
			Никак не мог считать строку из сохраненной в файле: у меня в классе CSettings 
			функция CStrings зарезервировна для другого - только для получения имени 
			файла... Тогда ее нужно переобозвать!</P>
		<P>13:57<BR>
			Функция переобозвана, заведена новая - возвращающая строку. Работает.</P>
		<P>14:40<BR>
			Исправление ошибки: в главном окне не покидал таймерную критсекцию при 
			отсутствии рабочих каналов.</P>
		<P>14:47<BR>
			С изменением таймера тоже разобрался - анализировал не то состояние 
			(переустанавливать - только при уже работающем таймере!!!)</P>
		<P>15:06<BR>
			Загрузка параметров вида вынесена в отдельную функцию, с параметрами "полная 
			загрузка" и "секция". При инициализации диалога производится неполная загрузка, 
			из функции LoadMap() - полная.</P>
		<P>15:56<BR>
			Вроде бы успешно разбираюсь с сохранением и загрузкой дефолтовых параметров - 
			но обнаружено: при закрытии любого окна ввод ввообще подвисает... Где?????</P>
		<P>16:22<BR>
			Оказалось даже еще хуже: вылеты при повторных запусках. Объяснение простое: 
			флаг m_bRun модифицировался вне таймерной секции (соответственно, таймерная 
			ф-ия получала доступ к нему до инициализации всех нужных переменных). Но с 
			закрытием второго окна все по-прежнему плохо :(((\</P>
		<P>16:46<BR>
			Ага! Дело оказывается в ф-ии вида GetPosition(), которая зачем-то устанавливает 
			SetParent(0) - после этого все и плохеет. А без этого оказываются совсем не те 
			координаты....</P>
		<P>17:11<BR>
			Вроде бы что-то нащупал: парентов переставлять не надо, для чаялдов следует 
			сдвигать не лево-верх родителя с поправкой на край....</P>
		<P>----------------------------------------------------------------------------------------------</P>
		<P>050504 ср</P>
		<P>После того обнаружил неполадки с закрытием окон - то подвиснет, то хрюкнет... 
			Стал разбираться, расставлять крит. секции - начались дедлоки :((( 
			Переставлял&nbsp;так, иначе - ну и соответственно глючило так или иначе. В 
			конце концов просто отрубил запуск главного таймера - чтобы этот поток в дело и 
			не вмешивался. Оказалось, что и оно не помогает!!! То есть даже без 
			вмешательства таймера с закрытием окон все равно беда :((((</P>
		<P>Похоже, что дело в самом алгоритме закрытия-удаления. Получая в виде сообщение 
			WM_CLOSE, я пощу соотв. (свое) сообщение в главное окно, и дальше вся работа 
			ведется уже от его имени (то есть - силами главного потока приложения). И этот 
			же поток удаляет окно - но создано-то оно было своим граф. потоком!!! А в 
			справке явно написано: удалять окно из другого потока нельзя!!! И вообще лучше 
			всего, чтобы удалялось оно само (по завершении потока).... В общем, нужно 
			редезайнить...</P>
		<P>Думал об этом по дороге домой, что-то пробовал дома. Но там картина другая: не 
			исключено, что вмешивается разница между одно- и многопроцессорными машинами 
			(таки здесь есть возможность одновременного выполнения двух потоков).</P>
		<P>Что интересно: "домашняя версия" (от 2 мая) таких проблем с закрытием окна не 
			испытвает - но там полно других проблем: при закрытии второго окошка зависает 
			(и напрочь) ввод, да и программа при закрытии виснет глухо...</P>
		<P>16:15<BR>
			Значится так.
			<BR>
			<STRONG><FONT color="#000099">- При закрытии вида (CActDView::OnClose) ничего не делаем 
					- только отсылаем сообщение главному окну<BR>
					- Главное окно в функции CMainFrame::OnViewClose проверяет наличие данного вида 
					и возможность удаления (запрет на удаление последнего вида) - и вызвает функцию 
					RemoveOsc<BR>
					- функция CMainFrame::RemoveOsc(int idx) удаляет вид и диалог из списков - и 
					удаляет диалог командой
					<BR>
					delete m_arpDialog[idx];<BR>
					- в деструкторе диалога (CDlgView::~CDlgView() )<BR>
					&nbsp; - сохраняются установки<BR>
					&nbsp; - разрушается окно<BR>
					&nbsp; - посылается сообщение граф. потоку на его закрытие
					<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
					::PostThreadMessage((DWORD)m_pThread-&gt;m_idThread,WM_QUIT,0,0 );<BR>
					&nbsp; - ЖДЕМ ЗАВЕРШЕНИЯ ПОТОКА !!!!!!!!!!! (здесь-то и была ошибка!!!)<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
					WaitForSingleObject(m_pThread-&gt;m_hThread,INFINITE);<BR>
					&nbsp; - удаляем поток<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete m_pThread;</FONT></STRONG></P>
		<P>В таком режиме не только не отмечено зависаний и вылетов - но и нет утечек 
			памяти!!!</P>
		<P>16:26<BR>
			Для унификации: диалог при нажатии кноки Close посылает то же сообщение, что и 
			вид!
			<BR>
			Функция OnDlgClose и соотв. дескрипторы команд из главного окна удалены!!!</P>
		<P>16:48<BR>
			Исправлена ошибка в CDlgView::PreTranslateMessage, из-за которой диалог 
			фильтровал все нажатия клавиш. Теперь акселераторы работают всегда</P>
		<P>===================== CheckIn ==========================================</P>
		<P>17:15<BR>
			В диалоге параметров вида - чекбокс SaveOnClose и кнопка SaveNow, их правильное 
			обслуживание (именованные пока трогать не будем)</P>
		<P>17:20<BR>
			В отображении - убраны отладочные точки по краям ломаных<BR>
			<BR>
			На повестке дня:<BR>
			<STRONG><FONT color="#990066"><FONT color="#000099">- диалог отображения триггерного канала 
						(цвета, инверия)<BR>
					</FONT></FONT><FONT color="#000099">- диалог сохранения, чтения параметров инд. 
					окон и программы в целом<BR>
					- диалог параметров ввода (свободный, гейтед, триггеред)</FONT></STRONG></P>
		<P>19:54<BR>
			В основном построен диалог отображения триггерного канала.
		</P>
		<P>20:28<BR>
			Диалог отображения тригканала проинтегрирован с классом CSettings (как 
			дружественный класс, сохранение - вместе с цветами)</P>
		<P>20:38<BR>
			Вид считывает триггерные установки.
		</P>
		<P>20:42<BR>
			Полностью убраны упоминания об "инверсии триггера" - теперь все заменено на 
			маску.</P>
		<P>00:31<BR>
			Попытки запустить дома: во-первых, обнаружена какая-то разница в CViewSettDlg - 
			на флешке нет последней версии. И дома тоже!!! ???</P>
		<P>Во-вторых, релиз-сборка все равно отлетает. По всей видимости, нецензурно 
			формируется SetMode...</P>
		<P>01:09<BR>
			Первая проблема с релизом ликвидирована: при установке в "выключено" в actMode 
			не инициализировалось количество пин-каналов nPinChans!!! Осталась проблема с 
			открытием нового окна...</P>
		<P>01:28<BR>
			Вторая часть проблем лежит где-то в районе загрузки параметров осцокна....</P>
		<P>----------------------------------------------------------------------------</P>
		<P>050505 чт</P>
		<P>11:54<BR>
			Убрана ставшая пустой ф-ия CDlgView::LoadMap()</P>
		<P>12:06<BR>
			Почему-то не перенес из дома изменения в actMode (обунуление пин-каналов). К 
			тому же здесь все равно в релизе отлетало - нужна задержка между USB_WRITE и 
			CLOSE_DRIVER</P>
		<P>12:14<BR>
			Да, вчера я действительно переписал не все файлы. Положил в "нулевую папку". 
			Релиз-сборка работает: возможно, проблемы у меня с домашней конфигурацией, так 
			что нужно проверять проверку загружаемых параметров :)))<BR>
		</P>
		<P>12:39<BR>
			Нет, отлеты все-таки есть - если нет драйверов, вылетаем при открытии нового 
			окна....</P>
		<P>13:44<BR>
			Похоже, что дело обстояло так: бокс с сообщением об отсутствии драйверов я 
			выдавал ДО запуска основоного потока приложения - и в итоге просто не успевал 
			отследить соотв. сообщение в CMainFrame::PreTranslateMessage. После переноса 
			окошка в CMainFrame::OnCreate похоже что все работает.</P>
		<P>14:00<BR>
			Для правильной работы и открытие окна нужно производить после проверки на 
			наилчие драйверов!!!</P>
		<P><BR>
			++++++++++++++++++++ чекин ++++++++++++++++++++++</P>
		<P>14:56 (После известия о принятии статьи в Neuroscience Letters)<BR>
			По итогам размышлений:<BR>
			- никакого открытия окон при запуске программы и соотв. флага не надо, нужна 
			будет отдельная кнопка, "загружающая сессию" (именованную или нет???)<BR>
			- флаг сохранения параметров окон тоже не нужен - пущай себе сохраняют. Если не 
			загружать, то это никому и не помешает<BR>
			Внесены соотв. изменения в диалог, проверена его работоспособность.</P>
		<P>15:20<BR>
			Реализована загрузка параметров окон - дефолтовая или индивидуальная.</P>
		<P>15:40<BR>
			Грузим главную карту</P>
		<P>16:32<BR>
			Загрузка главной карты и основных параметров программы работает. Какие-то глюки 
			с загрузкой биполяров...</P>
		<P>16:52<BR>
			Попутно выяснил что я не сохранял (и не читал) флаг индивидуальной загрузки 
			параметров окон... Исправлено..<BR>
			С биполярами немножко разобрался (при загрузке не восстанавлива "нулевую" 
			строчку) - но не совсем понятно, как быть в случае отключения от ввода 
			назначенного на пару канала....</P>
		<P>18:56<BR>
			Диалог установки значений и цветов для смещений, сохранение этих параметров</P>
		<P>19:25<BR>
			Пределы и смещения учитываются при отрисовке</P>
		<P>+++++++++++++++++ чекин +++++++++++++++++++++++</P>
		<P>20:00<BR>
			Изменена логика открытия: файловые команды помечены как недоделанные, новая 
			кнопка ID_OSC_NEW открывает новый осциллоскоп, запуск разрешен при полном 
			отсутствии окон, в этом случае при запуске открывается новый осциллоскоп.</P>
		<P>20:04 - соотв. команда в меню</P>
		<P>20:14<BR>
			Команда принудительного задочивания и каскадирования всех открытых окон.</P>
		<P>20:20<BR>
			Начато формирование триггерного диалога<BR>
			21:41<BR>
			Триггерный диалог в основе своей нарисован. Теперь нужно еще кое-что подправить 
			- и прописать.... Но - уже дома: пора. Третий чекин<BR>
			+++++++++++++++ чекин +++++++++++++++++++++++</P>
		<P>050506 пт<BR>
			Дома до половины второго ночи переименовывал контролы триггер-диалога - 
			вручную, в фаре. Чтобы было удобнее составлять массивы. Сейчас (уже на работе) 
			кофе попью и займусь - группами и алгоритмами их включения/выключения....</P>
		<P>14:30<BR>
			Диалог по части многочисленных чекбоксов ведет себя нормально. Хотел сделать 
			боксики цветными - но не получается: не посылают они соотв. сообщений. То бишь 
			если хочется, то нужно будет пускаться в OWNERDRAW - но это как-нибудь потом<BR>
			<STRONG><FONT color="#000099">- чтение и сохранение параметров<BR>
					- обрабока едит-контролов<BR>
				</FONT><FONT color="#000099">- запрет страницы во время ввода</FONT></STRONG></P>
		<P>15:17<BR>
			При активном вводе триггерная страница просто удаляется.</P>
		<P>16:54<BR>
			Заокнчено сохранение параметров</P>
		<P>17:28<BR>
			Сделана обработка едит-контролов. Пора пообедать :)))</P>
		<P>20:42<BR>
			Залез в CMapDlg - а там нехорошо... Первичную инициализацию подправил - но вот 
			цвета нормально отображать все равно не получается... Бог с ним.<BR>
			Сделал загрузку имен каналов из биосеми-файла - в CMapDlg</P>
		<P>20:50<BR>
			Загрузка имен каналов из меню.</P>
		<P>21:10<BR>
			Автозагрузка имен каналов из моего конффайла.</P>
		<P>21:41<BR>
			Вывод имен электродов в карте.<BR>
			++++++++++++++++++++++++++++ чекин - домой ++++++++++++++++++++++++++++<BR>
			Дома<BR>
			00:34<BR>
			В диалоге смещений исправлен порядок обхода</P>
		<P>00:44<BR>
			Функция Find() и макрос SIZE перенесены в глобальные - много где нужны</P>
		<P>00:56<BR>
			В диалог смещений добавлена обработка EnKillFocus, доработано поведение в 
			ошибочных ситуациях (возврат к старому значению)</P>
		<P>00:59<BR>
			В обеих версиях чтения списка имен к маскам добавлены все файлы.</P>
		<P>---------------------------------------------------------------------------------------</P>
		<P>050507 сб</P>
		<P>10:50 Перенесены изменения из дома</P>
		<P>11:00<BR>
			Передача адреса имен каналов в карты диалогов</P>
		<P>11:10<BR>
			Передача адреса имен каналов в карты биполярного диалога</P>
		<P>11:25<BR>
			Программа запускается на варягинском компьютере. Нехорошо с дефолтовыми 
			парметрами окна.</P>
		<P>11:38<BR>
			Параметры приведены в какую-то норму....
			<BR>
			--------------- чекин----------------------------------------</P>
		<P>13:12<BR>
			Вывод имен каналов на график</P>
		<P>13:20<BR>
			Ключевой момент!!! ПРоверка на ноутбуке!!! Работает</P>
		<P>13:40<BR>
			Сокартил битмэп на 50 пикселов (имена каналов выводятся отдельно). Коррекция 
			размеров главных диалогов</P>
		<P>14:00<BR>
			Нет, сделаем так: постоянная граница окна (для меток) - 30 пикселов, но в то же 
			время ширина битмэпа - 60; длинные метки будут мигать; заполнение - правильным 
			фоновым цветом.<BR>
			--------------------------- чекин ------------------------</P>
		<P>14:30<BR>
			Исправлена ошибка в заполнении имен биполяров.<BR>
			На ноутубке, при открытии в релизе большого количества осциллов и закрытии 
			прогарммы (без запуска) - вылетели :((((</P>
		<P>------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>17:45<BR>
				Написан документ, программа в его сопровождении послана to Coen Metting 
				VanReign</STRONG></P>
		<P>----------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050511 ср</STRONG></P>
		<P>Выходные прошли в перекопке заболоченного огорода - и в ожидании ответа от 
			Коуэна. Тяжелое это дело - ждать... Было даже отчаялся - но сегодня утром ответ 
			пришел. И хорошо, что сегодня - на возникшие вопросы я бы из дома ответить не 
			смог. Сейчас ответил (похоже, я просто не дал нужных инструкций), поулчил 
			подтверждение - будем ждать, что скажут дальше. Но просто ждать нельзя - нужно 
			продолжать....</P>
		<P>Итак, вопрос с триггером:<BR>
			- Возможно, понадобится сборка битов в слове не только по "OR", но и по "AND" 
			???<BR>
			- Как должна происходить сама обработка заданных тригпараметров???</P>
		<P>Если учесть, что проверяться должно каждое значение триггра, основной задачей 
			становится максимальное упрощение-ускорение этой процедуры - дабы зря время не 
			занимать. Для этого предлагаю: начинать с анализа произошедших изменений:
			<BR>
			- отмечать наличие&nbsp;изменений в тригканале,&nbsp;вставшие и упавшие биты<BR>
			- если изменения обнаружены, анализировать их релевантность: проверять гейтовые 
			условия, а затем - собственно триг.<BR>
			- видимо, и для "свободного" режима нужны "триг-условия" - чтобы можно было 
			запустить/остановить запись посылкой соотв. триг-слова.</P>
		<P>20:12<BR>
			Не слишком бодро, но начал таки развлекаться с битами триггера (NB! У них 
			все-таки единица - вверху, то есть разомкнута!!!) - но прервался, решив 
			добавить контрол для редактирования "спецсимволов". И вот тут-то и завис - не 
			доходят до диалога никакие PreTranslateMessage :(((</P>
		<P>Правда, попутно подправил поведение по Return и KillFocus в CAcqTrigDlg - теперь 
			в случае неудач возвращают предыдущее значение.</P>
		<P>Разобрался лишь сейчас - путем ПРАВИЛЬНОГО наследования собственного класса 
			контрола и подключением его в карту через DDX_CONTROL....</P>
		<P>20:22<BR>
			Да нет, DDX необязательно - достаточно subclass....</P>
		<P>21Ж25<BR>
			Поведение вынесенного в отдельный класс контрола вроде бы доведено почти до 
			ума: только вот продолжает брякать по сискеям - и западают шифты-контролы при 
			переходе на другое окно (нужно очищать при активищации)</P>
		<P>---------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050512 чт</STRONG></P>
		<P>13:06<BR>
			Таки возможность претранслировать системные сообщения (чтобы точно 
			зафиксировать клавиши) мне не давала покоя. Долго копался по и-нету, пока не 
			нашел в явном виде высказывания о возможность фильтров только для немодальных 
			диалогов. Сделал свои свойства немодальными (похоже, что в WTL на тему ошибки - 
			методы класса пришлось переписать.) - указатель, как член класса CMainFrame, 
			лист создается по первому запросу и существует все время - лишь скрывается по 
			командам закрытия. Разумеется, нужно о многом не забывать (уничтожать при 
			закрытии главного окна; фильтр удалять тоже только если родительский цикл еще 
			есть (его может и не быть) - и проч. проч...)</P>
		<P>Пока оставлю так (включая спецконтрол) - но далее все клавиши нужно будет 
			вынести на отдельную страницу свойств - и пусть редактируют....</P>
		<P>13:30<BR>
			Дополнительные телодвижения все по поводу тех же свойств: восстановление 
			активной страницы свойств и снятие с нее флага модификации. (почему-то это 
			оказалось нужным)</P>
		<P>13:35<BR>
			Видимо, мне еще придется предпринимать определенные усилия, чтобы системные 
			клавиши хучились лишь тогда, когда активна (и видима) соотв. страница.</P>
		<P>13:50<BR>
			Думаем на тему, что в каких ситуациях делать с тригканалом<BR>
			- Free acquisition - наверное, здесь все-таки нужно будет два триггерных слова: 
			для запуска записи - и для ее окончания. Тогда проверяем эти слова??? Наверное, 
			там нужен будет еще и "паузный гейт"<BR>
			- Gated - проверяем состояния гейтов (начиная снизу, при наличии соотв. And)<BR>
			- Triggered - проверяем наличие гейтов, потом - триггер....</P>
		<P>Результатом проверки должен являться некий флаг, доступ к которому будет 
			возможен не только из блока проверки триггера - но и из команд меню (шоткатов)</P>
		<P>Для такого поведения понадобится соотв. модификация диалога. Чтобы не рисовать 
			много чего лишнего, лучше будет "переобозвать" соотв. переменные - и 
			перенаправлять результаты в другие переменные...</P>
		<P>Таким образом, единственным "выключаемым" в диалоге становится Триггер в режиме 
			1 (Gated). Кроме того, в "свободном" режиме выклчюается And0 - а также меняются 
			тексты.</P>
		<P>14:37<BR>
			Продолжаю перерисовывать диалог. Нет, даже так: в свободном режиме всегда 
			разрешены три группы - два триггера и "Gate condtition" (бывшая And1)</P>
		<P>14:52<BR>
			Поведение диалога вроде бы сделал. Эх, только представить себе, как мне это 
			придется описывать... Да еще по-аглицки.... Теперь не худо было бы "развести" 
			переменные.... Для этого "непосредственные операции" должны осуществляться не с 
			самими массивами - а с их адресами...</P>
		<P>15:46 CAcqTrigDlg<BR>
			Адреса массивов заведены и обрабатываются. Нужно их переключать при 
			переключении режимов - и обновлять содержимое соответственно....</P>
		<P>16:03 CAcqTrigDlg<BR>
			Вроде бы переключения сделаны....</P>
		<P>---------------------------------------------------------------------------------------------------<BR>
			<STRONG>050513 пт</STRONG></P>
		<P>В полночь запостил зяблика - ну и как всегда время ушло на отслеживание 
			комментариев :((( И мозги - тоже. Будем вспоминать, на чем остановились:</P>
		<P>Мне нужно отработать переход от логики триггера к логике собственно записи. С 
			учетом того, что на запись оказывает влияние не только триггер - но и разные 
			там нажатые кнопки, команды меню....</P>
		<P>18:00<BR>
			Довольно долго маюсь с двумя ф-ми - подготавливающей и отслеживающей. Запутался 
			с итерацией (получилось [2-1] вместо [2-i]), в ходе экспериментов понял, что 
			выставлять "сверхстарший байт" мне нужно только в том случае, когда ОБА слова 
			(верхнее и нижнее) нулевые - и тогда можно это делать лишь в одном слове...</P>
		<P>Сейчас нужно придумать, каким образом в случае чистых гейтов возвращать ноль, 
			если сами гейт-условия не изменились....</P>
		<P>18:31<BR>
			Нет, лучше будет разделить "хардовые" и "логические" дела. Хотя.... А не 
			построить ли мне общую карту валидных битов????</P>
		<P>18:39<BR>
			Да, с маской все выглядит логичнее<BR>
			Меня смутило отсутствие сообщения о включении гейта в тригрежиме - но его вроде 
			и не должно быть? Ведь в этом случае гейт только регулирует видимость 
			стартового триггера??</P>
		<P>Ну а что тогда для старт-стопа? Угу, в старт-стопе конец гейта должен означать 
			то же, что и стоптриггер....</P>
		<P>19:27<BR>
			Нет, но тогда...<BR>
			Если отсутствие гейта означает то же, что пауза записи, то оно не должно 
			препятствовать распознаванию триггера. То есть может возникнуть ситуация, когда 
			изменяются одновременно оба параметра.... Но тогда и возвращать нужно нечто 
			более сложное :(</P>
		<P>21:22<BR>
			Очистка ненужных битов и сравнение со старым триггером вынесены за вызов ф-ии - 
			незачем лишнюю работу на каждом слове делать!</P>
		<P>------------------------------------------------------------------------------------</P>
		<P><STRONG>050514 сб</STRONG></P>
		<P>По дороге домой продумал еще раз: нет, полностью дублировать "гейт-паузу" и 
			запись в файл - нехорошо. Удобнее - переключиться в тестовый режим (с запретом 
			записи), и в нем иметь возможность еще раз посмотреть, как триггера-гейты 
			работают.</P>
		<P>В этом случае - нужна ли в тригрежимах информация о включении гейта? Для самой 
			функциональности - вроде бы нет (если триггер пришел - значит гейт включился). 
			Но для отображения соотв. кнопки - хорошо бы ее иметь. То есть если и гейт 
			включился, и триггер пришел - ничего лишнего не надо (наружный модуль и сам 
			сможет догадаться, что гейт включен - иначе и триггера бы не было). А вот если 
			просто включился гейт?&nbsp; А если он уже был включен и остался включенным? 
			Похоже, что мне остается только один вариант: в обоих случаях возвращать сигнал 
			включения гейта - а там уж пусть вызывающий модуль разибирается, имело ли место 
			изменение состояния. Тем более, что оно все равно зависит не только от 
			тригхарда - но и от софтовых кнопок.</P>
		<P>15:23<BR>
			Завел массив (CSimpleArray), в который будут складываться результаты обработки. 
			Но ведь нет! Я должен помещать в него не адрес входного буфера (он для 
			дальнейшей работы абсолютно безразличен) - а точку выходных буферов. Причем - с 
			возможной коррекцией для случая фильтрации-децимации...</P>
		<P>--------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050516 пн</STRONG></P>
		<P>Итак, вне зависимости от того, буду ли я обрабатывать тригканал (с точки зрения 
			поиска триггера) перым или последним, в этот момент я буду иметь информацию 
			только о нем. Можно, конечно, обработать его сначала, поскладывать смещения 
			входного буфера - но тогда придется их очень много раз проверять... Слишком 
			нехорошо.</P>
		<P>Хочу попробовать так:<BR>
			- в момент синхронизации выходного буфера (StoreW()) получать информацию о его 
			текущем положении (эта информация будет разной для каналов с разной децимацией 
			- а в пределе вообще своей для каждого канала; тогда становится более чем 
			резонной обработка тригканала в последнюю очередь). При обработке тригканала, 
			независимо от того, есть ли децимация вообще и децимируется ли тригканал в 
			частности, проходить ВСЕ ветки обработки с наращиванием соотв. счетчиков - и на 
			выходе получать ПАРУ значений (в простом случае децимации/не-децимации,&nbsp; в 
			дальнейшем значений может быть больше) - и плясать уже по ним....</P>
		<P>11:43<BR>
			- перед началом обработки тригканала запоминаем нужное тригслово (а то может 
			быть изменено)<BR>
			- сам вызов для проверки триг-изменений - ПОСЛЕ прохождения прочих проверок 
			(чтобы иметь нужные счетчики)</P>
		<P>12:53<BR>
			Ну, выходной массив тригкоманд я вроде бы сформировал (хотя и не проверял). 
			Какие же у меня есть варианты действий:<BR>
			- nTAns &lt; 0 - преркращение записи: Если запись идет, остановить ее по 
			окончании очередного фрейма. Если записи нет - просто изменить состояние кнопки 
			"пауза"<BR>
			- nTAns&nbsp; = 1<BR>
			&nbsp; - Если запись идет, ничего и не делаем<BR>
			&nbsp; - Если записи нет, и ввод по триггеру - ничего не делаем<BR>
			&nbsp; - Если записи нет, и ввод гейтовый - начинаем запись<BR>
			- nTAns = 2<BR>
			&nbsp; - В состоянии "пауза" - ничего не делаем<BR>
			&nbsp; - Если паузы нет, начинаем очередной ввод по триггеру</P>
		<P>13:08<BR>
			Заведена кнопка "пауза" и ее обработка</P>
		<P>13;17<BR>
			Обработка кнопки "пауза" по значениям тригканала</P>
		<P>13:57<BR>
			Все же за счет двойственности управления у меня появляется неоднозначность: 
			если пауза в тригрежиме была включена кнопкой, триггер все равно будет 
			приходить - и я никак не узнаю, был ли включен гейт или нет... То есть у меня 
			появляется единственный (!!!???!!!) случай двойного возврата - одновременный 
			триггер и включение гейта. Но тогда я могу и завести еще одно - двойное - 
			значение! Попробуем...</P>
		<P>14:24<BR>
			Вроде бы так: завел доп. проверку на ВКЛЮЧЕНИЕ гейтов - и оно добавляется к 
			возвращенному триггеру. Тогда при одновременном включении триггера и гейтов я 
			получаю значение 3 - и выключаю паузу. Любопытное дополнение: в этом случае 
			включение "еще одного гейтсигнала" (ежели их больше одного) приведет к 
			включению гейта!!! - то есть пересилит вручную включенную паузу.</P>
		<P>14:38<BR>
			Вроде бы так - но мне пока сложно сказать, насколько оно работает: нужны 
			гораздо более хитрые тесты (без неизбженого дребезга от используемого сейчас 
			гвоздя - придется еще писать программку, которая бы напрямую на джине нужные 
			биты дергала....)</P>
		<P>14:53<BR>
			Каковы же варианты собственно записи?<BR>
			- Гейтрежим<BR>
			&nbsp; - записи нет<BR>
			&nbsp;&nbsp;&nbsp; - гейт влкючился - начинаем<BR>
			&nbsp;&nbsp;&nbsp; - гейт выключился - ничего<BR>
			&nbsp; - запись есть<BR>
			&nbsp;&nbsp;&nbsp; - гейт включился - ничего<BR>
			&nbsp;&nbsp;&nbsp; - гейт выключился - заканчиваем<BR>
			- Тригрежим<BR>
			&nbsp;&nbsp;&nbsp; - независимо от того, есть запись или нет, анализирую 
			разницу во времени от предыдущего триггера и,
			<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; если она удовлетворяет&nbsp;&nbsp;&nbsp; 
			условиям, начинаю новую запись. Выключение гейта влияет только на распознавание
			<BR>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; очередного триггера<BR>
			- свободный режим<BR>
			&nbsp;&nbsp; ????????</P>
		<P>Получается, что мне нужно три независимых флага:<BR>
			- m_bRecording<BR>
			- m_bNeedStart;<BR>
			- m_bNeedStop;</P>
		<P>Что из себя представляет собственно запись? Получив команду m_bNeedStart, 
			начинаем с указанной точки строить файловые буфера - они-то как раз должны быть 
			строго определенной длины. Далее:<BR>
			- если свежие данные закончились, а буфера не заполнены, сохраняю флаг 
			m_bRecording<BR>
			- когда буфера заполнены,&nbsp;записываю их в файл и<BR>
			&nbsp; - при тригвводе сбрасываю флаг m_bRecording<BR>
			&nbsp; - при гейтвводе начинаю копить буфера заново - но только если не было 
			флага m_bNeedStop<BR>
			&nbsp; - при гейтвводе и установленном флаге m_bNeedStop - сбрасываю флаги 
			m_bRecording и m_bNeedStop</P>
		<P>Но вот какими средствами при этом обеспечивать перекрывающийся ввод???</P>
		<P>16:08<BR>
			Наверное, даже и в "неперекрывающемся" случае файловые буфера должны быть 
			отдельными объектами - для обеспечения одновременных записи в файл и заполнения 
			буфера.&nbsp;Тогда разница между&nbsp;перекрывающимся и неперекрывающимся 
			режимами заключается в том, что в первом случае заполняется один буфер, а во 
			втором нужно заполнять сразу много... Не заполнять&nbsp;я не могу - реальная 
			запись в файл поступивших данных может пойти только после того, как 
			будут&nbsp;получены ВСЕ данные....</P>
		<P>Ко&nbsp;всему прочему, буфер этот не так прост...&nbsp;он<BR>
			- может состоять из 24-битных (3-х байтных) значений<BR>
			- может иметь дополнельный канал Anntotations (for BDF+)<BR>
			-&nbsp;может (???) представлять собой смесь из 16-битных (триггер) и 24-битных 
			каналов....</P>
		<P>Начинать, видимо, я буду с "простого" варианта - 24-битных каналов....</P>
		<P>----------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050517 вт</STRONG></P>
		<P>Так за весь вечер ничего путного в голову и не пришло... Пытался думать по 
			дороге домой, по дороге на работу... Основной вопрос: что же делать с 
			возможностью перекрывающегося ввода? Ни в гейтовом, ни в "свободном" варианте 
			такого быть не может - и там все просто: завожу два буфера, пишется всегда в 
			один из них... И всё. &nbsp;Ниаких проблем не возникнет и в "нормальном" 
			триггерном варианте - когда следующий триггер приходит уже после окончания 
			обработки текущего фрагмента. Ну а если нет?</P>
		<P>Рассматривал варианты:<BR>
			- множественность буферов записи. Основной минус: при многочисленных триггерах 
			нужно писать сразу во много мест<BR>
			- Отдельные канальные буфера увеличенной длительности, запись в файл ведется 
			поканально. Минус: при большом количестве каналов сама операция "запись" может 
			стать невыносимо задумчивой<BR>
			- То же, что в предыдущем - но при окочнательной записи данные перекидываются в 
			"правильный" буфер. Минус - неэлементраная операция переброски</P>
		<P>Меня еще довольно сильно тормозило то, что один раз эта задача явно была решена 
			(последняя версия dERP позволяла записывать фрагменты с перекрытием) - но я 
			совершенно не помнил как. Смотрел версию, храняющуюся на ноутбуке - и ничего 
			там не нашел. И только сейчас снял последнюю версию (20030703 для RunThrd.cpp) 
			с компа DAQ - так вот там заведено 8 (!!!) буферов - и при необходимости запись 
			ведется в несколько сразу. Посмотрим, как это было сделано...<BR>
			&nbsp; Посмотрел. Не могу сказать, что мне все понятно. Некий флаг используется 
			- явно как обозначение для "свободности"/занятости очередного буфера (если он 
			ненулевой - данному буферу еще нужны данные; если же нулевой - в него можно 
			направлять новый ввод). Но при этом я сейчас никак не могу согласиться с тем, 
			как он считывается: после того, как я начинаю ввод в один буфер, я АВТОМАТОМ 
			перехожу на следующий - и объявляю его свободным. Что может привести к ситуации 
			"перекоса" (если на самом деле этот буфер еще не был освобожден). Нет, сейчас 
			бы я поступил так: на следующий буфер переходил (если он все равно есть - чего 
			экономить), но флаг обнулял только после того, как запись будет завершена. То 
			есть в случае прихода очередного триггера проверяется флаг текущего буфера и, 
			если он ненулевой (буфер еще не освободился) - просто пропустить данный 
			триггер. Ну и буферов возмьму поменьше... Скажем, 4 штуки - для общих задач 
			должно хватить.</P>
		<P>15:15<BR>
			В первом приближении создал класс для int24</P>
		<P>16:13<BR>
			В классе файла я завожу четырехкратный буфер, но к каждому буферу мне еще нужны 
			будут добавки: помимо флага свободности и "базового" адреса соотв. участка 
			буфера мне нужны будут еще 4 копии канальных массивов.... То есть нет, 
			главный-то канальный массив может оставаться одним - мне просто нужно для 
			каждого "подбуфера" иметь "локальные счетчики" - ведь они у меня получаются по 
			каждому каналу свои...</P>
		<P>16:43<BR>
			А как же все это будет происходить? Решив, что нужно что-то писать, я отправляю 
			классу файла соотв. сообщение, содержащее адрес массива каналов. Далее файл 
			разбирается сам:<BR>
			- нужно начать новую запись<BR>
			- нужно продолжать писать<BR>
			- нужно дописать текущий фрейм - и закончить запись</P>
		<P>Признаком того, что должна быть начата новая запись, является.... А что может 
			являться таковым признаком? Флаг занятости текущего массива не проходит - его 
			установленность может означать и то, что новую запись начать нужно - но никак 
			не возможно. То есть нужен еще один флаг (общий) - текущего ввода.</P>
		<P>Хорошо, получил я в качестве параметра адресс вектора рабочих каналов. В 
			соответствии с результатми анализа триггера и кнопок решил, что писать - нужно 
			(или мне это тоже передавать в параметрах сообщения? Ведь таковые сообщения 
			лягут в очередь...)
		</P>
		<P>Ой, еще более нет: вторым параметром сообщения станет адрес вектора, 
			сохраняющего результаты анализа триггера (угу. А кнопки мне как туда 
			складывать?)</P>
		<P>Ладно, потом. Но в общем, у меня будет информация о:<BR>
			- текущих НАЧАЛАХ канальных буферов<BR>
			- смещении в этих буферах, с которого нужно начинать запись<BR>
			- количестве поулченных данных
		</P>
		<P>Я начинаю заполнять текущий файловый буфер, и...<BR>
			- дохожу до конца буфера (а входные данные еще есть)<BR>
			- дохожу до конца входных данных (а буфер еще не заполнен)</P>
		<P>Во втором случае понятно: флаг "сейчас пишем" остается стоять - а поканальные 
			счетчики приобретают соотв. значения.
			<BR>
			В первом случае заполненный буфер должен быть отправлен на собственно запись (и 
			отображение в снап-окна), после чего нужно либо<BR>
			- закончить запись (обнулить соотв флаг) - в случаях, если кончился триггерный 
			участок или был получен сигнал о конце гейта<BR>
			- переключиться на следующий буфер - и заполнять его (если гейт продолжает быть 
			открытым)</P>
		<P>Но вот каким образом "продолжать в следующем буфере"? Мне нужно будет либо 
			запоминать итоговую позицию по каждому каналу - либо и сами переключения 
			осуществлять многократно (для каждого канала). Не проще ли будет сделать второе 
			- тем более что речь идет только о "непрерывных" режимах?</P>
		<P>Далее, случай с множественными триггерами: пришел один, начали писать первый 
			буфер, не закончили - а уже пришел второй, пишем и следующий - и тоже не 
			закначиваем.. Следовательно, каждый раз, получая "свежую посылку", я должен 
			буду перебирать все четыре буфера и проверять - ждет ли какой из них еще 
			данных. А получив "свежий триггер", опять же перебирать все - и определять, 
			есть ли свободный. Если же его нет... Отказываться? Или все же заводить еще 
			один (то есть - делать массив динамическим)?
		</P>
		<P>Далее - проблема борьбы с дребезгом (chatter). В случае триггера она должна 
			решаться введением "мертвого окна", в пределах которого новый триггер просто не 
			распознается. Для гейтов такой вариант недопустим. Там возможны:<BR>
			- дребезг при включении (вкл - кратковременное выключение - снова вкл)<BR>
			- при выключении (выкл - снова чуть-чуть вкл - выкл)<BR>
			- кратковременное включение<BR>
			- кратковременное выключение</P>
		<P>Первая и третья проблемы: сводятся к тому, что у меня есть еще один сигнал на 
			включение. Когда он приходит, мне нужно проверить - не соответствует ли он уже 
			записанному участку. При дребезге на включении это, очевидно, будет так - и 
			тогда тихо-спокойно продолжаем. При кратковременном выпадении теоретически 
			возможна ситуация, когда участок сигнала действительно таки выпадет. Ну так и 
			оставим его так :)</P>
		<P>Вторая и четвертая проблемы: последний случай как бы вообще не страшен (будет 
			начат и записан новый фрейм). При выключении же я рискую после реально 
			непрерывной серии записать еще один фрейм, да еще и с разрывом в начале... Как 
			бы все-таки от этого избавиться???</P>
		<P>19:56<BR>
			Я все еще продолжаю "теоретические измышления". На сей раз - на тему меток 
			времени и соответственно - определения того, нужен ли триггер. Так вот, чтобы 
			не маяться дурью с синхронизацией, время буду считать собственно по отсчетам. 
			Их, в DWORD, должно хватить на трое суток даже при максимальной частоте.... Но, 
			с другой стороны, в файл я должен буду писать именно время - то есть какая-то 
			"база" мне нужна. И где же она должна определяться? Строго говоря, ТОЧНО я 
			этого сказать все равно не смогу - поэтому пусть будет по кнопке Go...</P>
		<P>Но, согласно спецификации EDF+, события в файле должны считаться от момента его 
			открытия. Поэтому мне понадобятся два времени - время создания файла и время 
			нажатия на кнопку (чтобы определить смещение этого времени от времени создания 
			файла).</P>
		<P>21:26<BR>
			переменные-счетчики заведены. Вроде бы что-то считается. Но! Я не вижу сигнала 
			о закрытии гейта!!" Нет - это была уже ошибка тестирования: я вчера тригусловия 
			изменил (три бокса отметил). Нет, вроде бы все это работает....</P>
		<P>---------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050518 ср</STRONG></P>
		<P>Снова - дорожные мысли... После получения очередной порции данных и первичного 
			триганализа данные передаются "файлу". Возможные ситуации:<BR>
			- ЗАПИСЬ ИДЕТ<BR>
			&nbsp; - свежих команд нет - просто пишем и все тут<BR>
			&nbsp; - свежие команды есть. Что это может быть?<BR>
			&nbsp;&nbsp;&nbsp;&nbsp; - Тригрежим - ТОЛЬКО новый триггер (может быть не 
			один)<BR>
			&nbsp;&nbsp;&nbsp;&nbsp; - гейтрежим - ТОЛЬКО выключение гейта (но - возможно - 
			с последующим его включением)<BR>
			- НЕТ ЗАПИСИ<BR>
			&nbsp; - свежих команд нет - можно сразу отвалиться<BR>
			&nbsp; - свежие команды есть. Что это может быть?<BR>
			&nbsp;&nbsp;&nbsp;&nbsp; - Тригрежим - ТОЛЬКО новый триггер (может быть не 
			один)<BR>
			&nbsp;&nbsp;&nbsp;&nbsp; - гейтрежим - ТОЛЬКО включение гейта (но - возможно - 
			с последующим его выключением - и так не один раз)<BR>
		</P>
		<P>12:57<BR>
			Продолжаю - вдогонку "дорожным" (которые, собственно, так и не были записаны): 
			сообщение должно отправляться себе же (так как таймерная секция - в отдельном 
			потоке, который задерживать не стоит). А передать в нем я могу только адрес 
			списка событий... И что мне тогда делать? В месте принятия начну работать со 
			списком - а очередной таймер его модифицирует.... То есть получается, что флаги 
			событий мне следует расставлять прямо в триггерном канале? (О чем и думал по 
			дороге) Но это "наедет" на другую проблему: децимируемость тригканала... Чем же 
			сие грозит? Собственно - лишь одним: наличием в одном выходном слове разных 
			команд. Что может решаться так:<BR>
			- в тригрежиме - только триг<BR>
			- последовательность GATE_ON GATE_OFF так и передается<BR>
			- при последовательности GATE_OFF GATE_ON выклчюение гейта подавляется</P>
		<P>Но при этом и анализировать мне нужно в другом месте....</P>
		<P>14:50<BR>
			Итак, я вроде бы закодировал все в триггерных словах. Теперь мне существенно, 
			чтобы тригканал в списке стоял на первом месте. Попробую переставить.</P>
		<P>14:56<BR>
			Вроде бы перестановка прошла....</P>
		<P>15:00<BR>
			Класс TrigPos и соответствующий вектор удалены из класса CMainFrame</P>
		<P>15:46<BR>
			Были обнаружены утечки памяти. Думал - из-за заведенного файла, оказалось - 
			недовычищенные проблемы с децимирующими фильтрами и буферами. Исправил.</P>
		<P>16:00<BR>
			Установка триггерных команд по кнопке "пауза"</P>
		<P>18:50<BR>
			Начал прописывать записывающие фрагменты - тяжело получается, неизящно.... А 
			если тяжело и неизящно - то и работать оно не будет :( Вот и не работает... То 
			есть нужно как-то совсем по-другому. Интересно, как????</P>
		<P>20:14<BR>
			Транспонировал цикл. Первые признаки работоспособности. Не ловлю выключения 
			паузы.</P>
		<P>20:33<BR>
			При таком подходе m_nEndPoint мне и не нужна - достаточно флага m_bNeedStop. В 
			такой конфигурации элементарный случай (гейт без разновеликих каналов) 
			работает.</P>
		<P>21:40<BR>
			Стал пробовать с сочетанием децимированных и не каналов - вылетаю. Искал 
			причину в классе файла, потом дошло... И при отключенной записи вылетаю точно 
			так же: дело было не в бобине....</P>
		<P>00:17 - at home<BR>
			По всей видимости, основное изменение, повлекшее за собой неработоспособность 
			программы в режиме децимации без децимации триггера - перестановка тригканала 
			на первое место в списке: вид именно из нулевого канала считывает "основной" 
			счетчик. Если он будет делать это, базируясь на канале 1, неприятностей быть не 
			должно (НО!!! Нужно учитывать и вариант, когда пишется только один канал - 
			триггерный)</P>
		<P>----------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050519 чт</STRONG></P>
		<P>12:00<BR>
			Счетчики: вернулся к "старому образу мыслей": таймерная ф-ия послыает 
			сообщение, в котором WPARAM содержит децимированный счетчик - он-то и считается 
			видом за основной. В таком виде работает.</P>
		<P>12:05<BR>
			И после раскомментирования "пишущего сообщения" тоже не вылетает. НО! При 
			недецимированном счетчике пишу явно много (явный сбой счетчиков) - и неполадки 
			при остановке...</P>
		<P>12:50<BR>
			В частности обнаружено: "количество модулей" при построении главного списка 
			каналов не учитывается!!!</P>
		<P>13:10<BR>
			Да - действительно не учитывалось... И с тачпруфами примерно так же: где-то 
			учитвывалось - но успешно забывалось...</P>
		<P>13:21<BR>
			С записываемыми фреймами - точно так же: вернулся к передаче самого 
			децимированного значения.</P>
		<P>[отвлечение на тестовый эксперимент - записывали ActiView, свою версию просто 
			погонял]</P>
		<P>20:30<BR>
			Два самых актуальных замечания<BR>
			- Ошибка при остановке - обращение к уже несуществуещему канальному буферу из 
			NewFrame()<BR>
			- в режимах децимации дублируется первая триггерная команда
			<BR>
			Второе - замечание мелкое, а вот первое может быть серьезно. Отлавливать 
			сложно: проявляется довольно редко. Проверил, я и в самом деле удаляю 
			"канальный буфер" как бы без предупреждения - а он в это время может еще 
			обрабатываться. Непонятно, почему я не налетал на это без записи - возможно, 
			дело в том, что "записывающий" фрагмент куда более задумчив... Но в общем, с 
			этим нужно что-то делать...</P>
		<P>20:42<BR>
			Окуржил удаление буфера и вызов NewFrame критической секций m_csWChans - вроде 
			бы вылетов нет (но я и до того снова не смог их отловить). Но на самом деле 
			нужно другое: чтобы команда "Стоп" вообще не срабатывала до тех пор, пока не 
			будет дописана текущая секция!!! Или, хотя бы, чтобы запись действительно была 
			абортирована....</P>
		<P>Вариант "подождать" по-простому не пройдет - файл пишется в том же главном 
			потоке... Это мне нужно каким-то образом перепослать себе сообщение</P>
		<P>21:04<BR>
			Да, такой вариант похоже что работает. Не совсем ясно с "самым началом" - то я 
			выставляю паузу, то нет... Наверное, здесь вообще нужно логику управления 
			менять....</P>
		<P>21:08<BR>
			Спецмеры для преодтварещения заполнения фильтровального буфера тригкомандой.</P>
		<P>--__________________----------------------------------------------------------------------------------------------</P>
		<P><STRONG>050520 пт<BR>
			</STRONG><EM>(утром прогулялся - посмотрел соловев, на работе с 14:00)</EM></P>
		<P>14:00-16:50<BR>
			Озадачился выделением "файла" в отдельный поток. Сначала хотел еще один класс, 
			потом передумал - сделал сам файл наследником потока и процесса. Долго не мог 
			там найти свое сообщение... Только под конец понял: мне нужно при запуске 
			регистрировать в своем же лупе свой же фильтр (и нигде больше!). В таком виде 
			прекрасно работает - и даже таких проблем с синхронизацией нет! Хотя для 
			очистки совести мне все же лучше передавать адрес нужной крит. секции - чтобы 
			ее отслеживать....</P>
		<P>17:00<BR>
			Первая попытка обрамить получение фрейма крит. секцией закончилась неудачей: 
			при остановке попадаю в дедлок....</P>
		<P>18:00<BR>
			Все же пришлось отказаться от цикла, ожидающиего "дописывание" - висну. 
			Вернулся к варианту повторого пощения сообщения.</P>
		<P>На очереди - запись триггерного варианта. Основное в нем - с учетом претриггера 
			откатиться назад и сходу положить в очередной (!!!) свободный (!!!) буфер все 
			претригзначения.</P>
		<P>19:02<BR>
			В связи с переходом к триггерной записи (с возможным перекрытием и, соотв-но, 
			множественной записью) мне нужно изменить подход к понятиям "занят-свободен"<BR>
			- bUsed - все буфера, которым нужна запись<BR>
			- при переходе на след. буфер текущий объявляется Free, а следующий - тут же 
			Used<BR>
			- Видимо, в самом начале нужно объявлять первый буфер Used (или вообще если не 
			пишем...)</P>
		<P>19:35<BR>
			Выстроена возможность записи в несколько буферов сразу. Пока я работаю только с 
			гейтвводом, и мне ничего на страшно :) В том смысле, что у меня и запись в файл 
			пойдет синхронная, то есть текущий буфер по окончании записи уже будет свободен 
			- то есть я гарантированно получу свободный буфер!!! Но нужно предусмотреть и 
			ситуацию, когда этого не будет (если мне когда-нибудь случится перейти на 
			асинхронную запись).</P>
		<P>21:40<BR>
			Какой-то вариант триггерного ввода прописал - но по-настоящему там еще очень 
			далеко..<BR>
			- Обязательно нужна хоть одна посттриггерная точка<BR>
			- Вопрос с автоматикой нулевого буфера при триггерном вводе (если я его 
			помечаю, как писабельный - то в него пойдут только посттриг данные)<BR>
			- Вопрос с логикой отключения записи и перехода на след. буфера...</P>
		<P>В общем, есть где подумать :) Но - буду сворачиваться</P>
		<P>---------------------------------------</P>
		<P><STRONG>050523 пн</STRONG></P>
		<P><EM>Будем восстанавливаться после огородных выходных (+22, картошку сажали)</EM></P>
		<P>Итак, для обеспечения правильной буферизации мне необходимо "уточнить" флаг 
			занятости - он должен иметь следующие значения:<BR>
			- буфер свободен<BR>
			- в буфер ведется запись<BR>
			- запись в буфер завершена, файл нуждаетяс в переоткрытии</P>
		<P>Общий флаг bWritings должен устанавливаться по "или" - если хотя бы один из 
			буферов нуждается в новых данных. При входе в ф-ию все буфера должны 
			проверяться, если хотя бы один нуждается в закрытии - произвести закрытие и 
			переоткрытие файла, буфер объявить свободным.</P>
		<P>14:56<BR>
			Вроде бы отлажена логика работы с буферами - судя по сообщениям, отлажена как 
			для триггеров (в том числе - множественных(), так и для гейтов. Теперь нужно 
			думать о возможном сочетании (гейт в триггерном режиме - свободная запись).</P>
		<P>Но для этого сначала нужно понять, какую же логику я хочу получить... Итак, речь 
			идет о тригрежиме:<BR>
			- нажимается кнопка (или включается гейт) - ведем "обычную" непрерывную 
			гейт-запись<BR>
			- в ходе гейт-записи поступает триггер: мы должны<BR>
			&nbsp; - завершить текущий гейт-фрейм - и не начинать новый!<BR>
			&nbsp; - начать новый триг-фрейм<BR>
			&nbsp; - если "свободная запись" велась по кнопке (а не по хардовому гейту), 
			сбросить эту кнопку!<BR>
			- по окончании записи триг-фрейма (точнее - всех триг-фреймов) - снова 
			вернуться к рассмотрению вопроса о гейте. Если он установлен, продолжить запись 
			в свободном режиме.</P>
		<P>Вообще же, все это "замыкается" на иную общую логику - и иные кнопки. Так что 
			начинать нужно с того, что сделать эти кнопки. Это должны быть:<BR>
			- disable writing<BR>
			- Run<BR>
			- Pause<BR>
			- Manual recording</P>
		<P>Первая - касается только файла, и меня сейчас не волнует. Вторая - остается 
			точно той же, что и сейчас. Третья - меняет свое назначение в том отношении, 
			что НЕ ВКЛЮЧАЕТ гейт, а только отключает его запрещение.
		</P>
		<P>19:24<BR>
			Кнопки я сделал, и даже как-бы их "базовую функциональность" обеспечил - но 
			вопрос еще и в том, что этот подход должен сопровождаться соотв. изменениями в 
			диалоге: выкидыванием "свободного ввода" и выделением для тригввода отдельного 
			гейта для "ручного ввода"....</P>
		<P>----------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050524 вт</STRONG></P>
		<P>Продолжаю перестаивать триггерный диалог (удаление Free режима, отдельный гейт 
			для свободного ввода в тригрежиме). Сейчас не устраивает:<BR>
			- В гейтрежиме второй And не запрещает соотв. гейтбиты<BR>
			- В тригрежиме учитывается And3</P>
		<P>13:54<BR>
			Это сделано. Следующее не то: тригбиты вообще не запрещают гейтбитов</P>
		<P>13:56 - сделано. Переходим к самим разборкам. Похоже, что мне понадобятся и 
			другие возвращаемые значения....</P>
		<P>Еще раз - о кнопках:<BR>
			- Гейтрежим: работают исключительно как радио, флаги m_bNeedStart, m_bNeedStop; 
			повторное нажатие на уже нажатую кнопку эффекта не имеет<BR>
			- Тригрежим: работают независимо: левая выставляет те же флаги, правая - 
			m_bManStart, m_bManStop</P>
		<P>15:14<BR>
			Добавлены слова (расширяюсь вправона два бита)<BR>
			0xF0800000; - ManStart<BR>
			0xF0400000; - ManStop</P>
		<P>16:13<BR>
			С анадизом битов все еще хитрее: при таком подходе получается больше возможных 
			сочетаний: кроме возможности одновременного прихода триггера и включения гейта 
			добавляется оба варианта мануального гейта (как включение, так и выключение). 
			Соответственно, становится невозможной алгебраическая суммация - только по 
			битам.... Приходится менять коды возврата на:<BR>
			#define GATE_ON 1
			<BR>
			#define GATE_OFF 2
			<BR>
			#define TRIG_ON 4
			<BR>
			#define MAN_ON 8
			<BR>
			#define MAN_OFF 16
		</P>
		<P>17:33<BR>
			Соответственно, и возврат проверяем раздельно: в свитче биты манов не 
			учитываем, они пойдут отдельным свитчем</P>
		<P>18:10<BR>
			В мейнфрейме что-то прописал - пора идти в файл....</P>
		<P>18:50<BR>
			Что-то соответствующее попробовал прописать и в файле: дескать, если запись 
			есть - то просто снимаем флаг окончания, если записи нет - помечаем, что нужна 
			новая....</P>
		<P>У меня неполадки с чтением гейтов!!!</P>
		<P>19:15<BR>
			Ну да, у меня же отпала необходимость ремэпирования кнопок и массивов... Все 
			ненужное - удалено!. С результатами пока все равно неясно.... Будем пытать.</P>
		<P>19:18<BR>
			Таак... У меня в тригрежиме пауза не выключается :(</P>
		<P>19:46<BR>
			Гейт в тригрежиме переключаю нормально. Триггера = не вижу :(</P>
		<P>20:12<BR>
			Локализовал еще пару сегодняшних ошибок. Триггера ловлю, гейты тоже. Более 
			того, "понимаю" и маны, даже корректно выключаю их по триггеру - но 
			промахиваюсь при ручном выключении :(((</P>
		<P>20:53<BR>
			И с ручным выключением тоже разобрался. Но - не чую хардовых манов.</P>
		<P>21:03<BR>
			Как-то исправил - но насколько верно смогу узнать только при реальном вводе...</P>
		<P>21:08<BR>
			Попытался сигнализировать только о включении - не помогает, не понимаю....</P>
		<P>21:17<BR>
			Легкая коррекция остановки при мануальном вводе в тригрежиме Наверное, нужно 
			будет уточнить....</P>
		<P>21:30 - и с гейтрежимом тоже подрправил.</P>
		<P><STRONG><FONT color="#cc0066">Нужно отображать установленный режим ввода!!!</FONT></STRONG></P>
		<P>------------------------------</P>
		<P><STRONG>050525 ср</STRONG></P>
		<P>ToDo:<BR>
			- calculating and keeping time<BR>
			- event channel<BR>
			- CSnapView<BR>
			- File recording</P>
		<P>Время: согласно спецификации, каждая запись должна начинаться с поля "смещение" 
			- относительно начала файла, в секундах, со знаком. При этом время первой 
			записи ОБЯЗАНО быть нулевым - и означать время начала файла, указанное в 
			заголовке (дата и время в ч:м:с)<BR>
			&nbsp; Вопрос: как мне отслеживать это время? Наиболее точный вариант может 
			дать лишь подсчет введенных точек - но он окажется невалидным в случае, если в 
			записи были перерывы (нажатия кнопки Run/Stop). То есть мне нужны будут ДВА 
			времени - время первой записи и время каждого последующего запуска.</P>
		<P>Точное время запуска я смогу (гипотетически - время начала ввода) я могу 
			получить в ф-ии OnTimer - но не просто взяв текущее время, а еще и вычтя из 
			него длительность полученного участка (кол-во полученных точек деленное на 
			частоту дискретизации). Все последующие времена будут расчитываться из него - и 
			общего счетчика введенных точек.</P>
		<P>Само получение времени:<BR>
			&nbsp; GetLocalTime(&amp;tmSystemTime); //получим текущее локальное время в 
			формате SYSTEMTIME<BR>
			&nbsp; SystemTimeToFileTime(&amp;tmSystemTime, &amp;ftmTime); //переводим время 
			в 100 ns единицы - т.е. *10000 даст ms<BR>
			(переменные должны быть статическими - если они в стеке, то что-то глючит....)</P>
		<P>Но хорошо: время я измерил. Но как его передавать? Собственно "непрерывную 
			нумерацию" может иметь лишь первичный буфер - но все виды и файл имеют дело уже 
			с динамическим поканальным массивом... Так-так-так... Первой моей мыслью было - 
			завести еще один массив и писать в него счетчик. Но как-то это уж больно 
			расточительно, да и потребовало бы солидных перестроек в самых-самых основных 
			массивах... Тогда остается еще один вариант: считать непосредственно в 
			CDataFile - и считать точки тригканала. Тем более что и время старта, и 
			собственно назначение времени конкретной записи - дело именно файла....</P>
		<P>-------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050526 чт</STRONG></P>
		<P>Продолжаем раздумья о подсчете времени. Остановился я на том, что в CDataFile 
			считаю точки тригканала. И вот пришел сигнал на запись...<BR>
			- если это вообще первая запись, нужно:<BR>
			&nbsp; - присвоить это значение&nbsp;переменной StartPoint<BR>
			&nbsp; -&nbsp;Установить "глобальное" стартовое время, прибавив значение 
			счетчика (*10000000/nFrq) к&nbsp;полученному в&nbsp;основном окне времени 
			нажатия на кнопку "Run".&nbsp;</P>
		<P>- если запись не первая<BR>
			&nbsp; - это - первый Run, перерывов не было - смещение вычисляется только из 
			счетчика<BR>
			&nbsp; - были перерывы - к смещению должна добавляться&nbsp; разница между 
			временем очередного запуска и глобальным стартовым временем.</P>
		<P>14:32<BR>
			С этой целью m_u64StartTime перенесена в CDataFile, m_u64RunTime будет и там, и 
			там (в главном окне нужна, чтобы определять только один раз, в файле по ней 
			будет производиться "базирование")</P>
		<P>15:08
			<BR>
			Расчет стартового времени перенесен в CDataFile. Но! Там два входа - при одном 
			счетчик еще не инкрементирован, при другом - уже да... Так что переношу 
			увеличение счетчика в начало обработки тригканала.
		</P>
		<P>Осталось разобраться с не-первым пуском....</P>
		<P>19:25<BR>
			Что же, вроде бы с временами разобрался - и в гейтовых, и в триггерных режимах 
			показывают что-то похожее на истину. Так и не додумал (и не проверил, 
			следовательно) ситуацию с приходом триггера на фоне продолжающегося свободного 
			ввода... Но, наверное, на это нужно уже смотреть - то есть нужно сделать то, 
			чем смотреть. Но для начала - чекин</P>
		<P>=++++++++===================== чекин =================================</P>
		<P>19:40<BR>
			Итак, я хочу образовать "базовый вид", потомками которого будут вид-осциллоскоп 
			и вид-снэпшот (для начала). Для этого я должен сначала понять, какие из 
			переменных и методов должны перейти в базовый класс, а какие - остаться "чисто 
			осцилльными"....</P>
		<P>21:30<BR>
			Первый вариант "разнесения" умудрился оставить работоспособным. Вопрос в том, 
			что мне тогда нужно еще и диалоги делать разными - ну или по крайней мере 
			чувствительными к "содержимому"... В противном случае большинство ф-ий придется 
			оставить виртуальными - но везде.... Пока же получается неплохо: результат 
			зависит от того, какой именно вид порождает GrThread. А он создается диалогом в 
			OnInitDialog. Соответственно, достаточно будет сделать тип окна третьим 
			параметром конструктора диалога (и тогда он спокойно сможет что-то отображать - 
			а что-то нет...)</P>
		<P>-----------------------------------------------------------------------------------</P>
		<P><STRONG>050527 пт</STRONG></P>
		<P><EM>Что-то и встал поздно, и всю первую половину дня занимался другим - купил 
				Рубинар 500/8 (1200 р + 620 р бленда + 100 р крышка) - вот все и смотрел на 
				него и сквозь него, по сайтам ползал... Но все же...</EM></P>
		<P>На самом деле мне нужен совсем другой уровень абстракции. Базовый "вид" должен 
			содержать в себе лишь то, что необходимо для отображения ЧЕГО УГОДНО - то есть 
			никаких специфичных ф-ий в нем быть не должно. Таким образом, на настоящий 
			момент мне нужно выкинуть<BR>
			+SetZero(void) 
			-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			called by CDlgView::OnBnClickedZero<BR>
			+SetScroll(BOOL bSc)&nbsp;&nbsp; called by CDlgView::OnBnClickedScroll, 
			OnInitDialog, DoDataExchange<BR>
			+SetFrq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			message&nbsp; WM_DIZ_SETFRQ form CDlgView and CMainFrame<BR>
			+SetBuffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			called by CActDView::SetFrq and MapChanged<BR>
			+Set_Timer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;called 
			by COscView::Plot<BR>
			+Plot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message 
			WM_DIZ_PLOT<BR>
			+OnCfChanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			message WM_DIZ_CFCHANGED<BR>
			+Draw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			called by COscView::Plot<BR>
			+ChangeTimer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;called 
			by CDlgView::OnBnClickedTool. OnInitDialog<BR>
			+ 
			MapChanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			message WM_DIZ_MAPCHANGED<BR>
			и сделать переменным содержимое ф-ий<BR>
			OnSize<BR>
			OnPaint<BR>
		</P>
		<P>17:27<BR>
			CActDView::MapChanged(void) удалена и заменена на<BR>
			CActDView::OnMapChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, 
			BOOL&amp; /*bHandled*/), теперь обрабатывается не в PreTranslateMessage 
			-&nbsp;а в основной карте сообщений. Соответственно, и перенести проще...&nbsp;</P>
		<P>17:55<BR>
			бОльшая часть перенесена<BR>
			вместо ф-ии ChangeTimer - OnChangeTimer как обработчик сообщения 
			WM_DIZ_CHANGETIMER</P>
		<P>18:01<BR>
			C SetZero() и SetScroll() - так же....<BR>
			Таким образом, все специфичные ф-ии убраны. Теперь нужно так же поступить и с 
			переменными....<BR>
			Переносим
			<BR>
			m_bZero<BR>
			m_bScroll<BR>
			m_nWinBegPix - Нужна в OnSize<BR>
		</P>
		<P>18:41<BR>
			Собственно, OnSize - тоже лишь обработчик сообщения. Убираем в COscView. 
			Продолжаем перемещать пер-ые<BR>
			bool m_bChange;
			<BR>
			fltCf2 m_cfLP;
			<BR>
			fltCf1 m_cfHP;
			<BR>
			CRITICAL_SECTION m_csBitMaps;
			<BR>
			&nbsp; - для этого пришлось продублировать OnCreate с вызывом род. метода. 
			Интересно, а работать это будет???<BR>
			&nbsp;&nbsp;&nbsp; Да&nbsp;&nbsp;вроде&nbsp;&nbsp;&nbsp;&nbsp; как работает....<BR>
			UINT m_uTimerID;
			<BR>
			DWORD m_dwTime;
			<BR>
			double *m_pOldHPx;
			<BR>
			double *m_pOldLPx;
			<BR>
			double *m_pOldHPy;
			<BR>
			double *m_pOldLPy;
			<BR>
			int m_nTrigFrameCnt;
			<BR>
			<BR>
			/////// - не нужен long *m_pActBuf;<BR>
			long *m_pChanBuf;
			<BR>
			long *m_pRefBuf;
			<BR>
			WORD *m_pTrigBuf;
			<BR>
			int m_nMaxCnt;
			<BR>
			int m_nMaxTrigCnt;
			<BR>
			_GrBitmap *m_pWriteBmp;<BR>
			_GrBitmap *m_pReadBmp;
			<BR>
			int m_nWinFrameCnt;
			<BR>
			int m_nOneSecCnt<BR>
			УДАЛЕНА m_nLengPlus<BR>
			int m_nTimer<BR>
			УДАЛЕНЫ //int m_nX0, m_nY0; int m_nXSum,m_nYSum;<BR>
		</P>
		<P>19:36<BR>
			m_Pnt из статического сделан динамическим!!!<BR>
			Переменных там еще много - но дальше переносить я подожду: многие из них могут 
			понадобиться и для снапшота.</P>
		<P>21:10 (после очередной порции скана Сокала)<BR>
			Все же для диалогов тоже такое нужно будет - но много проще: в базовом классе 
			останется всего ничего, только указатель не вид да ф-ия активации...</P>
		<P>--------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050528 сб<BR>
			</STRONG><EM>Утром попытался поснимать птичек во дворе и около школы новым 
				стеклышком - безуспешно :( Поехал через Невский - а там подготовка к 
				карнавалу... Зашел в ЯМ, маленьких моноподов нет, в ФотоРу тоже - в итоге взял 
				еще один маленький штатив, но со съемной площадкой... Посмотрим... До работы 
				добрался лишь к 14:00, и начал не с работы, а с подготовки японской фотографии 
				к публикации</EM></P>
		<P>18:06<BR>
			Все-таки смог разделить и диалоги тоже на "базовую" и "индивидуальную" части. 
			Основная проблема оказалась с IDD, которая бралась из базового диалога. 
			Проблему удалось решить созданием своей ф-ии Create, причем она не виртуальная, 
			так что и указатель для ее вызова нужен явный. Что большой проблемой не 
			является: вызов идет из CMainFrame::OnOscNew.</P>
		<P>Пойду посканирую....
		</P>
		<P>21:06 Сканирование затянулось (еще и 18 глава вылетела - а она длинная...) Так 
			что больше ничего не успеваю - пора домой :(</P>
		<P>------------------------------------------------------------------</P>
		<P><STRONG>050530 пн<BR>
			</STRONG><EM>Начал день с письма Виктору Марковичу Шкловскому - про Active2. Ну и 
				Гале соловья заслал....</EM></P>
		<P>13:51<BR>
			Так. Что у нас должно быть в снапшот-диалоге? "Длина окна" не нужна. Но могут 
			понадобиться: номер реализации и кнопки перехода между ними (первая, пред, 
			след, последняя). Кроме того, участок отображения.... Попробуем.</P>
		<P>15:32<BR>
			Созданы диалог и класс вида. Контрукторы получили доп. параметр - тип (и поток 
			- тоже). Добился невылетаемости.</P>
		<P>17:43<BR>
			Даже присобачил к снапвью статусбар! Разрешаю закрывать первый при отсутствии 
			файла. Но! Вопрос в том, что и у первого может оказаться непервый номер.... То 
			есть нужно иметь&nbsp; отдельно счетчик, и отдельно - нумера....</P>
		<P>18:01<BR>
			Для обоих видов заведена двойная бухгалтерия: отдельно считаю номера, отдельно 
			- количество... Так помогает.</P>
		<P><EM>Николай Иванович оторвал вопросом про старинный DAQ, после этого к программе уже 
				не вернулся - попереставлял страницы в Sokal (дошел до 9 главы, в ней чего-то 
				напутал - и недоделал)</EM></P>
		<P>------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050531 вт</STRONG></P>
		<P><EM>Написал письмо в Универсалприбор: уже и май кончается, а обещанного в марте 
				осциллографа так и нет... Но и ответа нет тоже. Немножко фотосайта, немножко 
				Сокала: закончил главу 9 и сделал 10-11</EM></P>
		<P>12:56<BR>
			Нужно инициализировать CSnapView - резервировать буфера. По команде отрисовки 
			вид должен перекачать буфера к себе (полностью, чтобы можно было в любой момент 
			изменить отображение и референсинг, наверное лучше - с обратным декодированием 
			в Long)</P>
		<P>Где? Это понятно - там же, где инициализируется файл, при начале ввода (по 
			нажатию кнопки Run). В каком случае? Тоже понятно - если есть хотя бы один 
			SnapView. Остается вопрос, в каких случаях я должен принудительно создавать 
			новый SnapView, если ни одного нет. По моей логиек получается, что делать это 
			нужно:<BR>
			- если отрыт файл<BR>
			- если установлен триггерный режим ввода</P>
		<P>13:37<BR>
			К видам добавлен константый член m_nType, автозаполняемый в соотв. дочерних 
			конструкторах</P>
		<P>13:45<BR>
			Новое сообщение
			<BR>
			WM_DIZ_SNAPINIT, (WPARAM)(&amp;m_arChanW), (LPARAM)(&amp;m_atrParams)</P>
		<P>14:43<BR>
			Чтобы не путаться в Init-функциях (кроме моих - для карты и файла существует 
			еще куча стандартных), переобозвал свои ф-ии. Соответственно - изменения во 
			многих файлах....</P>
		<P>15:43<BR>
			Случайно подправил не то сообщение... Промаялся....<BR>
			Чтобы не искать в разных местах, флаг "плюсового формата" помещаю в структуру 
			Pointer24</P>
		<P>16:35<BR>
			Пока из рисования - только зачистка территориии. Все бы ничего - но для 
			взаимодействия с картами мне откуда-то нужно получать и использовать реальные 
			номера каналов!!!</P>
		<P>...Снова запутался с номерами каналов... Сложная там история: нужно высесть 2, 
			сравнить с кол-вом пинканалов, и при &gt;= вычесть число пинов и добавить 256<BR>
			<FONT color="#000099">&nbsp; m_pnChanNums[chan] = 
				(*parChanW)[chan+1].GetChanNum()-2;
				<BR>
				&nbsp; if (m_pnChanNums[chan] &gt;= m_nPinChans)
				<BR>
				&nbsp;&nbsp;&nbsp; m_pnChanNums[chan] = m_pnChanNums[chan]- m_nPinChans + 256; </FONT>
		</P>
		<P>20:47<BR>
			Впервые! Картинка нарисовалась!!!</P>
		<P>21:37<BR>
			Так, ладно.<BR>
			Рисует - и даже картинка после остановки держится :)<BR>
			Замечания и прочие <STRONG><FONT color="#cc0066"><FONT color="#000099">TODO<BR>
					</FONT><FONT color="#000099">- Биполяры<BR>
					</FONT><FONT color="#000099">- учет статусбара при определении размеров окна</FONT><BR>
					<FONT color="#000099">- Карты снэпшота не должны гаситься при выключении!!! Они 
						зависят только от "файла".<BR>
						- отзовн изменения масштаба - тот же, что и при изменении карты<BR>
					</FONT><FONT color="#000099">- подключение фильтров<BR>
					</FONT><FONT color="#000099">- триггер<BR>
					</FONT><FONT color="#000099">- вывод имен каналов<BR>
					</FONT></FONT><FONT color="#000099">- проблемы с одновременной активацией 
					осцилла и снэпшота</FONT></STRONG></P>
		<P>--------------------------- домой -----------------------------</P>
		<P><STRONG>050601 ср</STRONG></P>
		<P>Так... Выяснилось, что в субботу нужно паковать посылку на МБС. Вспоминаю, что 
			нужно... Заскочил в Дикси, что-то купил....</P>
		<P>14:43<BR>
			Для правильного учета статусбара используется ф-ия UpdateBarsPosition(rc);</P>
		<P>Карты снэпшотов и основная карта. Если файл начат (есть хотя бы одна запись) - 
			снэпшоты работают только с ней - и любая попытка изменения (а это может быть 
			только механическое изменение режима ввода) должно приводить к матюкам. Если 
			файл не начат (то есть снэпшоты существуют, но реальных записей нет), матюков 
			может и не быть - но изменения основной карты переносятся в дочерние только при 
			попытке запуска!</P>
		<P>15:34<BR>
			Не так просто с этими картами. Передачу сообщения снэпшотам я заблокировал - но 
			остаются проблемы со ссылкой на "основную карту". Получается, что у снэпшотов 
			она должна быть своя (одна на все) - ну и содержаться она тогда должна в 
			файле....</P>
		<P>Передачу карты файлу я легко могу сделать по запуску (главная карта в любом 
			случае по запуску фиксируется). Ну а что&nbsp;делать в случае, 
			если&nbsp;снэпшот был открыт - а никаких запусков еще не производилось? Уж в 
			этом-то случае карта снэпшота должна повторять&nbsp;главную... Тогда, наверное, 
			так: при создании снэпшот ссылается на главную карту, а как только есть хоть 
			одна запись... Но снэпшотов может быть много... Тогда так: файл имеет 
			собвственную ссылку, изначально устанавливаемую на главную карту. Как только 
			происходит заполнение собственно файловой карты, ссылка переводится на нее (и 
			на ней остается). А снэпшоты всегда ссылаются на файловую карту (то есть - на 
			ту самую ссылку)</P>
		<P>&nbsp;16:37<BR>
			Нет, указатель на файловую карту будем держать в главном окне - так проще.
			<BR>
			Получилось.</P>
		<P>18:28<BR>
			Передача сообщения из EditUpdate для перерисовки. Нужно то же самое для 
			биполяров и триггера.</P>
		<P>21:44<BR>
			Вроде бы вывел рисование линии в отдельную ф-ию (надо бы сделать ее вообще 
			общей для всего), начал работать с биполярами - но там снова засада: мне же 
			нужно перейти от "условных" номеров к номерам в получаемом массиве... А как? И 
			вообще нужно уже делать файл - и тогда с ним можно будет работать безо всяких 
			девайсов....</P>
		<P>---------------------------------------------------------------------------------------</P>
		<P><STRONG>050602 чт</STRONG></P>
		<P>13:50<BR>
			Вроде как выставил правильные биполярные каналы. Но вот что у меня с нижней 
			частью графика??? И что должно быть с цветами биполяров??? Ладно, с цветами 
			поступлю просто: начну нумерацию заново...</P>
		<P>14:12<BR>
			Триггер тоже рисуем. Не желаем жить, если нет аналоговых каналов..</P>
		<P>14:18<BR>
			C рисованием без аналоговых каналов тоже справился (h)</P>
		<P>14:35<BR>
			Вывод имен каналов (как обычных, так и биполяров)</P>
		<P>Вывод имен и карт ФАЙЛА порождает еще одну проблему: очень желательно и в случае 
			файла сохранять разбиение на модули (и выделение EXT в отдельную линейку). 
			Видимо, для осуществелния этого нужно записывать в файл не только имена каналов 
			(если таковые есть), но и их "номера" - например, в скобках после имени. Или 
			наоборот: писать номер (так как он есть всегда), а в скобках - имя (и тогда 
			пустые скобки будут означать отсутствие имени)</P>
		<P>15:30<BR>
			Фильтры сделаны. Мне не нравится, что при LowPass only я получаю резкие взбрыки 
			в начале...<BR>
			Выход виден (и здесь он виден лучше) - при LP игреки нужно приравнивать не 
			нулю, а начальному значению... То же сделаем и в осцилле.</P>
		<P>16:23<BR>
			С активацией проблем вроде бы нет... Есть проблемы с закрытием снэпшотов. И с 
			начальным выбором коэффициентов.</P>
		<P>16:26<BR>
			Выбор коэфф. при инициализации. Но нужно еще эту инициализацию провести! Она же 
			у меня по запуску - а новый снэпшот может быть открыт на лету....</P>
		<P>16:29<BR>
			Сделано - посылаем инит-сообщение при открытии нового вида. Вроде бы ничему не 
			мешает...</P>
		<P>Вроде бы список TODO пройден. Чекин. Обедаем - и за файл....</P>
		<P>------------------------- чекин 
			---------------------------------------------------</P>
		<P>17:30<BR>
			Сделана отдельная иконка для снэпшота.</P>
		<P>19:30<BR>
			Взялся за файл - и завис на ровном месте. Видимо, это все-таки нездоровье... 
			Ситуация-то простая: заголовок должен быть динамическим - в том смысле, что в 
			нем содержится 10 по-канальных полей (причем идут сначала поля, а уже внутри 
			них - каналы). Было бы здорово вспомнить, как я нечто подобное сооружал... или 
			не нужно этого делать: для реальной работы мне все равно понадобиться 
			"числовой" заголовок, а не алфавитный? Тогда достаточно будет уже сооруженной 
			структуры, из которой должно вытекать необходимое количество каналов - и сам 
			размер текстового буфера для чтения всего заголовка. Ну и для записи - тоже....</P>
		<P>19:50<BR>
			Добавил к табам диалогов соотв. иконки, заодно и их поменял - сделал темным 
			фон.</P>
		<P>20:04<BR>
			Но в то же время я бы не хотел заниматься заполнением этого текстового буфера в 
			тот момент, когда понадобится его записывать....<BR>
			Наверное, нужна какая-то комбинированная структура... Чтобы там и числа были, и 
			алфавитный заполняемый буфер....</P>
		<P>21:25<BR>
			Примерное решение найдено, и выглядит где-то так:<BR>
			&nbsp;&nbsp; char *pB = new char[400];
			<BR>
			&nbsp;&nbsp; int nChan = 5;
			<BR>
			&nbsp;&nbsp; char (*ppC)[80] = new(pB) char[nChan][80];
			<BR>
			При этом "подстроки" оказываются правильно распределены по массиву.... Вот бы 
			еще со всеми ними скопом так же.....</P>
		<P>--------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050603 пт<BR>
			</STRONG>Снова встал с трудом. Отправлися за птичками (благо солнце) - но 
			безуспешно: мое настроение оказалось сильнее окружающего, ничего не снял....</P>
		<P>16:20<BR>
			Так чего же я хочу? Каким-то образом попроще да поавтоматичнее заполнять 
			текстовый заголовок - и столь же просто его читать. Очень хотелось бы и в том, 
			и в другом случае для этого использовать конструктор и перегрузку оператора 
			new. То есть класс должен иметь в себе пул, если&nbsp;конструктор идет без 
			адреса, выделяется новый пул, обнуляется - и все поля распределяются по нему. 
			Если в конструкторе указывается адрес - то это адрес прочитанного заголовка, 
			пул выставляется на него, и снова "раскидываются" все поля...</P>
		<P>19:26<BR>
			Ну-с, читать заголовок я научился :) А что я с этим должен сделать???? Мне 
			нужно:<BR>
			- построить список каналов<BR>
			- сложить куда-то имена каналов<BR>
			- определить канальные частоты<BR>
			- определить длину ЗАПИСИ (как сумма длин всех каналов)<BR>
			- установить "базу" чтения</P>
		<P>21:00<BR>
			Доделаны тулбар (под открытие-закрытие), нужно еще меню. Ф-ия открытия 
			перенесена в файл, но пока она ничего не делает...</P>
		<P>---------</P>
		<P><STRONG>050606 пн<BR>
			</STRONG>Cуббота ушла на упаковку коробок для МБС, воскресенье - огород, 
			выкашивание травы под дождем. Осело две мысли:<BR>
			- просто с переопределением new я могу и напортачить: место под сам класс мне 
			нужно<BR>
			- для нормальной работы с проихвольными файлами CSnapView должен уметь работать 
			со сколь угодно разными каналами</P>
		<P>13:55<BR>
			По первому пункту я беспокоился напрасно - никаких new я и не переопределял, 
			буфер задается и используется в конструкторе заголовка, и это именно буфер под 
			заголовок.</P>
		<P>Второй же вопрос в очередной раз приводит к необходимости одинаковой длины всех 
			реферируемых каналов (и биполяров)! В самом деле, я никак не могу складывать и 
			вычитать каналы, имеющие разную длину.... Так что пока все останется как 
			есть....</P>
		<P>14:53<BR>
			Итак, после открытия файла я должен ИЗ НЕГО получить всю ту информацию, к-ую 
			обычно получал из своих установок. Это:<BR>
			- "главная карта" - пристутствующие каналы<BR>
			- параметры каналов (частота, длительность, длина, пре- и посттриг - А ОТКУДА Я 
			ИХ ВОЗЬМУ???)<BR>
			---------<BR>
			Поехал в Универсалприбор за осциллом. Нашли ошибку в доверенности, развернули. 
			Зашел в ФотоМагию, купил монопод с головкой. К работе больше не возвращался :(</P>
		<P>------------------------------------------------------------------------------------</P>
		<P><STRONG>050607 вт<BR>
			</STRONG>Вроде и не хотел, но увидел солнышко - пошел опробовать монопод. 
			Времени было мало, так что толком ничего не дождался - но один практически 
			резкий кадр получил. И это при выдержке 1/60 !!!</P>
		<P>14:53<BR>
			Файлы с разной частотой дискретизации мне пока придется отклонять - просто нет 
			информации для принятия решения о том, что с ними делать.
			<BR>
			Вопрос с именами каналов: вид берет их из диалога, диалог - получает при 
			создании, в CMainFrame::OnSnapNew , путем вызова
			<BR>
			&nbsp; pNewDlg-&gt;SetMainMap(m_pFileMap, m_LeftDlg.GetChanNames());&nbsp;
			<BR>
			&nbsp; pNewDlg-&gt;SetNofChans(m_nChans,m_nExtChans);<BR>
			Получается, что все это (и имена, и кол-во каналов) мне нужно брать из 
			файла.... А для этого они должны в "файл" попасть - даже в случае создания 
			нового!!! Для этого придется изменить ф-ию CDataFile::FillMap, она должна будет 
			получать количества каналов (основных и EXT), собственно карту - и адрес 
			массива имен....</P>
		<P>15:54<BR>
			Передачу имен организовал. Пришлось отказаться от константности указателя на 
			имена (в итоге это все доходит до карты, в том числе - главной, а там указатель 
			уже не константый). При тригвводе получил вылеты :((((</P>
		<P>18:01<BR>
			После отвлечения на ЛБ-MatLab-EEGLAB (но еще до обеда): моя основная проблема 
			оказалась в том, что я попытался брать длину из передаваемого "рабочего" 
			массива каналов напрямую. А там длина не та, там длина - "потребяемая", с 
			запасом... Вот и получалось черт-те-что... Тем не менее, считать в виде считаю 
			неправильным. Можно ли как-нибудь взять из файла???</P>
		<P>Проверка показывает, что при инициализации CSnapView параметр 
			(CSimpleArray&lt;_ChanW&gt;*)wParam; используется только для:<BR>
			- определения общего числа каналов<BR>
			- определения длин (через частоту)<BR>
			- определения номера канала<BR>
			Наверное, все это можно получить и из файлового списка...<BR>
			Отправляется это сообщение всего из двух мест - OnRunGo() и OnSnapNew()</P>
		<P>21:43<BR>
			Исправления не доделал!!! Так и не решил, что же мне нужно передавать в вид - 
			адрес файла или конкретно массива....</P>
		<P>----------------------------------------------------------------</P>
		<P><STRONG>050608 ср<BR>
			</STRONG>Еле встал, еле доехал до работы - и все равно сонный.....</P>
		<P>Однозначно: снэпшот должен быть связан прежде всего с файлом! И связан должен 
			быть настолько жестко, что "файл" можно указывать даже в конструкторе</P>
		<P>Никак не могу разобраться: у меня получается две "инициализирующие" функции 
			файла : OnFileInit и FillMap. Причем обе они вызываются из OnRunGo() - но в 
			разных местах оной. И по-разному между ними вклиниваются ф-ии инициализации 
			снэпшота. Надо с этим что-то делать.... Итак:<BR>
			- FillMap только устанавливает количества каналов и заполняет карту<BR>
			- создание нового снэпа (если ни одного не было)<BR>
			- CSnapDlg::SetNrOfChannels<BR>
			- FileInit собственно формирует массивы (исходя из полученного списка "рабочих" 
			каналов")<BR>
			- SnapInit<BR>
		</P>
		<P>21:13<BR>
			Нет, я все-таки совсем запутался с нумерацией каналов.
			<BR>
			- В "рабочем" списке хранятся "номера" (реально - смещения) в ПОЛУЧАЕМОМ потоке 
			(0 или 1 для триггера, 2 - для нулевого канала - и так далее, включая EXT)<BR>
			- для карты нужно каналы, имеющие номера со 2 по кол-во пинов сделать -2, для 
			бОльших - -nPins + 256<BR>
			- хранить нужно то же, что для карты!!!</P>
		<P>21:52<BR>
			Выкрутился путем сохранения в рабочем массиве не только "номера-смещения", но и 
			основного номера канала ("карточного", с -1 для триггера). Можно бы и 
			дальше.... Но поздно уже -
			<BR>
			------------------------------------------------- чекин 
			--------------------------------------------</P>
		<P><STRONG>050609 чт</STRONG></P>
		<P>14:32<BR>
			Собственно, мне уже параметр (LPARAM)(&amp;m_atrParams) в сообщении 
			WM_DIZ_SHAPINIT и не нужен. Это хорошо, SnapView у меня становится независимым 
			от главного окна - берет все параметры из файла. Но! Для диалога тоже что-то 
			такое нужно...</P>
		<P>15:30<BR>
			Продолжаем упрощать. В файле (и CSnapView) количества пин- и экст-каналов мне 
			не нужны!!!</P>
		<P>15:37<BR>
			Вообще-то у меня в классе _ChanW место под имя канала отведено (32 байта) - но 
			никак не используется!!! А если все-таки пользовать? Может быть легче будет???<BR>
			В заголовке под метку канала отведено 16 байт. Соответственно, мне должно 
			хватить 24 для того, чтобы можно было сохранить как "номер" (A1-A32, EXT1-EXT8 
			etc), так и "метку". Но для того мне нужно отследить всю "траекторию" 
			использования этих имен и меток...</P>
		<P>16:44<BR>
			Так, в списке имена присутствуют... А дальше?<BR>
			- CSnapVeiw берет имена из pDispMap<BR>
			- там она устанавливается ф-ией CDlgView::SetMainMap(m_pFileMap, 
			m_File.GetChanNames());</P>
		<P>21:24<BR>
			Делаю перенос имен в файловый массив из списка. Не срабатывает для EXT. И вновь 
			пошли какие-то перекосы с отображением вновь всключаемых экстов....</P>
		<P>21:45<BR>
			В общем, вроде бы как-то механизм передачи, ТОЛЬКО через список работает, НО!
			<BR>
			1) Непонятно, чтоможно передавать, если не прошла инициализация файла (а она - 
			только при запуске)<BR>
			2) При этом никак не отзванивается изменение смещений (нужно его передавать и в 
			файл тоже!!!)</P>
		<P>Тогда получается, что Файл имеет свою карту только при чтении. При вводе он 
			должен ссылаться на главную карту приложения!!!!</P>
		<P>---------------------------------------------------</P>
		<P><STRONG>050610 пт<BR>
			</STRONG>Нет, со снэповскими картами нужно по-другому! Ссылка на главную - 
			бессмысленна. Лучше уж насчитывать среднее смещение за потребленное время<BR>
			И еще - нужно обзавестись отдельным цветом для "отсутствующих данных" (в 
			главной карте - до включения аппарата, в файловой - до прихода первого фрейма).</P>
		<P>14:58<BR>
			Для осуществления вышесказанного (номер 2 - включенная карта при отс. данных) 
			все карты меняют тип с UCHAR на char - массовые изменения....</P>
		<P>15:15<BR>
			Заведен доп. цвет _Settings::m_colorOffsetNone, возвращаемый при -1<BR>
			При включении каждая клетка получает -1</P>
		<P>16:50<BR>
			Как-то сделал, есть ощущение "не того". Но оно связано и с поведением программы 
			при отсутствии сигнала от девайса... Сейчас я "скидываю и запрещаю" главную 
			карту. А нужно было бы - ставить её в -1. И не зпрещать кол-во модулей и 
			тачпруфов....</P>
		<P>18:27<BR>
			Сделал "синенькие" - включая переход в "не-режим" при выключении девайса. Нужно<BR>
			- изменение этого цвета в диалоге<BR>
			- не то со снэпдиалогом</P>
		<P><BR>
			-------------------------------------------------------------------</P>
		<P><STRONG>050611 сб</STRONG></P>
		<P>15:52<BR>
			Первая проблема (не та карта в снэпшоте) объяснялась тем, что при начальной 
			инициализации не устанавливалась мэйнфреймовская переменная m_pFileMap. вторая 
			(вылеты при повторном создании любого дочернего окна после уничтожения всех) - 
			введением иконок: я при закрытии последнего окна уничтожал m_tabbedChildWindow, 
			а снова его не создавал...</P>
		<P>Сейчас видны следующие проблемы:<BR>
			- не уничтожается один из списков меток<BR>
			- проблемы при закрытии не-первого осцилла</P>
		<P>16:42<BR>
			Не уничтожался список меток файла. Проблемы с закрытием осцилла отловить не 
			удается :( А "ошибки" в распределении памяти - артефакт расстановки соотв. 
			меток....</P>
		<P>16:48<BR>
			изменения в основной карте нужно обозначать и в снэпшотовых - ежели таковые 
			произошли....</P>
		<P>У меня что-то не то с подсчетом каналов в снэпвью.</P>
		<P>17:55
			<BR>
			Долго не мог понять, что у меня происходит с цветами каналов снэпшота. Выяснил: 
			в нём я решил идти циклом поВСЕМ каналам (как отображаемым, так и нет) - чтобы 
			конкретный цвет остался зафиксированным за каналом... Вот и получилось....</P>
		<P>18:26<BR>
			Редактирование и использование цветов для недоступных и выключенных каналов, 
			отс. данных.</P>
		<P>19:03<BR>
			Сделал неотключаемыми контролы харддиалога (чтобы можно было устанавливать 
			желаемое при отсутствии харда или его выключенности). Непрятная новость: рваный 
			вывод при высоких частотах дискртизации. Причем и в релиз-сборке (старой, той 
			что послана) - тоже :(((</P>
		<P>19:22<BR>
			Перезагрузился, проверил - все то же самое... Но! Такого эффекта нет, если 
			включить децимацию. Ergo - эффект отображалки.... Пошел...</P>
		<P>---------------------------------</P>
		<P><STRONG>050614 вт<BR>
			</STRONG>Итак, нужно решить, что именно в каких режимах оторажать. Я про карту 
			устройства-файловую карту. Мне кажется, что при открытом файле вместо HardDlg 
			следует отображать информацию об этом файле - и, соответственно, его карту (без 
			возможности редактировать). Включение аппарата при этом никак не отображается 
			(ну или еще один "диодик"). Информация о файле - это его имя, кол-во записей и, 
			возможно, начальная информация из "локальных описаний". При этом имя файла 
			должно добавляться к имени главного окна программы!!!</P>
		<P>Но сразу попробуем решить и еще одну проблему: собственно образование из 
			открытого файла нужных для дальнейшей работы структур....</P>
		<P>14:08<BR>
			Все же не выдержал - вернулся к субботней проблеме с рваным рисованием. 
			Возникшая за выходные мысль: оно может быть вызвано большим временем, 
			проводимым "рисовательным" фрагментов с закрытой битмэп-секцией - ну и 
			"таймерная" просто не получает доступа к рисованию. Захотел попробовать - но 
			обнаружил, что из таймерной слишком много точек выхода (каждая - с 
			освобождением крит. секции). Модифицировал, поставив вместо возврата взведение 
			исключения. Пробуем.</P>
		<P>14:14<BR>
			Попробовал. Не помогает. Похоже, что множество исключений выбрасывается. Будем 
			исследовать.</P>
		<P>----------------------------------------</P>
		<P><STRONG>050615 ср</STRONG></P>
		<P>Можно так сказать, что сутки над проблемой просидел... Ну и что??? Сущность 
			проблемы ясна: при высокой частоте дискретизации поток слишком много времени 
			проводит в построении линий - и на отрисовку его просто не хватает... Отсюда - 
			и рваность вывода<BR>
			Попробовал вернуться к мультимедийному таймеру для осцилла - не получилось 
			совсем ничего: явный уход в дедлоки... Да и в принципе это ничего дать не 
			может: ВСЕ мультимедийные таймеры живут в ОДНОМ потоке, так что кроме мешанины 
			я ничего не получу... "Промежуточный" вариант (пересылка сообщения от 
			ММ-таймера граф. потоку) тоже не помогает :((( Так что приходится возвращаться 
			к старому-доброму WM_TIMER. Единственное, что я здесь сделал - это заместил его 
			на WM_DIZ_WTIMER в надежде, что таковое сообщение отвергаться потоком уже не 
			будет. Но и это несущественно. Покамест помогла только усиленная оптимизация 
			данной функции - вроде бы с ней (с оптимизацией) и в релиз-сборке дерганий не 
			наблюдается....<BR>
			<BR>
			16:13<BR>
			Но зато наблюдаются:<BR>
			<FONT color="#990000"><STRONG><FONT color="#000099">- перекосы окна при 
						включении-выключении отображения тригканала</FONT><BR>
					<FONT color="#000099">- не создается (а точнее - тут же удаляется) осцилл, вновь 
						создаваемый в процессе ввода.....</FONT></STRONG></FONT></P>
		<P>Будем разбираться</P>
		<P>16:16<BR>
			С первым все вроде бы просто: я почему-то не посылал осциллам сообщением 
			WM_DIZ_MAPCHANGED. Но!!! При повторных включениях-выключениях - тот же самый 
			"вылет" (самозакрытие окна). Черт, откуда оно может взяться???</P>
		<P>17:42<BR>
			Разобрался. Сообщение, конечно же, посылать не нужно. А переосы возникают из-за 
			того, что при отсутствии тригзоны не инкрементировался счетчик тригканала - ну 
			и, соответственно, после включения он оказывался неизвестно где....</P>
		<P>17:50<BR>
			C вылетами осцилла тоже понятно: ему не устанавливалась частота... А вот 
			почему??? Я ведь вроде эту проблему уже решал....<BR>
			Правильно!!! Раньше работало, потому что по умолчанию m_nFrq = 2048 - вот 
			только при этой частоте и работало....</P>
		<P>21:00<BR>
			Активно проведенный вечер:<BR>
			- изменения в CHardDlg:<BR>
			&nbsp; - Если нет драйверов, ничего не отображаем, кроме соотв надписи<BR>
			&nbsp; - Новая кнопка - сигнал о включении-выключении питания
			<BR>
			&nbsp; - кнопковидное окошко с информацией о файле, перекрывающей все остальное 
			(кроме индикатора питания)</P>
		<P>- изменения в CDataFile::Open - первые попытки чтения реальных параметров, ф-ии 
			экспорта этих данных</P>
		<P>-----------------------------------------------------------------------------</P>
		<P><STRONG>050616 чт</STRONG></P>
		<P>13:40<BR>
			Изменения в алогритме считывания параметров: текстовые поля могут не иметь 
			нулевых окочаний (т.е. могут смыкаться), поэтому необходимо принудительное 
			преобразование в CString</P>
		<P>14:40<BR>
			Если драйверов нет, то после закрытия файла основные контролы диалога не 
			показываются.</P>
		<P>//отошел от дел: занялся записью своих фотографий. Подготовил и скинул все 
			старые (с 2001 года начиная) - плюс кэноновские за декабрь 2004- январь 2005, 
			то есть первый диск. И больше ничего...</P>
		<P>-------------------------------------------------------</P>
		<P><STRONG>050617 пт<BR>
			</STRONG>Все то же самое: продолжил обработку фотографий. Второй диск - 
			февраль-апрель 2005 года. Сейчас пишется второй экземпляр, а первый в это время 
			проверяю на чтение.</P>
		<P>15:55<BR>
			При открытом на чтение файле мне нужно запретить кнопки "новый осц", "Run", 
			"Pause". Более того, при открытии файла все текущие окна должны быть закрыты!!! 
			Видимо, для этого "файл" должен возвращать некий код (не только есть файл или 
			нет - но и открыт ли он на запись или чтение).</P>
		<P>19:16<BR>
			- Заведены переменная и функция кода файла
			<BR>
			- закрытие всех окон перед открытием файла, при закрытии файла<BR>
			- подправлена логика разрешения команд<BR>
			- закрытие всех окон реализовано через RemoveOsc()<BR>
			- Перед закрытием программы закрываем файл</P>
		<P>19:20<BR>
			При открытии файла главная карта запрещается Но!!! Она и ссылаться должна на 
			файловую карту - а я таковую даже не строю пока...</P>
		<P>Вечером занялся... Уже не помню, чем :) Да, видимо стал разбираться с видимостью 
			"левых диалогов" - ведь получается, что при чтении файла (и вообще в случае 
			отсутствия драйверов) они мне и не нужны... И тогда посетила мысль: а нельзя ли 
			задействовать для индикации состояния питания (ну и батарей с CMS заодно) 
			статус бар??? После чего отвлекся на пришедшее от Нади письмо - ну и забросил 
			это дело (сначала письмо раскодировал, потом на него отвечал). Дома продолжил 
			отвечать - но после все же вернулся к проблеме: первые попытки показали, что со 
			статус-баром управляться можно...</P>
		<P>-------------------------------------------------------------------------------------------------------------------------------</P>
		<P><STRONG>050618 сб<BR>
			</STRONG>Утром в очередной раз поснимал воробьев у Московской. Вроде бы и 
			удачно (застал очень подходящую семейку, и на хорошем месте) - но по-настоящему 
			удачного кадра нет: все не те ракурсы. Больше нужно было снимать, больше....</P>
		<P>13:00<BR>
			На работе вплоную занялся статусбаром. Скачал чью-то программку, в нем элементы 
			меняющую, но ей пользоваться не стал. Сначала игрался с "исходным" 
			CMultiPaneStatusBarCtrl, потом произвел от него свой класс, потом - уже совсем 
			настоящий класс
			<BR>
			class CDizStatusBar : public CMultiPaneStatusBarCtrlImpl<BR>
			Получалось все далеко не сразу, но наконец...</P>
		<P>17:00<BR>
			Мой статус-бар работает - и отображает все, что нужно. Так что теперь нужно<BR>
			- убрать кнопку "питание" из харддиалога<BR>
			- убирать все левые диалоги при отсутствии драйверов или открытии файла на 
			чтение<BR>
			- при открытии файла на чтение подставлять вместо них окошко с информацией о 
			файле.</P>
		<P>17:26<BR>
			Индикаторы Power иFile&nbsp; из хард-диалога убраны. Теперь мне нужно решить, 
			что и каким образом сажать на место левых диалогов при отсутствии драйверов - и 
			при чтении файла. Пожалуй, я попробую поступить следующим образом: создам одну 
			на всё инфо-панель с единственным текстовым полем - а уж заполняться оно будет 
			как-нибудь потом...</P>
		<P>18:03<BR>
			Новый класс CInfoPanel создан, панель в нем заполняется (сейчас - также, как 
			вчера делал в харддиалоге), по умолчанию она сообщает об отсутствии драйвров. 
			Теперь мне нужно понять, как поступить с показом этой панели в случае 
			отсутствия драйверов (и что делать при закрытии файла).</P>
		<P>18;14<BR>
			Инфо-панель действительно сделана - и ведет себя именно так, как мне хотелось. 
			А вот с разрешением кнопок - опять проблемы: почему-то при отсутствии драйверов 
			оказываются разрешены запуск и создание новых окон...</P>
		<P>18:47<BR>
			Логику разрешения команд тоже подправил.</P>
		<CDIZSTATUSBAR>
			<P>19:56<BR>
				Первые шаги по расшифровке имен каналов. Вроде бы карту получаю адекватную. А 
				имена мне все равно брать неоткуда :)</P>
			<P>Ладно, наверное таки на этом - завершим....</P>
			<P>---------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050620 пн<BR>
				</STRONG>В ходе воскресного окучивания картошки понял, чего я хочу: избавиться 
				от разделения левой части и от CLeftDlg вообще: сделать "основную карту" частью 
				CHardDlg, сделать последний resisable - и поместить итоговый диалог на таб. При 
				этом в ту же зону (но на другие табы) будут помещаться окно с информацией о 
				файле и списко записей. Видимо,на последних двух придется сделать уменьшенную 
				(и read-only) версию карты - для сохранения условия постоянного наблюдения за 
				качеством каналов.</P>
			<P>12:30<BR>
				Первое достаточно успешное перемещение карты в CHardDlg, отмена CLeftDlg</P>
			<P>13:16<BR>
				Устранено разбиение левой панели. Теперь нужно сделать табы....</P>
			<P>15:05<BR>
				Уфф, вроде бы и карта из файла считывается нормально....</P>
			<P>15:35<BR>
				Уже полчаса борюсь с двумя проблемами харддиалога:<BR>
				- изменине кол-ва модулей при выключенном харде приводит к позеленению кнопочек<BR>
				- первое выключение тачпруфов при выклчюенном харде дизеблит их.</P>
			<P><STRONG>---- + 050621 вт</STRONG></P>
			<P>В ходе разборок навыяснялось много интересного...
				<BR>
			</P>
			<P>Для начала - озаботалися "бряканием" программы при запуске. Один из его 
				источников - некорректная обработка сообщений статусбаром (вызываемые 
				обработчиками функции на самом деле посылали те же самые сообщения, что в итоге 
				приводило к переполнению стека). Другой... Другой вообще оказался скрыт в 
				недрах взаимодействия системы с матрасовскими средствами восстановления 
				положения окон: такой бряк появляется у любой программы с составным статусбаром 
				и вызывается тем, что в какой -то момент такой статусбар в ответ на GetParts 
				(SB_GETPARTS) возвращает 0... Было "вылечено" самостоятельным восстановлением 
				положения окна (SetWindowPlacement/GetWindowPlacement). Но при этом, похоже, не 
				вполне корректно отрабатывается "статус" окна (то есть было ли оно 
				максимизировано или нормально)</P>
			<P>------------------------------------------------------------------------------------------------------<BR>
				<STRONG>050622 ср<BR>
				</STRONG>Но это было еще не всё... Попутно выяснилось, что<BR>
				- при отсутствии конфигов программа на ввод запускаться не хочет<BR>
				- при большом количестве открытых дочерних окон, если некторые из них находятся 
				за пределами основного, программа виснет и при закрытии... Ох и муторные 
				разборки :(((</P>
			<P>15:20<BR>
				Некорректность при запуске вызывалась неинициализированными переменными 
				m_nDisp&nbsp;и&nbsp;m_nRef в CDlgView - при запуске ранее не запускавшейся 
				программы они имели отрицательные значения, ну и память, естественно, не 
				выделялась</P>
			<P>16:00<BR>
				Продолжаем борьбу со статусбаром: все же стандартный текст выводить тоже 
				хочется.... Задача решена расширением обработки сообщения SB_SETSIMPLE: при 
				переходе в "простой" режим (для вывода сообщения-подсказки) прячутся все 
				дочерние окна...</P>
			<P>18:00<BR>
				Самая непростая из перечисленных - проблема с закрытием окошек... Вроде бы все 
				делается честно - но.... В итоге чисто эксппериментальным путем установлено, 
				что наиболее стабильно работает такой механизм:<BR>
				&nbsp;&nbsp;&nbsp; int N = m_arpDialog.GetSize();
				<BR>
				<FONT color="#3300cc">&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; N; i++)&nbsp;<BR>
					&nbsp;&nbsp;&nbsp;{
					<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveOsc(0);
					<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sleep(200);
					<BR>
					&nbsp;&nbsp;&nbsp; }<BR>
				</FONT>Хотя&nbsp;почему лучше работает именно он (и будет ли он работать 
				всегда) я не знаю :(((</P>
			<P>&nbsp;19:10<BR>
				Аналонгично нужно поступать и в других местах, где закрываются все окна (перед 
				открытием файла, при закрытии файла)<BR>
				<STRONG><FONT color="#000099">При открытом файле получаю "пустые" снэп-диалоги (нулевое 
						кол-во каналов). Почему???<BR>
						Закрыть файл не удается...</FONT></STRONG></P>
			<P>Ищем дальше....</P>
			<P>20:10<BR>
				Первое очень похоже на недоработку (отвлекся на тулбар, переделку левой 
				панели)???? Вроде исправлено. А закрытие файла - очень смахивает на то же, что 
				наблюдалось ранее... Причем иногда закртыие таки происходит - спустя немалое 
				время....</P>
			<P>20:40<BR>
				Боролся с утечками памяти - недотирал образованные хедеры....</P>
			<P>20:50<BR>
				Открытие снэпов - просто мрак: первые еще кое-как, второй&nbsp; - уже никак 
				(при открытом на чтение файле)....</P>
			<P>21:00<BR>
				Таак.... Я теперь вообще не понимаю, как у меня происходит создание снэпов: вид 
				просто не успеват создаться - а уже хочет диалог...</P>
			<P>21:45<BR>
				Проблема, как всегда, оказалась в не тех переменных: при открытии файла я не 
				инициализировал переменные m_nChLen и m_nTrLen, в итоге получал требование на 
				выделение памяти безмерной длины (под гиг) - вот второй снэп и не создавался. 
				Подправил. Создаются. Но голова - уже вообще никакая... Пошел...</P>
			<P>-----------------------------------------------------------<BR>
				<STRONG>050623 чт</STRONG></P>
			<P>Чтобы избавиться от проблем с запрещением закрытия первого снэпа, разрешу их 
				открывать только при открытом файле (а открытие или создание файла само будет 
				созадвать первый снэп). При попытке закрытия первого снэпа будем спрашивать, 
				закрыать ли файл.</P>
			<P>21:50<BR>
				Сделал - и снова напоролся... Рассказывать долго - допишу дома...</P>
			<P>---------------------------------------------------------------------------------<BR>
				<STRONG>050624 пт<BR>
				</STRONG>Дома не поулчилось :) Пишу на работе.<BR>
				Напопролся, в очередной раз, на незакрытие дочернего окна: диалог посылает 
				граф. потоку сообщение WM_QUIT - но поток его не ловит... Где только не 
				смотрел, с чем только не игрался - всё одно... В итоге точно выяснил, что 
				прблема возникает ТОЛЬКО если закрытие вызвается кнопкой в окошке вида (и не 
				возникает при нажатии аналогичной кнопке диалога либо команде закрытия файла). 
				При включении отладочных трейс-сообщений в соотв. ф-ии (<FONT color="#000099">CActDView::OnNcLButtonDown</FONT>) 
				проблема исчезала - но только в режиме отладки. В итоге обошелся установкой 
				разнообразных задержек - но не нравится мне это: может оказаться специфичным по 
				отношению к компьютеру, системам - и еще бог знает чему....</P>
			<P>13:20<BR>
				Альтернативный метод: в вышеупомянутой ф-ии <FONT color="#000099">CActDView::OnNcLButtonDown</FONT>
				сам анализирую на флаг <FONT color="#000099">HTCLOSE</FONT> и делаю то, что 
				нужно - <FONT color="#000099">::PostMessage(m_hFrame,WM_DIZ_VIEW_CLOSE,0,(DWORD)this);</FONT>
				Похоже, что так срабатывает безо всяких задержек...</P>
			<P>13:25<BR>
				Да, в таком варианте задержки становятся не нужны даже в "главной функции"!!!!</P>
			<P>15:27<BR>
				Преотвращения ненужных отрисовок снэпшота при отсутствующих данных. Заливка 
				дефолтовым цветом</P>
			<P>18:45<BR>
				После долгих-долгих мытарств - первая отрисовка данных из прочитанного файла!!!</P>
			<P>19:15<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">В BDF-файлах триггер идет последним, а 
							не первым!!!<BR>
						</FONT><FONT color="#000099">Коэффициенты не переустанавливаются....<BR>
						</FONT></FONT><FONT color="#000099">Если открыто более одного снэпшота, файл не 
						закрывается...</FONT></STRONG></P>
			<P>19:20<BR>
				Неотклик на коэффициенты был обязан тому, что мейнфрейм не возвращал файловую 
				частоту.</P>
			<P>19:44<BR>
				Попытка более интеллектуальной передачи номеров каналов виду... Теперь вроде бы 
				все правильно - но проверить можно будет только в реале...</P>
			<P>20:10<BR>
				Тааак... У меня же теперь все не-первые окна не закрываются :((((<BR>
				Пришлось снова поставить Sleep(200) - теперь закрыаются....<BR>
				Еще одна проблема - что делать с "дублированными" каналами (ActiView может 
				записывать один канал несколько раз, и с Варягиной именно это и получилось)</P>
			<P>20:25<BR>
				Отсекаю дублирующиеся каналы при открытии файла. Но, видимо, мне нужно и 
				первоначальное число хранить - и сообщать....</P>
			<P>20:31<BR>
				Сохранение и возвращение разного кол-ва каналов (записанных и уникальных)</P>
			<P>Теперь нужно:<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">- Передать кол-во записей диалогу<BR>
							- в диалоге обрабатывать изменение текущей записи<BR>
						</FONT></FONT><FONT color="#000099">- список записей (пока - простой)&nbsp; 
						//050701</FONT></STRONG></P>
			<P>попробуем... Но уже не сегодня....</P>
			<P>------------------------------------------------------------------------------</P>
			<P><STRONG>050625 сб</STRONG></P>
			<P>14:18<BR>
				После долгой борьбы с константностью (фреймы и файлы - константные указатели, а 
				не указатели на константы!!!) таки добился переключения записей в диалоге. 
				Теперь нужно:<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">- отображать в виде номер текущей 
							записи<BR>
						</FONT></FONT><FONT color="#000099">- переиначить ф-ию чтения (лучше, если она 
						сходу будет считывать в вызывающий буфер, и без перекоса основных указателей)<BR>
					</FONT><FONT color="#000099">- обрабатывать ручное изменение едит-бокса<BR>
					</FONT></STRONG>перекур</P>
			<P>14:55<BR>
				Обработка ручного ввода номера записи</P>
			<P>15:18<BR>
				Обработка клавиш для перехода между записями.</P>
			<P>15:24<BR>
				Дополнительное поле в указателе - номер записи. Отображение номера записи.</P>
			<P>17:26<BR>
				Бездну времени провел - никак ничего не рисовалось :((( Похоже, что проблема 
				вчерашняя: триггер идет не первым, а последним в списке файловых каналов. Но 
				как же тогда я рисовал вчера вечером-сегодня утром?????</P>
			<P>--------------------------------------------------------------------------------------------</P>
			<P><STRONG>050627 пн</STRONG></P>
			<P>Ладно, почему работало - дело все-таки десятое. Не должно было. В любом случае 
				там ошибка - и более того, непонимание. Ведь в CSnapView я хочу список (и 
				количество) отображаемых АНАЛОГОВЫХ каналов - а файл предоставляет мне ОБЩИЙ 
				СПИСОК, в котором на ЛЮБОМ месте могут оказаться триггер, аннотации - и вообще 
				черт в ступе....</P>
			<P>&nbsp;Во-первых, CSnapView::m_nChanNum - должен содержать кол-во АНАЛОГОВЫХ 
				каналов заполняется в<BR>
				- CSnapView::OnSnapInit() - m_nChanNum = m_pFile-&gt;GetNumOfChans() - 1; 
				//нуждается в замене, тк может быть отнюдь не -1...<BR>
				К счастью, это - единственное место, где это кол-во определяется. Но, видимо, 
				ему в дополнение нужно и общее кол-во записанных (записываемых) каналов...<BR>
				- Сама CSnapView::OnSnapInit() вызывается в путем отправки соотв. сообщений из 
				OnRunGo OnSnapNew (обе- в CMainFrame)</P>
			<P>13:51<BR>
				Для "более общего варианта" мне нужен будет преобразователь номеров каналов - 
				по аналогии с уже имеющимся m_pnChanNums - для того, чтобы аналогвые циклы (так 
				же как и тригканал) брать "прямо" из входного буфера.</P>
			<P>14:45<BR>
				Файловая ф-ия уже возвращает два разных числа:<BR>
				int GetNumOfChans(bool bReal = true) const
				<BR>
				{
				<BR>
				&nbsp;&nbsp; return (bReal) ? m_nChanNum:m_nRecordedChans;
				<BR>
				}<BR>
				Вопрос в том, что же там такое m_nChanNum???</P>
			<P>Берется она в ф-ии FileInit как m_nChanNum = parChanW-&gt;GetSize(); и при 
				открытии файла - как число неповторяемых каналов. Но возникает вопрос: 
				включается ли сюда триггер??? Попробуем... Да, получается что включает...</P>
			<P>15:17<BR>
				И в файле, и в виде соотв. "файловые" списки переимнованы в m_pFChans<BR>
				В самом деле: зачем мне держать в файле триггерный канал вместе со всеми 
				остальными??? Может быть, выделить его отдельно? Ведь он же - отдельный....</P>
			<P>17:09<BR>
				Вообще-то что-то непонятное было с частотами: при записи нового файла как 
				"основная" почему-то запоминалась триггерная частота - если я ничего не 
				путаю.... Нужно быть готовым к неожиданностям.</P>
			<P>18:30<BR>
				Осложнил задачу: выделил в файле триггер в отдельный канал (отделил его от 
				аналоговых). Но это оказалось неудобно при записи: там-то я иду напропалую по 
				всем каналам... И без такового выделелния индексы просто совпадали - а 
				теперь... И что теперь делать???</P>
			<P>19:30<BR>
				Долго анализировал ситуацию... Вроде бы получается так, что я могу "засунуть" 
				блок, начинающий новый буфер, внутрь триггерного ифа (все равно таковое решение 
				может быть принято лишь на основании анализа тригканала).</P>
			<P>21:14<BR>
				Ну вот, как-то это дело вроде преобразовал. Но похоже, что на чтении с 
				тригканалом не то... Надо проверять....</P>
			<P>21:30<BR>
				Подправил (неправильно записывалось смещение). Ну вот ,теперь можно было бы 
				обобщить - и тестировать. Но не сегодня....</P>
			<P>---------------------------------------------------------------------------------------</P>
			<P><STRONG>050628 вт</STRONG></P>
			<P>14:00<BR>
				Больше часа на работе - и ни одной мысли в голове... Хотя все просто: мне 
				наконец нужно сформировать заголовок своего файла - и пробовать писать, после 
				чего - читать свои и "фирменные" файлы</P>
			<P>15:42<BR>
				Сделана заготовка "заголовочного диалога". Покамест ничего не обрабатывается и 
				не меняется. Не знаю, как присвоимть "дейтпикеру" английский язык....</P>
			<P>17:48<BR>
				Первое формирование самого главного заголовка. Создание файла.</P>
			<P>19:04<BR>
				Полный заголовок буду формировать в FileInit - вызывается она только при 
				запуске с новым файлом</P>
			<P>20:42<BR>
				После создания нового файла - вылеты: явно лезу куда-то не в ту память. Но:
				<BR>
				- Только в случае создания вида<BR>
				- Только если ДО ТОГО не было открытия файла на чтение.<BR>
				Ergo- что-то не инициализирую в файле....</P>
			<P>21:47<BR>
				Что-то победил - но далеко не... Проблема с переданной файлу картой остается: 
				что делать, если файл создан до включения - и после этого пошло изменение 
				основной карты??? И с прочими памятными вопросами нелегко....</P>
			<P>-------------------------------------------------------------------------------------------</P>
			<P><STRONG>050629 ср</STRONG></P>
			<P>Домашние эксперименты показали, что вылеты при изменении карты (при выключенном 
				девайсе) объясняются кривым поведением () при нулевом количестве каналов. 
				Отсюда следует два вывода:<BR>
				- Все же я хочу, чтобы при выключенном девайсе количество каналов в дочерних 
				диалогах и видах было не нулевым - а соответствовало заданному в харддиалоге<BR>
				- Во-вторых (но решать этот вопрос нужно первым) программа все же должна 
				работать и при нулевом кол-ве аналоговых каналов (возможно - с 
				предупреждением): мало ли кто захочет пользовать только триггер....</P>
			<P>Дома в итоге изменил принцип формирования списка фаловых каналов - вместо 
				"прямого массива" m_pFChans сделал CSimpleArray&lt;&gt; m_arFChans, это 
				позволяет заполнять массив без предварительного выяснения того, сколько же в 
				нем будет каналов. И вот тут-то и нарвался на ошибку при выделении памяти на 
				массив из одного инта... Сейчас проверил в отдельной программульке - вроде как 
				такая операция спокойно проходит.. Значит, дело не в этом...</P>
			<P>15:43<BR>
				Выяснил: неполадки с вызовом оператора new начинаются после использования 
				SetChanType()!!!</P>
			<P>17:34<BR>
				Эффект, конечно, потрясающий (видеть, как оператор new возвращает 0 - непонятно 
				почему....) - но источник прост: в заголовке поле Reserved имеет длину 32 
				символа, а в ф-ии копирования я засовывал в него 80... После исправления вроде 
				как всё OB.</P>
			<P>17:40<BR>
				Попытки записи без включенных каналов:<BR>
				- у осцилла рваный вывод - до изменения длины. Где-то что-то не передается....<BR>
				- Признаков записи нет....</P>
			<P>18:15<BR>
				С рваным выводом разобрался: диалог показывал уже после запуска таймера - и он 
				задерживал его обработку... Проверка и диалог перенесены в самое начало.</P>
			<P>19:05<BR>
				Отсутствие записи - это сложнее... Я же теперь насчитываю CDataFile::m_nChanNum 
				как кол-во АНАЛОГОВЫХ каналов - а в алгоритмах ввода оно считается как ВВОДИМЫХ 
				- то есть с учетом и триггера тоже... Вот и отлетаю - по разнице между 
				полученными и имеющимися....</P>
			<P>19:21<BR>
				Перевел все соотв циклы на записываеме каналы - все равно ничего.... Искал 
				долго: оказалось, я в карте вида сообщение WM_DIZ_SHAPNEW закомментировал :)) 
				Убрал комментарий - первый вью рисуется. Но - только первый....</P>
			<P>19:43<BR>
				Нет, не только первый - нарисовалось 6 штук. И - в глухой завис :(</P>
			<P>20:43<BR>
				Пока нашел только одну ошибку: попытку выделения памяти до должной 
				инициализации (в снэпвью, при отрицательной тригдлине). Какие там потоки 
				"кончают с собой" - соверешнно непонятно. Так же как и то, каким образом я 
				дохожу до...</P>
			<P>21:10<BR>
				Стало чуть легче: я обнулял счетчики не по всем каналам (все та же разница в 
				двойном наименовании). Более того, в отладочных целях поставил выделение памяти 
				под 50 :) Хорошо, что на бОльшем количестве не попробовал Е:)) Но все равно - 
				какие-то два потока прекращаются.... Хотя это, вроде бы, ничему не мешает...</P>
			<P>21:30<BR>
				При очередной попытке вроде почти все прошло удачно.<BR>
				Запуск без аналоговых каналов: тоже идет, но SnapView ничего не отображает - и 
				при выходе информация о двух утечках нулевой длины.<BR>
				--------------------------------- завершаем 
				--------------------------------------</P>
			<P><STRONG>050630 чт</STRONG></P>
			<P>14:24<BR>
				Записи в файл пока нет - однако команда "закрыть файл" не выполняется :((( 
				Боюсь - все по той же причине....</P>
			<P>14:50<BR>
				При открытии файла на чтение закрытие идет нормально. Были неполадки с 
				указателем на главное окно (CDataFile::m_pMainFrm) - но устранены, причем с 
				запасом:<BR>
				- инициализация в конструкторе<BR>
				- инициализирующая функция</P>
			<P>16:02<BR>
				Очередное решение наболевшей проблемы: диалог перед тем, как закрывать вид, 
				принудительно назначем ему родителем главное окно. Сделано из-за наблюдения: 
				зависы происходят (только с первым снэпом) только в случае, когда он 
				"свободен"....</P>
			<P>16:56<BR>
				После снятия в CSnapView двух проверок стало возможным отображение ввода без 
				аналоговых каналов.<BR>
				<STRONG><FONT color="#000099">Ближайшее TODO - правильная расстановка кнопок при 
						запуске (чтобы не было изначального разрешения).</FONT></STRONG></P>
			<P>17:40<BR>
				<STRONG><FONT color="#cc0066">Однако заметил: у меня все равно "пропадает" несколько 
						областей нулевой длины. Надо бы ликвидировать...</FONT></STRONG></P>
			<P><FONT color="#000000">18:05<BR>
					При запуске ВСЕГДА выключаю мануальный ввод, а при гейт-режиме - ставлю паузу.<BR>
					Разрешено закрытие нулевого снэпшота при отсутствующем файле (для теста 
					триггеров).<BR>
					Разрешить создание снэпшотов при текущем вводе в тригрежиме.</FONT></P>
			<P>18:08<BR>
				Угу. Вернемся к вопросу о картах: при создании снэпшота на лету получается 
				пустая...</P>
			<P>19:55<BR>
				Разобрался - при инициализации файла в нем не насчитывались соотв. количества 
				каналов, а при создании снэпшота ему не передавалась файловая карта. Сейчас 
				передается. Следующие задачи:<BR>
				<FONT color="#cc0066"><STRONG><FONT color="#000099">- Ненулевые карты при выключенно 
							девайсе (возможность предварительного заполнения)<BR>
						</FONT><FONT color="#000099">- насчет смещений в файле<BR>
						</FONT><FONT color="#000099">- странная отрисовка в файле (что-то не то с нулями на 
							коцне при тригвводе с претригом)</FONT></STRONG></FONT></P>
			<P>20:12<BR>
				Вроде бы с картами разобрался....</P>
			<P>20:37<BR>
				Со смещениями получается не так просто: если я хочу, чтобы в снэповых картах 
				отображались средние смещения по текущей записи - то и цвета должны браться не 
				из главной карты - а индивидуально. Но при этом главную карту я отменять не 
				могу :((( Получается, что придется делать еще одно ветвление в самом классе 
				карт - откуда брать цвета....</P>
			<P>21:22<BR>
				Перерасчет карт сделан!!! Теперь действительно считаю прямо в фрейме - и 
				отзваниваю в своем диалоге!!!</P>
			<P>На сегодня - хватит....</P>
			<P>-----------------------------------------------------------------------------------------</P>
			<P><STRONG>050701-home (00:40)</STRONG></P>
			<P>Одна небольшая косметичсеская добавка:&nbsp;в CSnapDlg введен CUpDownCtrl для 
				смены&nbsp;записей (невидимый); изменены и кнопки: на пред. реализацию смещают 
				кнопки влево и вверх, на следующую - вправо и вниз,&nbsp;PAGE_UP (VK_PRIOR) 
				теперь смещает на 8 записей назад, аPAGE_DOWN (VK_NEXT) - на 8&nbsp;записей 
				вперед (если когда-нибудь будут многозаписные виды - будут смещать на длину 
				экрана)</P>
			<P>050701 -&nbsp;фин</P>
			<P>11:53<BR>
				Ближайшие задачи:<BR>
				<STRONG><FONT color="#cc0066">-<FONT color="#000099"> реальная запись в файл<BR>
						</FONT><FONT color="#000099">- список<BR>
						</FONT></FONT><FONT color="#000099">- Locked &amp; Unlocked snapshots</FONT></STRONG></P>
			<P>13:22<BR>
				После долгих мытарств&nbsp;что-то в файл записалось - и он даже открылся... Но 
				внутри все совсем не то :(((</P>
			<P>15:16<BR>
				Ага, ошибка была в вычислении размеров записи (и смещений) при инициализации 
				файла. Смещения и размеры считаются в <STRONG><FONT color="#000099">int24</FONT></STRONG>!!! 
				Это означает, что "плюсовое" смещение равно <FONT color="#000099"><STRONG>64</STRONG></FONT>
				(а <STRONG><FONT color="#cc0066">не 64*3</FONT></STRONG> - вот источник 
				неполадок в конце), а&nbsp;писать нужно <STRONG><FONT color="#000099">m_nRecSize*3</FONT></STRONG>
				(там это в байтах).
			</P>
			<P>Файл записался и читается!!!
				<BR>
				<STRONG><FONT color="#000099">При чтении не отображаются данные реализации...</FONT></STRONG></P>
			<P>15:22<BR>
				Последняя проблема тоже решена - просто при чтении реализации нужно 
				в&nbsp;полученном принудительно устанавливать файловый флаг m_bPlus</P>
			<P>15:30<BR>
				Из старых воспоминаний: запрещение карты в CFInfoPanel....<BR>
				Начинаю создавать список....</P>
			<P>17:39<BR>
				Простой список формируется, на изменения реагирует, отрисовку во всех видах 
				производит....</P>
			<P>18:20<BR>
				Завис на разборе аннтоаций - а тут и вспомнил, что формируются они у меня до 
				сих пор не по-правилам, а по-правилам в них должны быть непечатные и нулевые 
				символы... А при наличии таковых уже и алгоритмы копирования должны быть 
				другими.... В частности, вообще непонятно - как мне формировать и копировать 
				строку, содержащую нули...</P>
			<P>19:40<BR>
				Ага, формирую вроде бы теперь то... Будем учиться разбирать сформированное....</P>
			<P>20:09<BR>
				Разбор при отображении фрейма (в виде) - простой:<BR>
				<FONT color="#000099">&nbsp;&nbsp; char *cp = (char*)pPointer-&gt;pBuf;&nbsp;<BR>
					&nbsp;&nbsp;&nbsp;while (*cp)
					<BR>
					&nbsp;&nbsp; {
					<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str += cp;
					<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str += " | ";
					<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp += strlen(cp);
					<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cp++;&nbsp;<BR>
					&nbsp;&nbsp;&nbsp;&nbsp;}
					<BR>
					&nbsp;&nbsp;&nbsp; str.Replace("\024"," ");
					<BR>
					&nbsp;&nbsp;&nbsp; str.Replace("\025"," "); </FONT>
			</P>
			<P>Для разбора списка нужно более сложное: Типом может быть как&nbsp;второе 
				значение первого поля - так и второе значение второго (в первом случае 
				-&nbsp;New/cnt, во втором - тип триггера)</P>
			<P>20:39<BR>
				Таак, что-то такое сгородил.... Но куда это годится - просто&nbsp;не знаю... 
				:((( Однако, работает - и&nbsp;списки &nbsp;формирует... Тогда - пусть так оно 
				и будет...
				<BR>
				<BR>
				Возможно, успею еще и с локами/анлоками разобраться....</P>
			<P>21:12<BR>
				Кнопка пока без всякой картинки, список посылает сообщения всем залоченным. Что 
				нужно?<BR>
				- Если текущий вид - снэпшот, и он анлочен - только ему<BR>
				- При смене в текущем залоченном виде - сообщения всем</P>
			<P>21:20<BR>
				Разборки в мейнфрейме прописал - а вот с диалогом сложнее: там 
				придется&nbsp;завести еще одну, внутреннюю и к тому же промежуточную ф-ию: она 
				должна будет либо вызвать ту самую GoToRec(), которую пользует и мейнфрейм - 
				либо&nbsp;отправлять сообщение последнему</P>
			<P>21:33<BR>
				Сделал. Изнутри диалога проходит, из списка - нет :(((
			</P>
			<P>Но разбираться буду или дома - или завтра. Чекин.</P>
			<P>-----------------------------------------------------------------------<BR>
				<STRONG>050702</STRONG> дома 00:49<BR>
				- не назначался m_pCurrView при смене снэпшотов - и не обеспечивлася досрочных 
				выход из ф-ии смены записи. Исправлено. При этом программа снова перестала 
				закрываться :((</P>
			<P>13:18 (на работе)<BR>
				Да, закрытие снова не проходит - причем на работе не проходит и закрытие файла 
				:((( - и только в том случае, если второй вид находится в окне, а первый - 
				вынесен... Если при этом вынесен третий вид - закрывается... Если второй и 
				третий в окне, а первый вне - нет.</P>
			<P>14:00<BR>
				Ну вот, пока пытался в очередной раз подумать о причинах зависа - они и исчезли 
				:((( Причем проверил по коду - код тот самый, совпадающий. А зависов нет... 
				Получается, что дело все-таки где-то глубоко в потрохах: дедлок между потоками 
				вида и главного окна... Но где???? Пообедал, протестировал еще раз (в том числе 
				и релиз-сборку) - ничего :(((</P>
			<P>14:30<BR>
				Автоселекция текущей записи в списке - пока без переключения при переключении 
				видов (и не работает с анлоченным - так как он не посылает соотв. сообщения)</P>
			<P>14:33<BR>
				Если вид ВСЕГДА меняет текущую запись не сам, а обращаясь к главному окну - то 
				все рабоает.</P>
			<P>14:42<BR>
				Переключение текущей записи в списке при смене вида.
				<BR>
				Нужно: при создании нового вида он получает номер текущей линкованной записи. 
				Для этого разумно в главном окне этот самый номер хранить...</P>
			<P>15:05<BR>
				Сделано: вновь создаваемый снэпшот получает номер "линкованного"...</P>
			<P>15:42<BR>
				Примитивные картинки для Lock-Unlock</P>
			<P>16:01<BR>
				Еще раз попытался записать с ActiView - никакой синхронности записи с триггером 
				не наблюдаю. :((( Буду готовиться к записи со своей программой....</P>
			<P>16:33<BR>
				Снова вспоминаю, как же оно там формируется....<BR>
				бит 8&nbsp; (256)&nbsp;&nbsp; -257<BR>
				бит 9 (512)&nbsp;&nbsp;&nbsp; -513</P>
			<P>18:13<BR>
				Первые тесты записи:<BR>
				- что-то умудряется писть по финальному брыку<BR>
				- я не пишу реальные номера каналов!!! Вот мне их и брать неоткуда :(((</P>
			<P>19:00<BR>
				В общем, всяческих сбоев у меня хвататет...<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">- что делать, когда никаких номеров 
							каналов и меток нет<BR>
							- где на самом деле хранить номера<BR>
							- что делать с прочитанными метками<BR>
						</FONT></FONT><FONT color="#000099">- не задается задержка триггера (сейчас 
						поставил 200 мс)</FONT></STRONG></P>
			<P>Ну а так - вводит... А я - домой....</P>
			<P>---------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050704 пн<BR>
				</STRONG><EM>Воскресенье начал с воспоминаний про физиологию (надо же сочинить 
					тезисы в конференции) - МАМА, регрессии... Вроде бы все уже делал - но когда, 
					где???? Что-то прикинул - но ничего толком. На огороде обкосил по второму разу 
					смородину, подвязал ее и полил</EM></P>
			<P>Сегодня забрал заказанные билеты, к часу пришел на работу - и к трем написал 
				таки тезисы!!! Честь мне и хвала :))))</P>
			<P>18:00<BR>
				Сделана защита от достпа последующими экземплярами приложения хардовой 
				библиотеки - на основе мьютекса. Текс в инфо-панели подправляется 
				соответственно. Но, увы, этот метод не проходит для многопользовательского 
				режима :((((</P>
			<P>18:18<BR>
				Для обхода этой проблемы имя создаваемого мьютекса должно начинаться с Global\ 
				- тогда он будет распространяться на все сессии....</P>
			<P><EM>//поехал к НС<BR>
				</EM>// Дома попробовал поразвлекаться с проблемой закрытия окон - и ничего 
				путного не выходит :((( Но все равно - сравнить нужно....</P>
			<P>---------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050705 вт<BR>
				</STRONG><EM>Утром получил в озоне кукиновские фильтры, через Василеостровскую - 
					цветы для Маши, ну а там - СФ, Малинина, Юля, все вперемешку... В итоге семь 
					вечера - а я даже не проврил, что же собственно "наработал" дома...</EM></P>
			<P>Проверил - наработки в основе своей прошли.</P>
			<P>Попробовал внести изменения: вернулся&nbsp; к старому. При закрытии всех файлов 
				- делать
				<BR>
				PostMessage(WM_DIZ_VIEW_CLOSE) Все равно ничего не получается...</P>
			<P>---------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050706 ср<BR>
				</STRONG>Причина "не получается" проста - я должен передавать в сообщении не 
				хэндл окна, а адрес класса вида. После смены заработало - но с тем же 
				результатом (50% незакрытие последнего окна)</P>
			<P>Ночные размышления и тесты на работе позволяют предположить, что дело именно в 
				закрытии последнего окошка: там явно требуется взаимная перерисовка окошка и 
				клиента, а клиентская область перерисована быть не может, так как главный поток 
				находится как раз в той самой ф-ии закрытия всего... Попробовал варинат:
				<BR>
				&nbsp;- в цикле постить сообщение на закрытие всем видам, кроме последнего<BR>
				&nbsp;- пауза (300 мс)<BR>
				&nbsp;- закрытие последнего вида<BR>
				Удивительно, но этот вариант - проходит....</P>
			<P><EM>На этом превал себя - поехал в Полюс за доверенностью, в переехавший на 
					Васильевский Универсалприбор - за осциллографом. Наконец-то получил....</EM></P>
			<P>По возвращении подергал программу еще - вроде работает... Но сил ни на что нет - 
				пойду...</P>
			<P>--------------------------------------------------</P>
			<P><STRONG>050707 чт<BR>
				</STRONG>На программу и не посмотрел: утром забежал в Сивму, увидел искомую 
				головку 329 - но облюбованного штатива 190PROB там не было. Тогда заехал в 
				Фотомагию - там не было головки :) Но штатив взял (3200). На работе на меня с 
				разговорами обрушилась СФ (не даваться Малининой). Попил кофе, зашел в ЯМ на 
				Большом Петроградской, посмотрел на 410 голову - всего один уровень и 5900 руб 
				:( . Дошел до Петроградской, снова пришел в Сивму, купил головку (3270) и 
				кокиновскую бленду (175). На работе получил зарплату, принялся разбираться с 
				головкой - а там одной пружинки не хватает. Хорошо, Сорокин под рукой оказался. 
				Потом НС, запись дисков, потом как-то сразу стало уже поздно, так что чуток 
				полазал в пабмеде и отправился снимать на Среднюю рогатку.</P>
			<P>----------------------------------------------------------</P>
			<P><STRONG>050708 пт<BR>
				</STRONG>Поставленный на 5:03 будильник слышал - но не встал. Но проснулся в 
				5:45!!! Хотел было повернуться на другой бок, но.... Но таки поднялся, выпил 
				кофе и поехал. Довольно долго прождал автобуса, но у пруда был в 6:35 - так что 
				поснимать удалось. Увы, без записи о фильтрах, так что опять придется 
				гадать.... Домой, еще кофе, но на работу - пораньше (а что дома сидеть?). Кофе, 
				зеленый чай, Юлин диплом, статьи... В общем, уже первый час и вроде как уже 
				минут 20 как должна была прийти Малинина - а я снова за программу еще не брался 
				:(((</P>
			<P>TODO<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">- отработка запоминания и чтения имен 
							каналов<BR>
						</FONT></FONT><FONT color="#000099">- заполнение списка и навигация по списку в 
						процессе ввода<BR>
					</FONT><FONT color="#000099">- файловые имена каналов (отображение в карте и 
						графиках)</FONT></STRONG></P>
			<P>1310
				<BR>
				Номер канала буду записывать в поле Transducer, как <STRONG>Active Electrode #A32#<BR>
				</STRONG>
			</P>
			<P>1321
				<BR>
				Версию пишу как <STRONG>24BIT BDF+D</STRONG></P>
			<P>1325<BR>
				флаг плюсовости устанавливаю по результату поиска в строке версии подстроки <STRONG>
					BDF+</STRONG></P>
			<P>1546<BR>
				Уже после встречи с Малининой и забега в отдел кадров:<BR>
				- что-то написал - но пока метки нигде не храню и ни на чем не могу проверить 
				правильность считывания меток (не номеров) каналов из старых файлов - просто у 
				меня здесь таковых нет...</P>
			<P>1808<BR>
				Ага, записать - записал (и их файл, и свой). Но! Имена-то я пока никуда не 
				читаю - и даже не помню, куда должен читать....</P>
			<P>1817<BR>
				Установил - в формируемый буфер m_pChanNames[8*TOTCHANS] - по 8 байт на 
				канал!!!! Теперь данные ActiView читаются, мои метки - почему-то не хотят :(((</P>
			<P>18:22<BR>
				Разобрался и со своими: во-первых "тип" имеет длину 80 символов (а я читал 
				только 16), а во-вторых, метка начинается с EEG_ - то есть копировать нужно 
				начиная с 4 символа.</P>
			<P>--------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050709 сб<BR>
				</STRONG>Утром заехал на Звездную, купил жилетку. Довольно долго сидел на ФС.</P>
			<P>1420<BR>
				<STRONG><FONT color="#000099">- При создании нового файла - бредовое количество 
						модулей!<BR>
						- Список при создании нового файла вообще не создается!</FONT></STRONG></P>
			<P>1424<BR>
				С количством модулей ясно: при инициализации файла сравнивал номер канала по 
				chan &gt; 256, а нужно &gt;=</P>
			<P>1427<BR>
				Добавляю список. Инфо-панель пока не буду. Но список еще не заполняется....</P>
			<P>14:45<BR>
				При получении нового фрейма главному окну посылается сообщение
				<BR>
				WM_DIZ_SNAPPLOT,(WPARAM)(&amp;m_Pointers[nBuf]),(LPARAM)m_arFChans.GetData()<BR>
				- но такое же сообщение идет и от снэпдиалогов, и от листа... НО!!! LPARAM в 
				этом сообщении никак не используется - поэтому я могу его задействовать под 
				различение "нового фрейма" и переключения между существующими. К тому же доп. 
				анализ (необходимость дополнения) можно сделать по неотрицательному номеру 
				полученного фрейма (чтобы избежать занесения в список незаписываемых записей)</P>
			<P>14:49<BR>
				Нет, даже еще проще: при чтении старых я использую другое сообщение - 
				READFRAME!!! Так что в LPARAM я как раз могу передавать флаг записываемости 
				(чтобы в главном окне его не вытаскивать)</P>
			<P>14:56<BR>
				С добавлением к списку проходит. Но работать это дело пока не работает....</P>
			<P>17:47<BR>
				Пообедал. Жарко. С трудом вожусь, отвлекаясь на интернетовские поиски всякой 
				чуши....<BR>
				У меня почему-то не проходит чтение - получаю ноль прочитанных байт ????</P>
			<P>17:58<BR>
				С не-чтением разобрался: файл нужно открывать с сочетанием флагов 
				GENERIC_READ|GENERIC_WRITE. Но остается два вопроса:<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">- по-видимому, я и после начала записи 
							файла сохраняю возможность переписать заголовок - из-за этого при вылючении 
							бокса в заголовок пишется не то, что нужно<BR>
						</FONT></FONT><FONT color="#000099">- что-то у меня записываемые по триггеру 
						картинки сильно отличаются от "свободных" записей. Как это???</FONT></STRONG></P>
			<P>18:22<BR>
				Отменена повторная инициализация файла, запись в который уже начата; введена 
				проверка на кол-во каналов; окошко харддиалога после начала записи в файл 
				остается запрещенным</P>
			<P>18:42<BR>
				Проверки на кол-во каналов и частоту при начатом файле. = Отказ от записи</P>
			<P>Почему-то изменение режима перестало отображаться в главной карте :(((</P>
			<P>-----------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050712 вт<BR>
				</STRONG>(в воскресенье вспоминал про virtual-sound программы для гранта 
				Малининой + огород, понедельник - отмечание ЯА, так что два дня - без подхода к 
				программе....)</P>
			<P>1501<BR>
				Восстановлено изменение главной карты при изменении режима</P>
			<P>1517<BR>
				Файл запоминает режим ввода, при изменении режима и непустом файле - 
				предупреждение о невозможности продолжения с предложением вернуться на страый 
				режим или закрыть файл.</P>
			<P>1638<BR>
				"Общие" параметры программы перенесены из секции Colors в секциб General</P>
			<P>2035<BR>
				Выбор и создание каталога и подкаталогов, создание имени файла при его 
				создании.</P>
			<P>---------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050713 ср<BR>
				</STRONG>Утром сходили с мамой на выставку Шагала. Хорошо.</P>
			<P>1400<BR>
				Запрос на создание несуществующего каталога при создании нового файла.</P>
			<P>1425<BR>
				Разрешение/запрещение контролов в зависимости от флага использования 
				фиксированного фолдера.</P>
			<P>1503<BR>
				Обслуживание кнопки Browse в установках хранилища данных</P>
			<P>1551<BR>
				После долгих мучений запретил скрытие пропертей при установленном флаге 
				использования фолдера и пустой строке (нужно пользовать GetResult()). Но 
				переходу на другие страницы это не мешает....</P>
			<P>1600<BR>
				Теперь отслеживаю и переходы между страницами плюс запрос на создание каталога 
				при выходе...</P>
			<P>1605<BR>
				Запрет перехода со страницы при невозможности создать указанный каталог</P>
			<P>1956<BR>
				по результатам наблюдений, сделанных в 1625<BR>
				<STRONG><FONT color="#cc0066">-<FONT color="#000099"> в заголовке файла - нули про частоту 
							и длительность<BR>
						</FONT></FONT><FONT color="#000099">- с триггерными реализаями сильное не то</FONT></STRONG></P>
			<P>2052<BR>
				С нулевой длительность понятно: sprintf(,,,"%8.8d") давал строчку из 8 символов 
				- и нулевой в конце, а у меня всего 8. Замена на 7 помогла...</P>
			<P>2104<BR>
				Неполадки с перекосом тригканала были вызваны не тем кол-вом каналов в цикле - 
				нужно <STRONG>m_nRecordedChans</STRONG> !!!<BR>
				<STRONG><FONT color="#000099">Снова неясности с включением паузы в тригрежиме при 
						повторном запуске.<BR>
					</FONT><FONT color="#000099">Не записывается StartTime</FONT></STRONG></P>
			<P>2118<BR>
				Пишу StartTime. Только все эти поля у меня пока никак не отзваниваются....</P>
			<P>2121<BR>
				С паузой тоже понятно - я не снимал флаг m_bNeedPause/<BR>
				<STRONG><FONT color="#000099">А вот "пустные данные" в снэпшоте у меня все одно 
						пытаются отрисоваться :((((<BR>
					</FONT><FONT color="#000099">И свежий фрейм передается и анлочным снэпам - хотя 
						навигация худо-бедно есть<BR>
						Номер нового фрейма в списке и снэпдиалоге не отзванивается....</FONT></STRONG></P>
			<P>2136<BR>
				Внесение в список свежих фреймов и навигация работают как задумано<BR>
				<STRONG><FONT color="#000099">Типы записпей не отзваниваются!!!!</FONT></STRONG></P>
			<P>поливать цветы -и домой.....</P>
			<P>--------------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050714 чт<BR>
				</STRONG>Снова жара. Купил вентилятор...</P>
			<P>1404<BR>
				Внесение времени и типа новой записи в список - для этого модифицирована 
				извлекающая ф-ия в файле: теперь таковых две, первая принимает номер записи, 
				вторая - уже готовый буфер. Первая вызывает вторую.</P>
			<P>1430-1750<BR>
				Обнаружил солидные утечки памяти при закрытии программы. Вычислил источник: при 
				закрытии вызывается RemoveAllViews(), которая работает через PostMessage - а до 
				обработки этих посланий дело уже не доходит :((( Остановился на попытке 
				перепостить то же сообщение - но все-равно что-то течет. И мои мозги текут тоже 
				- температура в комнате уже под 30 подбирается :(((</P>
			<P>1752<BR>
				Если просто наоткрывать разных видов - утечек нет. Если еще и ввод запустить (и 
				ввести) - утекает 37056 байт. Если ничего не записывать - столько же. И если 
				создать файл и записать в него - тоже столько же!!!!</P>
			<P>1802<BR>
				Один источник утечек обнаружен - не уничтожался CSnapView::m_pReadBuf24 при 
				повторной инициализации вида. После исправления нет утечек и в случае 
				нормальной записи в файл.</P>
			<P>1923<BR>
				Сделал обработку запрета записи - но с большими "не вдруг" - вплоть до полных 
				зависов (не ту переменную в кач-ве номера буфера брал). Но в итоге все равно 
				непонятно: при запрете записи и при переходе по команде в виде нормально 
				отображается статус записанной реализации, а при отображении новой триггерной 
				вся информация о триггере терятеся (но - только если пишем). Не понимаю... И 
				вряд ли пойму при актульных +30. Так что закрываюсь - и домой. То есть на 
				огород - поливать...</P>
			<P>--------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050715 пт</STRONG></P>
			<P>1226<BR>
				Проверил - и в самом деле получается, что при отрисовке нового фрейма я не 
				получаю сточку с описанием триггера и проч....<BR>
			</P>
			<P>1248<BR>
				Получается, что у меня при первом входе (новая реализация) в конце каждого тага 
				стоит два нуля, а при втором - то, что нужно....</P>
			<P>1258<BR>
				Это у меня ф-ия CDataFile::GetRecTypeAndTime(char* pStr, char* pType, char* 
				pTime) занималась модификацией аннотаций (меняла служебные символы на нули). 
				Заставил ее делать то же самое с копией - тогда вроде бы все получается. Но!!! 
				У меня каким-то образом в триггере проскакивает явно не-триггерное значение 
				oxFFFF - а такого вроде бы совсем не может быть ????</P>
			<P>1304<BR>
				Тоже понятно - я сначала брал точку, а потом делал Reverse(1) - а нужно 
				наоборот: сначала на точку откатиться, а потом уже ее брать (в противном случае 
				я беру не первую точку триггера - тут-то и возможна промашка).</P>
			<P>1407<BR>
				Ввел управление плюсовостью формата. Пытаюсь заставить фирменный ридер читать 
				мои файлы. Оказалось - не пишу -1 в начале: пришлось насильно. Далее: фирменный 
				ридер хочет, чтобы триггер шел в конце :(((( А как мне это сделать????</P>
			<P>1510<BR>
				Вроде бы добился записи триггера в конец и чтения "не-плюсовых" файлов 
				фирменным ридером. Но!!! Только при длительности 1 секунда!!!<BR>
				<FONT color="#cc0066"><STRONG><FONT color="#000099">- запретить изменение формата при 
							открытом файле<BR>
						</FONT><FONT color="#000099">- почему не работают системные клавиши в пропертях????</FONT></STRONG></FONT></P>
			<P>1637<BR>
				Борьба с переходом по табам оказалась суровой - она изначально не работает в 
				немодальных диалогах!!! Обойти же ее через PreTranslateMessage() - не вдруг.... 
				То есть в итоге обошел - но оказалось, что все перехватывается уже первой 
				страницей, а не активной....</P>
			<P>1646<BR>
				Как-то избавился, производя регистрацию (и отмену оной) при 
				активации/деактивации страницы. Но это, конечно же, полный бред - на самом деле 
				мне нужно не писать всю эту ернунду в каждом классе, а заводить свой класс 
				страницы (да и немодального диалога вообще)<BR>
				<STRONG><FONT color="#000099">К тому же у меня теперь окошко триггера показывается 
						как-то неправильно....</FONT></STRONG></P>
			<P>1721<BR>
				Как выяснилось, на показ триггера фатально сказывается разрешение первой кнопке 
				режима флага TABSTOP - она начинает непрерывно нажиматься :((((</P>
			<P>1823<BR>
				Запрещение полей "плюсововсть" и "длина записи" при непустом новом файле - 
				реализовано через _Settings.m_nFileMode, который при первой записи становится 
				равен трем.</P>
			<P><STRONG><FONT color="#000099">Опять большие проблемы с закрытием программы :((((<BR>
						Более того, при попытке пуска СРАЗУ после включения питания - тоже уходим в 
						завис :(((</FONT></STRONG></P>
			<P>2144<BR>
				На этот раз мне показалось (и были к тому основания), что один из корней 
				проблемы - в сложностях активации видов и диалогов: уж больно долго 
				перемигвались два окошка, возинкающих при запуске программы на пустом месте... 
				И в самом деле: активация вида приводит к активации диалога, и диалога - 
				вида....<BR>
				Избавился от этого введением переменной CActiView::m_bHere - она 
				устанавливается внутри ф-ии OnSetActive (вызываемой при активации из диалога) - 
				и не дает выполнятся обработчику OnActivate. При этом исчезли перемигивания - и 
				вроде бы даже проблемы с закрытием программы (там явно были какие-то завязки на 
				то же самое)</P>
			<P>Еще парочка проблем обнаружилась на запуске: если попытаться запустить программу 
				тут же после разрешения кнопки - она висла... Видимо, из-за того, что 
				разрешение (по флагу режима) давалось ранее, чем происходили все прочие 
				обраотки... Избавился, заведя флаг CMainFrame::m_bReady - он устанавливается в 
				самом конце таймерного обработчка и сбрасывается в нем же по любым исключениям, 
				в том числе - и по смене режима. Таким образом, вроде решил и эту задачку.</P>
			<P>Схожий вопрос: при таком запуске (и с одновременным созданием двух новых окон) у 
				меня начинался рваный вывод на осцилл. Подумал - это из-за порядка создания, и 
				переместил создание новго осцилла ближе к концу. Так вроде бы рвани не 
				возникает...</P>
			<P>Для Юли снова времени не оказалось - поставил туда Джину и обнаружил, что у меня 
				снова на трое ушей - всего один переходник :((( А ведь были же!!! Написал эти 
				слова - и нашел: у себя в красном конце-переходнике :))) Одной проблемкой 
				меньше :))))
			</P>
			<P>2153 - поливать цветы и к дому....</P>
			<P>-------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050716 сб<BR>
				</STRONG>Я хочу:<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">- добависть к cnt-реализациям время 
							начала реалзицаии относительно New<BR>
						</FONT><FONT color="#000099">- Обрабатывать разрешение записи при текущем вводе как 
							переход на New (чтобы не получать cnt с разрывами)<BR>
						</FONT></FONT><FONT color="#000099">- рисовать метки времени на SnapShot</FONT></STRONG></P>
			<P>1250<BR>
				В файле заведен флаг m_bSkipped, который позволяет переводить cnt записи в New</P>
			<P>1300<BR>
				Еще одна переменная - CDataFile::m_flNewTime - время начала непрерывной записи, 
				для возможности пометки относительного времени в непрерывной.</P>
			<P>1310<BR>
				Размышления на тему временных меток в снэпшотах:<BR>
				- New - начинаем с нуля<BR>
				- cnt - целые секунды "базового" времени<BR>
				- Tr - за ноль принимается время триггера</P>
			<P>1330<BR>
				Все бы ничего, но по-хорошему&nbsp;мне для расстановки временных меток нужно бы 
				знать длину окна в мс - а она нигде не формируется... Нужно посмотреть, где это 
				можно сделать...</P>
			<P>1450<BR>
				Такая переменная есть!!! Только для COscView она - в секундах, а здесь сразу 
				будет в миллисекундах....</P>
			<P>1500<BR>
				Нулевую линию нарисовал. Теперь нужно бы остальные - и еще бы времячко....</P>
			<P>1531<BR>
				Пообедал. Вроде бы рисую все возможные метки. Вопрос с отображением чисел....</P>
			<P>1647<BR>
				Немножечко косовато, но сделал: в начале всегда рисутеся линия и обозначается 
				базовое время с двумя знаками после запятой, далее - линии через 1 с....</P>
			<P>1729<BR>
				К триггерной панели добавлена установка "мертвого времени" триггера (Idle Time) 
				- с сохранением в соотв. структуре. Одновременно к диалогу добавлена обработка 
				клавиши ВВОД, чуточку усовершенствована логика обрабочтиков (бОльшая часть 
				работы перенесена в EditUpdate). Главная ф-ия не хранит время в себе, берет из 
				установок. Проверил - работает.</P>
			<P>1736<BR>
				При вызове пропертей главной окно запрещается, при их закрытии - разрешается.</P>
			<P>--------------------------- сохранение и чекин ----------------------</P>
			<P>1746<BR>
				Возвращаюсь к диалогу формирования заголовка файла. Хочу:<BR>
				<FONT color="#cc0066"><STRONG><FONT color="#000099">- заменить дейт-тайм пикер на отдельные 
							контролы с возможностью установки нулей ("не задано")<BR>
							- в комбобоксах проверять введенную строку на совпадение с уже существующими, 
							при совпадении новые не формировать<BR>
						</FONT><FONT color="#000099">- сохранять все накопленные в комбобоксах значения<BR>
							- при выборе испытуемого из существующих подставлять его данные</FONT></STRONG></FONT></P>
			<P>1829<BR>
				Реализован свободный выбор даты</P>
			<P>1849<BR>
				С кодами пациентов тоже потихоньку разбираюсь - сделал код нечувствительным к 
				регистру (и поиск по началу) - но проблемы еще ожидают... Поливать цветы - и 
				бежать!!!</P>
			<P>--------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050718 пн<BR>
				</STRONG>1354<BR>
				Вчера (в воскресенье) дома чуток повозился с возможной сортировкой 
				комбо-боксов. Есть два варианта: либо переписывать сортировочную ф-ию, либо 
				вручную переставлять строчки. Перый способ вроде и более хорош - но:<BR>
				- требует создания своего класса<BR>
				- этот класс будет сильно привязан к данным как таковым</P>
			<P>В то же время если просто переставлять строчки - то каждый раз будут 
				переписываться все поля в ини-файле (и испытуемые получат другие номера). Может 
				быть это и не страшно - но каким образом я буду выбирать "прочие данные" 
				испытуемых при выборе уже существующего???</P>
			<P>Альтернативный подход: каждый испытуемый - структура, в к-й помимо информативных 
				полей есть и "номер" - место в списке. Но тогда при каждой смене текущего 
				испытуемого должны изменяться и номера у всех остальных....&nbsp; Так... Какие 
				еще есть варианты????</P>
			<P>2020<BR>
				День прошел - а не то что ничего не написал - но ничего и не придумал: жарко и 
				душно, никаких мыслей и в помине нет :(((</P>
			<P>---------------------------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050719 вт<BR>
				</STRONG>В общем, единственное что надумал:<BR>
				- испытыуемые хранятся по номеру (в порядке добавления)<BR>
				- в списке data - номер испытуемого<BR>
				- при переносе испытуемого наверх нужно перенести и его номер<BR>
				- отдельно хранится список "очередности" - и при считывании конфигурации 
				испытуемые помещаются в комбобокс согласно ему<BR>
				- то же самое и для остальных комбобоксов</P>
			<P>1626<BR>
				Вопрос еще и в том, что я на самом деле не хочу лишний раз переписывать в 
				ини-файле оставшихся неизменными испытуемых. А для этого я должен держать на 
				них флаги - изменился или нет.... Причем массив должен быть динамическим....</P>
			<P>1750<BR>
				Вообще-то нет. Одним из возможных вариантов использования может быть занесение 
				нескольких испытуемых за один заход - тогда и апдейт будет делаться 
				инидивидуально, то есть достаточно одного флага.</P>
			<P>1924<BR>
				Сделана смена параметров испытуемого при выборе другого - пока только при 
				смене.... Осталось - такую же смену при выходе (то есть вынесение в отд. фию) и 
				запоминание порядка (чтение вроде как уже есть).</P>
			<P>2111<BR>
				Нет, все же какие-то расстыковки продолжаются.... Нужно попробовать полить 
				цветы и дойти до дому - может легче станет???</P>
			<P>0047<BR>
				И в самом деле, дома удалось довести до ума (к тому же и кол-во реков за 
				"июльское утро" достигло 45 - положительная эмоция!!!) сохранение, 
				восстановление и добавление испытуемых. Долго не мог справиться с 
				восстановлением правильных ItemData - но таки сообразил: нужно было снять флаг 
				сортировки!!!</P>
			<P><STRONG><FONT color="#000099">Теперь нужно обобщить поведение этого комбобокса (но без 
						излишеств "доп. полей") на остальные - тип эксперимента, экспериментататора, 
						оборудование....</FONT></STRONG></P>
			<P>------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050721 чт<BR>
				</STRONG>Вчера на работу не пошел - весь день пробродил по лесам, настрелял 
				почти гиг птах. Так что и сегодня, придя на работу, два часа их распихивал по 
				местам... Но - к делу</P>
			<P>1340<BR>
				Какого поведения я хочу от "прочих комбобоксов"?<BR>
				- ввод нового значения по Enter и KillFocus<BR>
				- помещение выбранного значения на нулевую строку<BR>
				- запоминание порядка (MRU-style)<BR>
				В какой момент должна производиться модификация ини-файла?<BR>
				- Добавление нового значения (с увеличением счетчика) - при записи нового 
				значения<BR>
				- Запись порядка - при выходе из диалога</P>
			<P>Возможен и другой вариант: при добавлении "по ходу" изменяются внутренние списки 
				строк. При правильном выходе из диалога производится запись добавленных строк. 
				Этот вариант потребует<BR>
				- списка на каждый комбобокс<BR>
				- количества исходных значений<BR>
				(результирующее кол-во можно опустить - его можно брать из основного списка)</P>
			<P>Вроде бы второй варинат выглядит лучше - но с ним будут несклады при добавлении 
				в будущем&nbsp; (и, вероятно, скором) кнопок, позволяющих удалить каждое 
				значение. Таковое удаление проще производить прямо в ини-файле....</P>
			<P>1534<BR>
				Прописана общая ф-ия заглатывания списков (если длина списка не совпадает - 
				заполняется номерами). Прописаны фрагменты чтения списков (типов эксперимента, 
				исследователя и оборудования) из ини-файла. Запись не прописана.</P>
			<P>1545<BR>
				Добавление новых строк проходит. Изменение сортировки при выбре существующих - 
				нет :(</P>
			<P>1623<BR>
				Я просто не подключил мессаджи по KillFocus. После доавлений в карту 
				перестановка работает - но только при смене фокуса. Теперь нужно переставлять 
				собственно при выборе....</P>
			<P>1801 (после перерыва на редактирование очередной фотографии для ФС)<BR>
				в карте последовательность из 4 входов<BR>
				//COMMAND_HANDLER(IDC_PATCODE, CBN_KILLFOCUS, OnCbnKillfocus)
				<BR>
				//COMMAND_HANDLER(IDC_INVCODE, CBN_KILLFOCUS, OnCbnKillfocus)
				<BR>
				//COMMAND_HANDLER(IDC_RESEARCHER, CBN_KILLFOCUS, OnCbnKillfocus)
				<BR>
				//COMMAND_HANDLER(IDC_EQUIPMENT, CBN_KILLFOCUS, OnCbnKillfocus)
				<BR>
				заменена на единственное вхождение<BR>
				//COMMAND_CODE_HANDLER(CBN_KILLFOCUS, OnCbnKillfocus)
				<BR>
				- и все работает!!!</P>
			<P>1815<BR>
				Попытка обойтись таким же образом с SelEndOk (спецкод для пациента, вызов 
				ComboString для остальных) успехом не увенчалась: ComboString берет текущую 
				строку, а она еще не установлена.....</P>
			<P>1821<BR>
				В ComboString() введен доп. параметр, позволяющий брать либо текущую строку (по 
				умолчанию), либо свежевыбранную строку (при доп. параметре bSelected = true). 
				Так работает. Осталось все это дело сохранять при выходе....</P>
			<P>1838<BR>
				Прописалось - но не прочиталось. Я просто не пишу кол-во ("NumberOf") и 
				порядок.</P>
			<P>1845<BR>
				Порядок обхода диалога. Снятие сортировки</P>
			<P>1946<BR>
				Общая для всех комбобоксов ф-ия сохранения порядка. По всей видимости - 
				работает... Можно успокоиться :)))<BR>
				Нужно сделать отображение этих полей в инфо-панели.</P>
			<P>2007<BR>
				Сделал примитивное отображение полей. Дальше нужно будет их "разбросать" в 
				соотвествии со спецификацией.</P>
			<P>----------------------------- сохранение. чекин 
				------------------------------------------------</P>
			<P>2035<BR>
				Записал некое подобие тестового файла. Замечено: не слишком-то релевантные 
				изменения в тригканале приводят к сбросу режимов "пауза" и "принудительная 
				запись".... Нужно будет посмотреть!!!</P>
			<P>-----------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050722 пт</STRONG></P>
			<P>Снова какой-то вялый день. Выставил на ФС второю фотографию с рогатки...</P>
			<P>Дорабатоал заголовочный диалог: проверка всех полей на валидность символов, 
				недопущение пустых строк. Проверил поведение триггеров: единственное, что меня 
				может не устраивать - в тригрежиме принудительная запись при поступлении 
				триггера сбрасывается даже в режиме "пауза".</P>
			<P>----------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050725 пн</STRONG></P>
			<P>Выходные провел дома (Лента, птички, огород).... Какие-то размышления были - и 
				даже в EEGLAB заглянул. Сформулированы основные вопросы-пожелания:<BR>
				<STRONG><FONT color="#cc0066"><FONT color="#000099">- поведение ручных кнопок и хардовых 
							триггеров - логика обработки<BR>
						</FONT><FONT color="#000099">- Запуск с созданием двух окошек: почему приводит к 
							дергающемуся отображению<BR>
						</FONT></FONT><FONT color="#000099">- матлаб-экспорт</FONT></STRONG></P>
			<P>1211 - поехали...</P>
			<P>1331<BR>
				С дрыганьем при старте разобрался кардинально: не обрабатываю первую получку 
				после перезапуска системы (ту, в которой 64 точки). Вроде бы помогает... <FONT color="#000099">
					<STRONG>Но!!! Снова престал закрываться снэпшот (полученный без файла)....</STRONG></FONT></P>
			<P>1904<BR>
				И снова весь день прошел в поисках решения проблемы незакрывающихся окошек - то 
				есть не-окончания граф. потока. И это уже который день!!! Господи, как мне эта 
				проблема надоела!!!!!<BR>
				Переносил вызов установки родителя в поток (в вид) - стало еще хуже. Понятно: в 
				моих интересах, чтобы как раз это место было отработано в основном потоке... 
				Заметил, что зависа нет, если окошко (внешнее) сначала активировать, попробовал 
				встроить ф-ию активации - снова плохо: не отрабатывает. И никакие задержки не 
				помогают :((( В общем, часов до шести - и без малейших подвижек: если не 
				зависает с внешними - виснет при закрытии дочерних. Или наоборот, причем сейчас 
				уже точно и сказать не могу, когда что мешает.</P>
			<P>Не выдержал - вернулся к идее принудительной терминации потока. Она-то проходит 
				- но в памяти остается мусор. Немного - 4 байта (то есть одно какое-то 
				значение) - но кто знает, в какой момент этот мусор может стать фатальным :(((</P>
			<P>Размышления показали: эти 4 байта - переменная CMessageLoop theLoop. Она же 
				объявлена локальной в ф-ии Run, а при принудительном завершении выхода из этой 
				ф-ии не происходит!!! Сделал ее переменной класса - и все работает!!! Правда, 
				теперь пришлось отменить регистрацию цикла в модуле (удалять цикл в деструкторе 
				я не могу: такое удаление производится по идентификатору текущего потока, а 
				деструктор работает в главном потоке). Вроде бы работает.... И мусора не 
				остается...</P>
			<P><STRONG><FONT color="#000099">После отказа от ввода первых 64 значений я получаю 
						разнообразный мусор (то есть куда-то они все-таки вводятся) - в том числе и на 
						тригканале: это приводит к паразитному вводу реализации.</FONT></STRONG></P>
			<P>2045<BR>
				Отказался от предыдущей задумки (с выбрасыванием первых значений). Вернулся к 
				перезапуску таймера. А там вернулась и мысль о возможности его переустановки - 
				сначала забазировался на переменную в _Settings, потом ввел ее во вторую панель 
				установок (в пределах 50-500 мс). Как ни странно, все работает. И даже без 
				дерганий (во всем диапазоне изменений). Ну и беспокоящие дергания тоже ушли....</P>
			<P><STRONG><FONT color="#000099">Но!!! Теперь у меня снэпшоты при открытии сразу что-то 
						отрисовывают... Откуда бы???</FONT></STRONG></P>
			<P>2123<BR>
				Доработана логика кнопок и гейтов:<BR>
				- кнопки на тулбаре показывают не только текущее, но и желаемое состояние 
				(чтобы не вводить пользователя в заблуждение) - то есть если пауза еще не 
				установлена, но попросили - показываем паузу, если находимся в режиме паузы но 
				попросили ее закончить- показываем что нет, и с WrManual также<BR>
				- устранено выклчюение мануального ввода в тригрежиме при паузе</P>
			<P>Каким-то образром это решило и проблему с отрисовкой новых снэпшотов???? Нет - 
				только в дебаг-версии. В релизе - чтой-то рисуем.... <STRONG><FONT color="#000099">Найти 
						неинициализированную переменную!!!!</FONT></STRONG></P>
			<P>2200<BR>
				Нашел - ошибка в SnapInit: я не учел, что снэпшот может создаваться без файла - 
				и рисовал, даже если файле не было...
			</P>
			<P>------------------------------------------- Уфф.. 
				---------------------------------------</P>
			<P><STRONG>050726 вт<BR>
				</STRONG>Утром пробежался по магазинам - заглянул в Петра Великого (пустота), в 
				Доме Книги купил маме две книжки Айрис Мердок.</P>
			<P>Основное туду на сегодня - матлаб-экспорт. Вопросы:<BR>
				<FONT color="#cc0066"><FONT color="#000099">- условия разрешения кнопки (наличие 
						непустого файла)<BR>
					</FONT><FONT color="#000099">- отдельный каталог (отдельная переменнная в 
						установках, пока - без специального режима установки: просто запоминаем)<BR>
					</FONT><FONT color="#000099">- экспортируем всё, тригканал - отдельно, аннотации - 
						отдельно (как текствую переменную)<BR>
					</FONT></FONT><FONT color="#000099">- масшабирование при записи (с вопросом для 
					тригканала)<BR>
				</FONT><FONT color="#000099">- ориентация массива (хотелось бы сделать так, чтобы 
					не накапливать весь в памяти - слишком много может получиться. Тогда нужно 
					смотреть - как его располагать, чтобы можно было писать по реализациям)</FONT></P>
			<P>1335<BR>
				Матлаб-кнопка и логика ее включения</P>
			<P>1501<BR>
				Для запоминания каталога пришлось создать свой класс: из фирменного каталога не 
				получить, так как он выдается лишь посылкой сообщения окну, а после закрытия 
				диалога окна уже нет :((((</P>
			<P>1509<BR>
				Файл создается. Осталось немного - записать в него :))))</P>
			<P>1648<BR>
				Пишу основные переменные и имена каналов.</P>
			<P>1745<BR>
				Пишу аннотации (и письмо)</P>
			<P>1807<BR>
				Пишу тригканал. Формат в EEGLAB&nbsp;<BR>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
				Channels * Time * Records<BR>
				отбросив каналы (если пишем их отдельно), получаем<BR>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Time*Records<BR>
				- вот и триггер пишу в таком формате.....</P>
			<P>Ну а как быть с самими данными??? Заводить и заполнять буфер на всё сразу... 
				Мягко говоря, опасно (может получиться сильно много-гиговым). Попробую-ка 
				писать по отдельным записям (порождая кучу переменных - и массив с их именами)</P>
			<P>Если писать по записям, формат должен быть<BR>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Channels*Time</P>
			<P>1847<BR>
				Угу, пишу по записям. Короткий скрипт собирает их воедино:<BR>
				<FONT color="#000099"><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for r = 
						1:NumberOfRecords,
						<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A(:,:,r) = 
						eval(RecNames(r,:));
						<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</STRONG></FONT></P>
			<P>Осталось сделать масшатбы..... И собственно перевод аннотаций в типы реализаций.</P>
			<P><BR>
				&nbsp;2126<BR>
				На делании масштабов подзавис: обнаружил, что EEGLAB их не читает :((( Выяснил: 
				он их берет как строку, а у меня она заполнена нулями (в ActiView - проблеами) 
				- вот и результат... Принудительно добавил нулей - вроде бы помогает....</P>
			<P>На самом деле масштабы нужно читать при открытии файла (а не при экспорте) - и 
				насчитанные значения использовать!!!
			</P>
			<P>Но все это - уже не сегодня....</P>
			<P>----------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>040728 чт<BR>
				</STRONG>Среда прошла в поездке на Казанское кладбище - годовщина д. Толи... 
				Разобрался с расчетом поправочных коэффициентов. Но!!! У меня в настоящий 
				момент все эти коэффициенты нигде и никак не учитываются... И еще нужно 
				подправить ф-ии заполнения полей заголовка - чтобы остатки полей заполнялись 
				пробелами, а не нулями....</P>
			<P>1220<BR>
				Модифицированная ф-ия strncpySP - с добиванием остатков пробелами. Но!!! Она не 
				работает с основным заголовком....</P>
			<P>1300<BR>
				Итак, определенные вчера уравнения выглядят так:<BR>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cal = (PhMax - PhMin) / 
				(DgMax - DgMin)<BR>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Off = PhMin - DgMin*Cal<BR>
				Для совместимости неплохо было бы привести считанные из файла коэффициенты к 
				"оригинальным". Последний ("оригинальный") составляет 
				(262143+262144)/(8388607+8388608) = 1/32. То есть считав коффициенты, я должен 
				их умножить на 32.... Так. Ну а что в таком случае со смещением????</P>
			<P>Если подумать (ну или попытаться...), то получается, что у меня дефолтовая 
				ФИЗИЧЕСКАЯ ЕДИНИЦА равна 1/32 мкв. То есть мне достаточно ПОСЛЕ вычисления и 
				то, и другое (коэфф и смещение) умножить на 32</P>
			<P>Не забыть учесть единицу измерения - и в случае ЛЮБОГО отката ставить дефолтовые 
				коэффициенты. Поэтому лучше - в отдельной ф-ии...<BR>
				1328 - пошел на Ботанику, к Ростовой....</P>
			<P>1650<BR>
				Сходил к Ростовой, поговорил с Шестопаловой.<BR>
				Расчет делается - только пока без учета единиц измерения.</P>
			<P>1819<BR>
				Расчет коэффициентов долго сбоил - пока не сделал внутренние переменные 
				статическими... Бред.... А может и нет....</P>
			<P>1927<BR>
				Видоизменил запись: тригслово пишу и для New и cnt - но похоже, что пишу не 
				всегда то :(((</P>
			<P>1956<BR>
				Во избежание пишу всегда то самое слово, которое вызвало "срабатываение" 
				триггера (для этого модифицирована и ф-ия WritePre) - тогда вроде как пишется 
				то.... Вылеты при попытке экспорта свежезаписанных данных!!!!</P>
			<P>2000<BR>
				Установлена причина вылета: m_PntRead.pBuf неинициализирован....</P>
			<P>2010<BR>
				В этом случае (при экспорте свежезаписанных) создаем новый временный буфер, и 
				указатель приравниваем к нему. Потом не забываем буфер уничтожить, а указатель 
				- обнулить...</P>
			<P>2027<BR>
				Ф-ия экспорта сама формирует командную строку для объединения данных - и диалог 
				с объяснением.</P>
			<P>050729<BR>
				1318<BR>
				Добавлена облигатная запись тригслова и его вывод в списке</P>
			<P>1417<BR>
				Ф-ия чтения типов сама расчитывает "базовое время".</P>
			<P>1439<BR>
				Экспорт латентностей, типов и тригслов</P>
			<P>1508<BR>
				Экспорт индивидуальных временных осей</P>
			<P>1527<BR>
				Простая ось замещается первой встреченной триггерной.<BR>
				<STRONG><FONT color="#000099">Загрузить EEGLAB и посмотреть, какие еще нужны 
						переменные.....</FONT></STRONG></P>
			<P>1536<BR>
				Пишем частоты дискретизации</P>
			<P>1555<BR>
				При приходе буфера удаляю все недописанные буфера свободных реализаций<BR>
				<STRONG><FONT color="#000099">- Пишется не то время для свободных<BR>
						- В свежезаписанном - что-то не то с отображением в списке тригреализаций</FONT></STRONG></P>
			<P>1705<BR>
				Ошибки были вызваны неаккуратным обращением с вновь введенным полем в 
				m_Pointers: я в нескольких местах использовал не тот индекс - вот и писал 
				непонятно куда :((((</P>
			<P>1715<BR>
				Тригслово при записи новой реализации<BR>
				У меня при NEW пишется не то слово!!!!</P>
			<P>1727<BR>
				Да нет, в файле - то слово! Это читаю я его неверно....
			</P>
			<P>1730<BR>
				Дело было в лишних пробелах, которые я не пропускал...<BR>
				<STRONG><FONT color="#000099">Перенести конфиги!!!</FONT></STRONG></P>
			<P>1800<BR>
				Оказалось, нужно не только перенести - но и подправить работу: у меня не 
				срабатывал выход с некоторых страниц....</P>
			<P>1830<BR>
				<STRONG><FONT color="#cc0066">- <FONT color="#000099">Теперь не отображается триггерных код<BR>
						</FONT></FONT><FONT color="#000099">- Подрпавить значения фильтров!!!</FONT></STRONG></P>
			<P>1852<BR>
				Подправлено чтение тригслова для тригреализаций<BR>
				<FONT color="#000099"><FONT color="#cc0066"><STRONG></FONT><FONT color="#000099">Отображать 
						имя файла в заголовке главного окна и всех дочерних!!!!</FONT></STRONG></FONT>
			</P>
			<P>1900<BR>
				"правильные" значения фильтров</P>
			<P>1915<BR>
				Имя файла в заголовке главного окна и снэпшотов (для осциллов не стал - там 
				может быть и без, и непонятно как переименовывать...)</P>
			<P>2000<BR>
				Обнаружены вылеты:<BR>
				<STRONG><FONT style="BACKGROUND-COLOR: #99ff99" color="#cc0066">- при записи файла - 
						при поптыке создания нового снэпшота "на лету"<BR>
						<FONT color="#000099">- при закрытии осцилла на лету</FONT></FONT></STRONG></P>
			<P>2015<BR>
				Вылет при закрытии осцилла на лету: недобиваю таймер. Решение - принудительное 
				убиение (с введением пустой виртуальной ф-ии в родителе)</P>
			<P>2020<BR>
				Вылеты при создании снэпа на лету - попытка перерисовать еще не существующее 
				окно (соотв. иф был - просто его раскомментировал) - и какие-то непонятнки, 
				свойственные только плюс-формату....</P>
			<P>2035<BR>
				Вылеты при создании снэпшота вылечились объявлением промежуточных текстовых 
				буферов статическми....</P>
			<P>2102<BR>
				Неполадки с активацией диалогов.</P>
			<P>2115<BR>
				Пришлось вернуть обращение к главной ф-ии OnActivate из SetAvtive</P>
			<P>2120<BR>
				Неполдки с перьями - убрал penOld из CSnapShot::PolyLine.</P>
			<P>2125<BR>
				Больше не могу... Что есть - то и посылаю....</P>
			<P>----------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050731вс - дома<BR>
				</STRONG>Разумеется, я был неправ. Нужно было еще подумать, выдержать, 
				доработать - и программу, и документ. Но не было сил - и слишком сильна 
				уверенность (да, уже она), что никому это самое письмо и прочие мои старания не 
				нужны, неинтересны... Но тем не менее, продолжать придется - чтобы потом 
				породить из всего этого какой-никакой, но документ....</P>
			<P>Итак, в воскресенье:<BR>
				- вывод имен каналов соотв. цветами<BR>
				- модифицирован алгоритм вывода (чтобы "наложение" было возможно при любом 
				цвете фона - в прежнем варианте "проходило" только для черного)<BR>
				- при изменении цветов диалог посылает главному окну WM_DIZ_MAPCHANGED - 
				немедленная смена цветов во всех дочерних окнах</P>
			<P>----------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050801 пн</STRONG></P>
			<P>1120-1356<BR>
				Продолжил борьбу с цветами... Вроде бы такая ернунда - а столько маеты: и 
				сообщение грозит многое порушить, и в осцилле с цветами совсем не то, и 
				отрисовка тоже непонятная... Вроде бы чего-то добился (рисует, не вылетает) - 
				так и оставлю...</P>
			<P>1400<BR>
				<STRONG><FONT color="#000099">После пятничных изменений (вновь разрешенная активация) - 
						снова проблемы с перемигиванием :((((</FONT></STRONG></P>
			<P>1441<BR>
				Вроде бы очередная победа над взаимной активацией....</P>
			<P>1533<BR>
				Исправлена ошибка: не писал стартовое время при не-плюс-формате</P>
			<P>---------------------------- 1546 - чекин, займусь конфигами 
				---------------------------------</P>
			<P>1910<BR>
				Простейший менеджмент конфигов - второй чекин.</P>
			<P>------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050802</STRONG></P>
			<P>Проведен первый полномасштабный тестовый эксперимент: с 32 электродами, 
				реальными стимулами и метками. Две серии - первая с Sennheiser HD265, вторая - 
				с Etymotic ER-2.
				<BR>
				В принципе все нормально, за исключением каких-то проблем с тачпруфами: при 
				сохранении смещения вместо сигнала начинает идти шум....</P>
			<P>Возникшие "по ходу" замечания:<BR>
				<FONT color="#cc0066"><STRONG><FONT color="#000099">- включение биполяров (чекбоксом) в 
							диалоге не вызвает сообщения WM_DIZ_MAPCHANGED</FONT>
						<BR>
						<FONT color="#000099">- похоже, что для биполяров нужен отдельный масштаб 
							(окулограмма может сильно перекрывать ЭЭГ)<BR>
						</FONT><FONT color="#000099">- после каких-то процедур пропадает заполнение списка 
							доп. полями при вводе<BR>
						</FONT><FONT color="#000099">- в создаваемой матлаб-строке нужно обеспечить 
							предварительное резервирование массива<BR>
						</FONT>-<FONT color="#000099"> StartDate и StartTime в инфо-панели<BR>
						</FONT><FONT color="#99ff33">- возможно, там же предусмотреть cellstring(TWORD) - 
							для облегчения дальнейшего поиска меток<BR>
						</FONT><FONT color="#000099">- при создании нового файла не меняются имена уже 
							существующих дочерних окон<BR>
						</FONT></STRONG></FONT>
			</P>
			<P>2033<BR>
				Замена имени существующих окон при создании файла</P>
			<P>2038<BR>
				Посылка WM_DIZ_MAPCHANGED почему-то была просто закомментирована
			</P>
			<P>2048<BR>
				Предвыделение памяти в матлабоскаой строке CommanString</P>
			<P>2113<BR>
				StartDate и StartTime в инфо-панели<BR>
				Два оставшихся замечания - на завтра....</P>
			<P>---------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050804 чт<BR>
				</STRONG>Среда - похороны Фатюхина, на которые мы не попали (опоздали на 
				автобус). Попали только на поминки. Сегодня - освобождал Перфильевский 
				компьютер, разбирался с Шестопаловой с переводом данных в EEGLAB и вел с ней 
				прочие разговоры. Так что что-то околорабочее - только после восьми...</P>
			<P>2020<BR>
				Ликвидировано дублирование колонок списка при повторном открытии файла.</P>
			<P>2051<BR>
				Окружил запись и чтение файла крит. секциями - от неполадок со списком не 
				помогает :((((</P>
			<P>2116<BR>
				Все дело в том, что, пока в списке нажата мышиная клавиша, добавление в него не 
				проходит... И как этого избежать - непонятно :(((</P>
			<P>2138<BR>
				Нет, я не понимаю, как можно этого избежать: как только клавиша в списке 
				нажимается, запощенные сообщения перестают доходить до MainFrame&nbsp; - и 
				просто куда-то деваются :((((</P>
			<P>---------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050805 пт</STRONG></P>
			<P>1320<BR>
				Все утро расследовал попведение списка - даже думал, что придется плюнуть.... 
				Но вроде бы победил:<BR>
				// Мне пришлось завести свой класс списка, так как обычный майкрософтовский // 
				контрол при нажатии на мышиную кнопку (как левую, так и правую) входил в 
				модальный цикл // глотающий все сообщения - вплоть до отпускания кнопки. 
				Добавленная ф-ия PreTranslateMessage // собственно делает только одно - 
				помещает сразу же за сообщением о нажатии кнопки сообщение о ее // поднятии. 
				Вроде бы это помогает....
			</P>
			<P>1420<BR>
				Прописаны незавимые масштабы для биполяров. Всего за час!!! Фантастика... 
				Осталось их сохранять....</P>
			<P>1426<BR>
				Ага - и сохранение биполяров тоже работает...
			</P>
			<P>1441<BR>
				Пишу в аннотации установленные и снятые биты. Нужно их проэкспортировать в 
				матлаб.</P>
			<P>1451<BR>
				Дефолтовая длина&nbsp;записи 1000 мс</P>
			<P>1513<BR>
				Экспорт побитовых данных тоже проходит (TSET и TCLR)</P>
			<P>2130<BR>
				Написал очередной документ, подправил about-box.</P>
			<P>======================================================================================</P>
			<P><STRONG>050812 -</STRONG>
				<BR>
				проведены тесты на правильность децимации. Похоже, что промахиваюсь на точку 
				при непрерывной записи</P>
			<P><STRONG><EM><U>050815-050917<BR>
							отпуск на Острове</U></EM></STRONG></P>
			<P>======================================================================================</P>
			<P><STRONG>050920 вт</STRONG></P>
			<P>Первое знакомство с HTMLhelp и его присобачиванием к программе</P>
			<P>---------------------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>050921 ср</STRONG></P>
			<P>Продолжаю возиться с присобачиванием хелпа. Постигаю, какие там нужны сообщения 
				- и какие флаги в проперти-шитах и страницах.</P>
			<P>Чтобы не лезло лишнего, во время работы с установками хелп из основного окна 
				вызываться не должен!!! Отслеживаю по запрещению основгого окна (установки-то 
				немодальны).</P>
			<P>Попутно выяснилось, что при закрытии окна установок кнопкой SC_CLOSE я не 
				разрешал главное окно программы.</P>
			<P>======================================================================================</P>
			<P><STRONG>051031</STRONG></P>
			<P>Введен глобальный флаг TRIAL, цель - производство "пробной" версии с 
				ограничением на число вводимых каналов (16 пинов и 8 тачпруфов)</P>
			<P>======================================================================================</P>
			<P><STRONG>051115 вт</STRONG></P>
			<P>Массированные изменения, связанные с совместимостью с Mk2-системой (увеличенное 
				количество каналов etc). Попутно пришлось пересмотреть и поведение в режиме 0 
				(я его практически запрещал - а это, тем не менее, практически рабочий режим). 
				Программа выложена на diz-vara.narod.ru</P>
			<P>=========================================================================================</P>
			<P><STRONG>051128 пн</STRONG></P>
			<P>При открытии файла параметры триггера (его длина в отсчетах) брались из канала 
				номер 1, а не из текущенго, что привело к неправильному рисованию тригканала в 
				ситуации с децимацией аналогвых и не-децимацией триггерного.</P>
			<P>Остается вопрос с перекосом первой точки реализации - вроде бы наблюдается лишь 
				при децимации.</P>
			<P>===========================================================================================</P>
			<P><STRONG>051206 вт</STRONG></P>
			<P>- исправлена ситуация с запоминанием кодов экспериментаторов (использовалось не 
				то число - m_nInvNum вместо m_nResNum)</P>
			<P>18:58<BR>
				Попытки найти "смешение каналов" (первая точка - из предыдущего канала). 
				Получается, что я не рано начинаю (беру пред. канал). Я поздно кончаю - и 
				именно в случае с недецимацией тригканала.<BR>
				&nbsp; Ситуация следующая. Я проверяю - по окончании канального (и вложенного в 
				него децимационного) цикла только счетчик тригканала. Если оного, скажем, в 4 
				раза больше - то может возникнуть ситуация, когда тригканал еще не дописался 
				(осталось, скажем, 2 или 3 точки) - а данные-то уже все!!! Соответственно, при 
				следующем заходе я попытаюсь записать данные... Но вот с какой стати они 
				попадут именно туда, куда надо???????<BR>
				Я не рано начинаю - я поздно кончаю...<BR>
				Флаг начала анализируется ВНУТРИ деццикла - то есть действительно есть 
				возможность... Но возможность чего????
				<BR>
				Да: получается, что я начну с точки, соотв. началу деццикла - и тогда попытаюсь 
				записать на точку больше (в данных). Ну а чего я хочу??? Что НА САМОМ ДЕЛЕ 
				нужно делать в такой ситуации???<BR>
				Тем более, что ситуаций может быть две:
				<BR>
				- окончание одиночной реализации - кончить и все тут<BR>
				- продолжающаяся запись - я должен переключиться на след. буфер...</P>
			<P>ERGO<BR>
				Проверять я должен внутри деццикла!!! НО???? Проверять я при том должен ТОЛЬКО 
				тригканал!!! Если же я буду проверять любой канал - то могу получить ситуацию с 
				парой недостающих точек на тригканале с заполненными данными. Возможны ли 
				подводные камни в случае с проверкой только тригканала???&nbsp; Возможные 
				ситуации:
				<BR>
				- я начинаю с тригканала. Первая точка ввелась. Вторая хочет ппереключения 
				буфера. Правильно ли это??? ДА! По всему получается, что это правильно - так 
				как данные при этом уже заполнены.<BR>
				- я начинаю с тригканала. Ввелись ВСЕ децточки (скажем, четыре при соотв. 
				коэффициенте). И тут наступил конец буфера. Я переключусь. НО!!!!!!!!!!!!!!!!! 
				Данные я при этом тоже переключу на новый буфер - а на самом деле делать этого 
				не нужно....</P>
			<P>Но такая ситуация возникает только если проверять на границу буфера ПОСЛЕ 
				положения очередной точки ююю А если до???? Тогда я буду проверять... А что я 
				буду проверять...
			</P>
			<P>=====================================================================================</P>
			<P><STRONG>051207 ср</STRONG></P>
			<P>Попробовал перенести ф-ию переключения на новый буфер вовнутрь - но прокололся 
				(там - слишком много завязок). Перенес ее наружу, но вперед - все те же самые 
				проблемы....</P>
			<P>21:32 НАШЕЛ!!!!<BR>
				Я после анализа пытался писать В ЛЮБОМ случае - то есть и тогда, когда буфер 
				закончился, и больше писать не нужно.... Сейчас скидываю флаг m_bWriting - но 
				нужно еще посмотреть, как было раньше....</P>
			<P>========================================================================================</P>
			<P><STRONG>051212 пн</STRONG></P>
			<P>По итогам очередного (пятничного) эксперимента исправлено следующее:</P>
			<P><BR>
				<STRONG><FONT color="#000099">- непогашение тултипов в диалогах - просто прячу 
						тултиповые окна (CStatMap::OnMouseMove)<BR>
						- при любом открытом дочернем окне не появлялись тултипы в основном тулбаре - 
						из-за перехвата ф-ией CDlgView::PreTranslateMessage() сообщения WM_TIMER - 
						исправлено фильтрацией сообщений по хэндлу окна (если не свое - то не обращаем 
						внимания)<BR>
						- путаница с контролами в SnapDlg - исправлено наполовину вручную (приводила к 
						перемещению надписи Scroll и не-перемещению единиц измерения биполяров)<BR>
						- В меню введено File-&gt;Close</FONT></STRONG></P>
			<P><STRONG><FONT color="#000099">Осталось - отключение скринсейвера<BR>
						19:13 - отключение сделано, с доп. флагом. Работает или нет - не проверял. 
						Выпущен релиз alpha0.06</FONT></STRONG></P>
			<P>==============================================================================//</P>
			<P><STRONG>051216 пт</STRONG></P>
			<P>1150 - кнопка As Previous в CHeaderDlg - приводит диалог в состояние "как 
				предыдущий".</P>
			<P>1217 - добавлен комбобокс с кодами стимулов.</P>
			<P>=========================================================================<BR>
				=========================================================================<BR>
				=========================================================================</P>
			<P><STRONG><EM><U><FONT style="BACKGROUND-COLOR: #ff0066">2006</FONT></U></EM></STRONG></P>
			<P>=========================================================================</P>
			<P><STRONG>060123 пн</STRONG></P>
			<P>По результатам пятничного эксперимента отмечены следующие баги:<BR>
				<STRONG><FONT color="#cc0066">- вылетаю при смене конфигураций<BR>
						- отлов лишних меток (??? непонятно - дело это в воспринимающей или же 
						стимулирующей программе???)<BR>
					</FONT><FONT color="#000099">- появление первой же перекрывающейся реализации 
						приводит к неправильному вводу всех дальнейших реализаций<BR>
					</FONT><FONT color="#000099">- в листе не отображаются смещения электродов!!!</FONT></STRONG></P>
			<P>1513<BR>
				CListPanel::m_Map - при вводе нового файла перерисовывается также, как и в 
				хардовой панели.</P>
			<P>1710<BR>
				Локализовано: проблема присутствует в версии от 051207, но ее еще нет в версии 
				от 051229</P>
			<P>--------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>060125 ср</STRONG></P>
			<P>Увы, но ни в понедельник вечером, ни во вторник не то чтобы поразмышлять - 
				просто подумать над проблемой не пришлось: нас ждала ограбленная квартира 
				(пострадала, собственно, одна Марина) - и связанные с этим хлопоты (менял 
				замок)</P>
			<P>Сегодня, к шести часам вечера, вроде бы понял, что проблема заключается во флаге <STRONG>
					m_bWriting</STRONG>. Так получается, что я его снимаю при окончании первого 
				же из перекрывающихся буферов - а вновь он ставится лишь когда приходит новый 
				триггер. Нужно меняь логику. Посмотрим, как он использовался в старой (рабочей) 
				версии:</P>
			<P>//// внутри цикла по каналам-повторам<BR>
				- <EM>проверялся </EM>при приходе мануального старта (если стоит, новый пуск не 
				происходит)<BR>
				- <EM>устанавливался</EM> после вызова WritePre (triggered)<BR>
				- <EM>проверялся</EM> после провеки флагов if (bNeedNew &amp;&amp; !m_bWriting) 
				//пришел свежий гейт - а запись не ведется<BR>
				&nbsp;&nbsp; для преотвращения начала новой гейт-записи при наличии текущей<BR>
				- <EM>устанавливался</EM> при начале новой гейт-записи<BR>
				- <EM>проверялся</EM> перед собственно занесением данных в буфер</P>
			<P>///// после цикла по каналам-повторам - но в цикле по точкам<BR>
				- <EM>обнулялся</EM> перед проверкой всех буферов<BR>
				- <EM>выставлялся</EM>, если велась запись хотя бы в один из буферов</P>
			<P>/// после цикла по отсчетам - проверялся перед записью на диск</P>
			<P>&nbsp;</P>
			<P>1922<BR>
				<STRONG><FONT color="#000099">Поборол</FONT></STRONG>!!! Нужно было:<BR>
				- не проверять флаг перед проверкой буферов (она должна вестись лишь по 
				буферным флагам)<BR>
				- если буфер недописан, поднимать флаг!</P>
			<P>-----------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>060130 пн</STRONG></P>
			<P>По результатам пятничного эксперимента: ошибка в определении частоты прочитанной 
				из файла. Возникала в случае некруглой длительности из-за того, что в файле 
				собственно частота не кодировалась - только длительность записи и кол-во 
				отсчетов на канал, в итоге частота получалась делением, и могла быть не 
				круглой; после отбрасывания дробной части я получал 511 Гц (а мог бы и 513) - 
				из-за чего не срабатыали все фильтры. Исправлено заменой целочисленных расчетов 
				на плавающие с правильным округлением.</P>
			<P>----------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>060202 чт</STRONG></P>
			<P>1710<BR>
				Инициализация каталогов коффайлов из существующего имени.</P>
			<P>1738<BR>
				Баг с подкрашиванием индикаторов в CHardDlg после смены конфигурации:<BR>
				Причина - повторный принудительный вызов инициализации диалога, а уже там:<BR>
				- заново создавал кисти (что могло быть нехорошо)<BR>
				- инициализировал обе кисти красным</P>
			<P>Исправлено правильной инициализацией всех переменных (и недопущением повторной 
				инициализации)</P>
			<P>1800<BR>
				Запоминание не только полного пути к файлу конфигурации, но и его имени. 
				Отображение конфигурации в тайтлбаре главного окна (при отсутствии открытых 
				файлов).</P>
			<P>1805<BR>
				Тот же тайтл будет отзваниваться и в заголовках диалогов чтения и сохранения 
				кофигураций.</P>
			<P><BR>
				-------------------------------------------------------------------------------------------------------------------------------------</P>
			<P><STRONG>060210 пт</STRONG></P>
			<P>Продолжаю борьбу с вылетами при смене конфигураций:<BR>
				- заключил чтение конфигурации в крит. секцию таймера (чтобы не было набегов)<BR>
				-&nbsp;делаю m_nActChans = -1; -&nbsp;для&nbsp;гарантированной повторной 
				инициализации</P>
			<P>1257 -&nbsp;не помогает. После какого-то кол-ва триггерных (,???) записей при 
				переключении все равно вылетаем - причем можем и сразу....</P>
			<P>Добавил закрытие драйвера&nbsp;и устанвку m_dwMode в нецензурное состояние.<BR>
				Вроде бы помогает - хотя не уверен :((((</P>
			<P><STRONG><FONT color="#cc0066">У меня проблемы с отображением коротких тригсигналов при 
						большой длительности развертки!!!</FONT></STRONG></P>
			<P>.</P>
			<P>&nbsp;</P>
	</BODY>
</HTML>
